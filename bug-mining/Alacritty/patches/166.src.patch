diff --git a/CHANGELOG.md b/CHANGELOG.md
index 10f43787..f9c71df0 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -67,6 +67,7 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
 - `Add` and `Subtract` keys are now named `NumpadAdd` and `NumpadSubtract` respectively
 - Feature checking when cross compiling between different operating systems
 - Crash when writing to the clipboard fails on Wayland
+- Crash with large negative `font.offset.x/y`
 
 ## 0.5.0
 
diff --git a/alacritty/src/cursor.rs b/alacritty/src/cursor.rs
index 2ee2916c..8c782185 100644
--- a/alacritty/src/cursor.rs
+++ b/alacritty/src/cursor.rs
@@ -1,7 +1,5 @@
 //! Helpers for creating different cursor glyphs from font metrics.
 
-use std::cmp;
-
 use crossfont::{BitmapBuffer, Metrics, RasterizedGlyph};
 
 use alacritty_terminal::ansi::CursorStyle;
@@ -15,10 +13,12 @@ pub fn get_cursor_glyph(
     cursor_thickness: f64,
 ) -> RasterizedGlyph {
     // Calculate the cell metrics.
-    let height = metrics.line_height as i32 + i32::from(offset_y);
-    let mut width = metrics.average_advance as i32 + i32::from(offset_x);
-
-    let line_width = cmp::max((cursor_thickness * f64::from(width)).round() as i32, 1);
+    //
+    // NOTE: With Rust 1.47+ `f64 as usize` is defined to clamp automatically:
+    // https://github.com/rust-lang/rust/commit/14d608f1d8a0b84da5f3bccecb3efb3d35f980dc
+    let height = (metrics.line_height + f64::from(offset_y)).max(1.) as usize;
+    let mut width = (metrics.average_advance + f64::from(offset_x)).max(1.) as usize;
+    let line_width = (cursor_thickness * width as f64).round().max(1.) as usize;
 
     // Double the cursor width if it's above a double-width glyph.
     if is_wide {
@@ -35,41 +35,41 @@ pub fn get_cursor_glyph(
 }
 
 /// Return a custom underline cursor character.
-pub fn get_underline_cursor_glyph(width: i32, line_width: i32) -> RasterizedGlyph {
+pub fn get_underline_cursor_glyph(width: usize, line_width: usize) -> RasterizedGlyph {
     // Create a new rectangle, the height is relative to the font width.
-    let buf = vec![255u8; (width * line_width * 3) as usize];
+    let buf = vec![255u8; width * line_width * 3];
 
     // Create a custom glyph with the rectangle data attached to it.
     RasterizedGlyph {
         c: ' ',
-        top: line_width,
+        top: line_width as i32,
         left: 0,
-        height: line_width,
-        width,
+        height: line_width as i32,
+        width: width as i32,
         buf: BitmapBuffer::RGB(buf),
     }
 }
 
 /// Return a custom beam cursor character.
-pub fn get_beam_cursor_glyph(height: i32, line_width: i32) -> RasterizedGlyph {
+pub fn get_beam_cursor_glyph(height: usize, line_width: usize) -> RasterizedGlyph {
     // Create a new rectangle that is at least one pixel wide
-    let buf = vec![255u8; (line_width * height * 3) as usize];
+    let buf = vec![255u8; line_width * height * 3];
 
     // Create a custom glyph with the rectangle data attached to it
     RasterizedGlyph {
         c: ' ',
-        top: height,
+        top: height as i32,
         left: 0,
-        height,
-        width: line_width,
+        height: height as i32,
+        width: line_width as i32,
         buf: BitmapBuffer::RGB(buf),
     }
 }
 
 /// Returns a custom box cursor character.
-pub fn get_box_cursor_glyph(height: i32, width: i32, line_width: i32) -> RasterizedGlyph {
+pub fn get_box_cursor_glyph(height: usize, width: usize, line_width: usize) -> RasterizedGlyph {
     // Create a new box outline rectangle.
-    let mut buf = Vec::with_capacity((width * height * 3) as usize);
+    let mut buf = Vec::with_capacity(width * height * 3);
     for y in 0..height {
         for x in 0..width {
             if y < line_width
@@ -85,14 +85,28 @@ pub fn get_box_cursor_glyph(height: i32, width: i32, line_width: i32) -> Rasteri
     }
 
     // Create a custom glyph with the rectangle data attached to it.
-    RasterizedGlyph { c: ' ', top: height, left: 0, height, width, buf: BitmapBuffer::RGB(buf) }
+    RasterizedGlyph {
+        c: ' ',
+        top: height as i32,
+        left: 0,
+        height: height as i32,
+        width: width as i32,
+        buf: BitmapBuffer::RGB(buf),
+    }
 }
 
 /// Return a custom block cursor character.
-pub fn get_block_cursor_glyph(height: i32, width: i32) -> RasterizedGlyph {
+pub fn get_block_cursor_glyph(height: usize, width: usize) -> RasterizedGlyph {
     // Create a completely filled glyph.
-    let buf = vec![255u8; (width * height * 3) as usize];
+    let buf = vec![255u8; width * height * 3];
 
     // Create a custom glyph with the rectangle data attached to it.
-    RasterizedGlyph { c: ' ', top: height, left: 0, height, width, buf: BitmapBuffer::RGB(buf) }
+    RasterizedGlyph {
+        c: ' ',
+        top: height as i32,
+        left: 0,
+        height: height as i32,
+        width: width as i32,
+        buf: BitmapBuffer::RGB(buf),
+    }
 }
diff --git a/alacritty/src/display.rs b/alacritty/src/display.rs
index 8a6cd220..600ce2a4 100644
--- a/alacritty/src/display.rs
+++ b/alacritty/src/display.rs
@@ -691,8 +691,8 @@ fn compute_cell_size(config: &Config, metrics: &crossfont::Metrics) -> (f32, f32
     let offset_x = f64::from(config.ui_config.font.offset.x);
     let offset_y = f64::from(config.ui_config.font.offset.y);
     (
-        ((metrics.average_advance + offset_x) as f32).floor().max(1.),
-        ((metrics.line_height + offset_y) as f32).floor().max(1.),
+        (metrics.average_advance + offset_x).floor().max(1.) as f32,
+        (metrics.line_height + offset_y).floor().max(1.) as f32,
     )
 }
 
