diff --git a/CHANGELOG.md b/CHANGELOG.md
index ffdfc8c1..9609ecc7 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -10,6 +10,7 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
 ### Fixed
 
 - Character `;` inside the `URI` in `OSC 8` sequence breaking the URI
+- Selection on last line not updating correctly on resize
 
 ## 0.12.0
 
diff --git a/alacritty/src/display/content.rs b/alacritty/src/display/content.rs
index c062ba9b..ca49c01a 100644
--- a/alacritty/src/display/content.rs
+++ b/alacritty/src/display/content.rs
@@ -199,7 +199,7 @@ pub struct RenderableCellExtra {
 }
 
 impl RenderableCell {
-    fn new<'a>(content: &mut RenderableContent<'a>, cell: Indexed<&Cell>) -> Self {
+    fn new(content: &mut RenderableContent<'_>, cell: Indexed<&Cell>) -> Self {
         // Lookup RGB values.
         let mut fg = Self::compute_fg_rgb(content, cell.fg, cell.flags);
         let mut bg = Self::compute_bg_rgb(content, cell.bg);
diff --git a/alacritty/src/display/mod.rs b/alacritty/src/display/mod.rs
index f1757ae6..4d9c1540 100644
--- a/alacritty/src/display/mod.rs
+++ b/alacritty/src/display/mod.rs
@@ -588,11 +588,10 @@ impl Display {
         });
     }
 
+    // XXX: this function must not call to any `OpenGL` related tasks. Renderer updates are
+    // performed in [`Self::process_renderer_update`] right befor drawing.
+    //
     /// Process update events.
-    ///
-    /// XXX: this function must not call to any `OpenGL` related tasks. Only logical update
-    /// of the state is being performed here. Rendering update takes part right before the
-    /// actual rendering.
     pub fn handle_update<T>(
         &mut self,
         terminal: &mut Term<T>,
@@ -666,14 +665,11 @@ impl Display {
         self.size_info = new_size;
     }
 
+    // NOTE: Renderer updates are split off, since platforms like Wayland require resize and other
+    // OpenGL operations to be performed right before rendering. Otherwise they could lock the
+    // back buffer and render with the previous state. This also solves flickering during resizes.
+    //
     /// Update the state of the renderer.
-    ///
-    /// NOTE: The update to the renderer is split from the display update on purpose, since
-    /// on some platforms, like Wayland, resize and other OpenGL operations must be performed
-    /// right before rendering, otherwise they could lock the back buffer resulting in
-    /// rendering with the buffer of old size.
-    ///
-    /// This also resolves any flickering, since the resize is now synced with frame callbacks.
     pub fn process_renderer_update(&mut self) {
         let renderer_update = match self.pending_renderer_update.take() {
             Some(renderer_update) => renderer_update,
diff --git a/alacritty/src/event.rs b/alacritty/src/event.rs
index 2ccd42cb..9a27963c 100644
--- a/alacritty/src/event.rs
+++ b/alacritty/src/event.rs
@@ -796,7 +796,7 @@ impl<'a, N: Notify + 'a, T: EventListener> input::ActionContext<T> for ActionCon
             // We remove `\x1b` to ensure it's impossible for the pasted text to write the bracketed
             // paste end escape `\x1b[201~` and `\x03` since some shells incorrectly terminate
             // bracketed paste on its receival.
-            let filtered = text.replace('\x1b', "").replace('\x03', "");
+            let filtered = text.replace(['\x1b', '\x03'], "");
             self.write_to_pty(filtered.into_bytes());
 
             self.write_to_pty(&b"\x1b[201~"[..]);
diff --git a/alacritty/src/renderer/text/builtin_font.rs b/alacritty/src/renderer/text/builtin_font.rs
index f2c0e3ea..06eb5bc0 100644
--- a/alacritty/src/renderer/text/builtin_font.rs
+++ b/alacritty/src/renderer/text/builtin_font.rs
@@ -719,9 +719,8 @@ impl Canvas {
         let v_line_bounds = (v_line_bounds.0 as usize, v_line_bounds.1 as usize);
         let max_transparancy = 0.5;
 
-        for (radius_y, radius_x) in (h_line_bounds.0..h_line_bounds.1)
-            .into_iter()
-            .zip((v_line_bounds.0..v_line_bounds.1).into_iter())
+        for (radius_y, radius_x) in
+            (h_line_bounds.0..h_line_bounds.1).zip(v_line_bounds.0..v_line_bounds.1)
         {
             let radius_x = radius_x as f32;
             let radius_y = radius_y as f32;
diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index fe9c7794..3513aa0e 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -611,6 +611,10 @@ impl<T> Term<T> {
         delta = cmp::min(cmp::max(delta, min_delta), history_size as i32);
         self.vi_mode_cursor.point.line += delta;
 
+        let is_alt = self.mode.contains(TermMode::ALT_SCREEN);
+        self.grid.resize(!is_alt, num_lines, num_cols);
+        self.inactive_grid.resize(is_alt, num_lines, num_cols);
+
         // Invalidate selection and tabs only when necessary.
         if old_cols != num_cols {
             self.selection = None;
@@ -618,14 +622,11 @@ impl<T> Term<T> {
             // Recreate tabs list.
             self.tabs.resize(num_cols);
         } else if let Some(selection) = self.selection.take() {
-            let range = Line(0)..Line(num_lines as i32);
+            let max_lines = cmp::max(num_lines, old_lines) as i32;
+            let range = Line(0)..Line(max_lines);
             self.selection = selection.rotate(self, &range, -delta);
         }
 
-        let is_alt = self.mode.contains(TermMode::ALT_SCREEN);
-        self.grid.resize(!is_alt, num_lines, num_cols);
-        self.inactive_grid.resize(is_alt, num_lines, num_cols);
-
         // Clamp vi cursor to viewport.
         let vi_point = self.vi_mode_cursor.point;
         let viewport_top = Line(-(self.grid.display_offset() as i32));
