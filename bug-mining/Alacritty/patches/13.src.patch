diff --git a/src/term/cell.rs b/src/term/cell.rs
index 98d46bf2..18e03dee 100644
--- a/src/term/cell.rs
+++ b/src/term/cell.rs
@@ -77,6 +77,10 @@ impl Cell {
         self.flags.contains(BOLD)
     }
 
+    pub fn inverse(&self) -> bool {
+        self.flags.contains(INVERSE)
+    }
+
     pub fn new(c: char, fg: Color, bg: Color) -> Cell {
         Cell {
             c: c.into(),
@@ -86,17 +90,6 @@ impl Cell {
         }
     }
 
-    /// Get foreground and background colors adjusted for INVERSE flag
-    ///
-    /// First color is the foreground, second color is the background.
-    pub fn colors(&self, force_invert: bool) -> (&Color, &Color) {
-        if self.flags.contains(INVERSE) || force_invert {
-            (&self.bg, &self.fg)
-        } else {
-            (&self.fg, &self.bg)
-        }
-    }
-
     #[inline]
     pub fn is_empty(&self) -> bool {
         self.c == ' ' &&
diff --git a/src/term/mod.rs b/src/term/mod.rs
index 6cbd07d7..bbc3f1aa 100644
--- a/src/term/mod.rs
+++ b/src/term/mod.rs
@@ -309,12 +309,12 @@ impl<'a> Iterator for RenderableCellsIter<'a> {
                     (*cell, selected)
                 };
 
-                // `Color` fg, bg
-                let (fg, bg) = cell.colors(selected);
-
-                // `Rgb` fg, bg
-                let fg = self.compute_fg_rgb(fg, &cell);
-                let bg = self.compute_bg_rgb(bg);
+                // Apply inversion and lookup RGB values
+                let (fg, bg) = if selected || cell.inverse() {
+                    (self.compute_bg_rgb(&cell.bg), self.compute_fg_rgb(&cell.fg, &cell))
+                } else {
+                    (self.compute_fg_rgb(&cell.fg, &cell), self.compute_bg_rgb(&cell.bg))
+                };
 
                 return Some(RenderableCell {
                     line: line,
