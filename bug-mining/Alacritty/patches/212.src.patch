diff --git a/CHANGELOG.md b/CHANGELOG.md
index 797c0658..d5342d2c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -21,6 +21,9 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
 - Crash when resizing during vi mode
 - Unintentional text selection range change after leaving vi mode
 - Deadlock on Windows during high frequency output
+- Search without vi mode not starting at the correct location when scrolled into history
+- Crash when starting a vi mode search from the bottommost line
+- Original scroll position not restored after canceling search
 
 ## 0.8.0
 
diff --git a/alacritty/src/event.rs b/alacritty/src/event.rs
index 78cc6cb6..37d28bb9 100644
--- a/alacritty/src/event.rs
+++ b/alacritty/src/event.rs
@@ -421,11 +421,12 @@ impl<'a, N: Notify + 'a, T: EventListener> input::ActionContext<T> for ActionCon
             self.search_state.origin = self.terminal.vi_mode_cursor.point;
             self.search_state.display_offset_delta = 0;
         } else {
-            let screen_lines = self.terminal.screen_lines();
+            let viewport_top = Line(-(self.terminal.grid().display_offset() as i32)) - 1;
+            let viewport_bottom = viewport_top + self.terminal.bottommost_line();
             let last_column = self.terminal.last_column();
             self.search_state.origin = match direction {
-                Direction::Right => Point::new(Line(0), Column(0)),
-                Direction::Left => Point::new(Line(screen_lines as i32 - 2), last_column),
+                Direction::Right => Point::new(viewport_top, Column(0)),
+                Direction::Left => Point::new(viewport_bottom, last_column),
             };
         }
 
@@ -770,7 +771,8 @@ impl<'a, N: Notify + 'a, T: EventListener> ActionContext<'a, N, T> {
         // Reset display offset and cursor position.
         self.terminal.scroll_display(Scroll::Delta(self.search_state.display_offset_delta));
         self.search_state.display_offset_delta = 0;
-        self.terminal.vi_mode_cursor.point = self.search_state.origin;
+        self.terminal.vi_mode_cursor.point =
+            self.search_state.origin.grid_clamp(self.terminal, Boundary::Grid);
 
         *self.dirty = true;
     }
@@ -805,7 +807,7 @@ impl<'a, N: Notify + 'a, T: EventListener> ActionContext<'a, N, T> {
 
                 // Store number of lines the viewport had to be moved.
                 let display_offset = self.terminal.grid().display_offset();
-                self.search_state.display_offset_delta = old_offset - display_offset as i32;
+                self.search_state.display_offset_delta += old_offset - display_offset as i32;
 
                 // Since we found a result, we require no delayed re-search.
                 self.scheduler.unschedule(TimerId::DelayedSearch);
diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index ccec0166..29556517 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -512,9 +512,9 @@ impl<T> Term<T> {
 
         // Clamp vi cursor to viewport.
         let vi_point = self.vi_mode_cursor.point;
-        let viewport_bottom = Line(-(self.grid.display_offset() as i32));
-        let viewport_top = viewport_bottom + self.bottommost_line();
-        self.vi_mode_cursor.point.line = max(min(vi_point.line, viewport_top), viewport_bottom);
+        let viewport_top = Line(-(self.grid.display_offset() as i32));
+        let viewport_bottom = viewport_top + self.bottommost_line();
+        self.vi_mode_cursor.point.line = max(min(vi_point.line, viewport_bottom), viewport_top);
         self.vi_mode_cursor.point.column = min(vi_point.column, self.last_column());
 
         // Reset scrolling region.
