diff --git a/CHANGELOG.md b/CHANGELOG.md
index 17189d40..9bc3098a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -49,6 +49,7 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
 - Freeze when the vi cursor is on the scrollback and scrollback clear is invoked
 - Vi cursor on topmost of the display moving downward when scrolled into history with active output
 - Input lag on Wayland with Nvidia binary driver
+- Crash when hovering the mouse over fullwidth characters
 
 ### Removed
 
diff --git a/alacritty_terminal/src/term/search.rs b/alacritty_terminal/src/term/search.rs
index 07403b67..e34fd1b4 100644
--- a/alacritty_terminal/src/term/search.rs
+++ b/alacritty_terminal/src/term/search.rs
@@ -205,6 +205,7 @@ impl<T> Term<T> {
         let mut state = dfa.start_state();
         let mut last_wrapped = false;
         let mut regex_match = None;
+        let mut done = false;
 
         let mut cell = iter.cell();
         self.skip_fullwidth(&mut iter, &mut cell, direction);
@@ -239,7 +240,7 @@ impl<T> Term<T> {
             }
 
             // Stop once we've reached the target point.
-            if point == end {
+            if point == end || done {
                 break;
             }
 
@@ -254,7 +255,12 @@ impl<T> Term<T> {
                     iter.cell()
                 },
             };
+
+            // Check for completion before potentially skipping over fullwidth characters.
+            done = iter.point() == end;
+
             self.skip_fullwidth(&mut iter, &mut cell, direction);
+
             let wrapped = cell.flags.contains(Flags::WRAPLINE);
             c = cell.c;
 
@@ -700,6 +706,26 @@ mod tests {
         assert_eq!(term.regex_search_left(&dfas, start, end), Some(end..=start));
     }
 
+    #[test]
+    fn end_on_fullwidth() {
+        let term = mock_term("jarrðŸ¦‡");
+
+        let start = Point::new(Line(0), Column(0));
+        let end = Point::new(Line(0), Column(4));
+
+        // Ensure ending without a match doesn't loop indefinitely.
+        let dfas = RegexSearch::new("x").unwrap();
+        assert_eq!(term.regex_search_right(&dfas, start, end), None);
+
+        let dfas = RegexSearch::new("x").unwrap();
+        let match_end = Point::new(Line(0), Column(5));
+        assert_eq!(term.regex_search_right(&dfas, start, match_end), None);
+
+        // Ensure match is captured when only partially inside range.
+        let dfas = RegexSearch::new("jarrðŸ¦‡").unwrap();
+        assert_eq!(term.regex_search_right(&dfas, start, end), Some(start..=match_end));
+    }
+
     #[test]
     fn wrapping() {
         #[rustfmt::skip]
