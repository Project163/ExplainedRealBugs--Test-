diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1dcb9b23..cbe1ab17 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -26,8 +26,10 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 - Low resolution window decoration icon on Windows
 
 ### Fixed
+
 - Tabstops not being reset with `reset`
 - Selection not cleared when switching between main and alt grid
+- Fallback to `LC_CTYPE=UTF-8` on macOS without valid system locale
 
 ## 0.4.2
 
diff --git a/alacritty_terminal/src/lib.rs b/alacritty_terminal/src/lib.rs
index 6991ffdc..1bf35389 100644
--- a/alacritty_terminal/src/lib.rs
+++ b/alacritty_terminal/src/lib.rs
@@ -28,6 +28,7 @@ pub mod event;
 pub mod event_loop;
 pub mod grid;
 pub mod index;
+#[cfg(target_os = "macos")]
 pub mod locale;
 pub mod message_bar;
 pub mod meter;
diff --git a/alacritty_terminal/src/locale.rs b/alacritty_terminal/src/locale.rs
index 40c915b5..183b4805 100644
--- a/alacritty_terminal/src/locale.rs
+++ b/alacritty_terminal/src/locale.rs
@@ -12,22 +12,62 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 #![allow(clippy::let_unit_value)]
-#![cfg(target_os = "macos")]
-use libc::{setlocale, LC_CTYPE};
+
 use std::env;
 use std::ffi::{CStr, CString};
 use std::os::raw::c_char;
-use std::ptr::null;
 use std::slice;
 use std::str;
 
+use libc::{setlocale, LC_ALL, LC_CTYPE};
+use log::debug;
 use objc::runtime::{Class, Object};
 
+const FALLBACK_LOCALE: &str = "UTF-8";
+
 pub fn set_locale_environment() {
-    let locale_id = unsafe {
+    let env_locale_c = CString::new("").unwrap();
+    let env_locale_ptr = unsafe { setlocale(LC_ALL, env_locale_c.as_ptr()) };
+    if !env_locale_ptr.is_null() {
+        let env_locale = unsafe { CStr::from_ptr(env_locale_ptr).to_string_lossy() };
+
+        // Assume `C` locale means unchanged, since it is the default anyways
+        if env_locale != "C" {
+            debug!("Using environment locale: {}", env_locale);
+            return;
+        }
+    }
+
+    let system_locale = system_locale();
+
+    // Set locale to system locale
+    let system_locale_c = CString::new(system_locale.clone()).expect("nul byte in system locale");
+    let lc_all = unsafe { setlocale(LC_ALL, system_locale_c.as_ptr()) };
+
+    // Check if system locale was valid or not
+    if lc_all.is_null() {
+        // Use fallback locale
+        debug!("Using fallback locale: {}", FALLBACK_LOCALE);
+
+        let fallback_locale_c = CString::new(FALLBACK_LOCALE).unwrap();
+        unsafe { setlocale(LC_CTYPE, fallback_locale_c.as_ptr()) };
+
+        env::set_var("LC_CTYPE", FALLBACK_LOCALE);
+    } else {
+        // Use system locale
+        debug!("Using system locale: {}", system_locale);
+
+        env::set_var("LC_ALL", system_locale);
+    }
+}
+
+/// Determine system locale based on language and country code.
+fn system_locale() -> String {
+    unsafe {
         let locale_class = Class::get("NSLocale").unwrap();
         let locale: *const Object = msg_send![locale_class, currentLocale];
         let _: () = msg_send![locale_class, release];
+
         // `localeIdentifier` returns extra metadata with the locale (including currency and
         // collator) on newer versions of macOS. This is not a valid locale, so we use
         // `languageCode` and `countryCode`, if they're available (macOS 10.12+):
@@ -40,41 +80,26 @@ pub fn set_locale_environment() {
             msg_send![locale, respondsToSelector: sel!(countryCode)];
         let locale_id = if is_language_code_supported && is_country_code_supported {
             let language_code: *const Object = msg_send![locale, languageCode];
-            let country_code: *const Object = msg_send![locale, countryCode];
             let language_code_str = nsstring_as_str(language_code).to_owned();
             let _: () = msg_send![language_code, release];
+
+            let country_code: *const Object = msg_send![locale, countryCode];
             let country_code_str = nsstring_as_str(country_code).to_owned();
             let _: () = msg_send![country_code, release];
+
             format!("{}_{}.UTF-8", &language_code_str, &country_code_str)
         } else {
             let identifier: *const Object = msg_send![locale, localeIdentifier];
             let identifier_str = nsstring_as_str(identifier).to_owned();
             let _: () = msg_send![identifier, release];
+
             identifier_str + ".UTF-8"
         };
+
         let _: () = msg_send![locale, release];
+
         locale_id
-    };
-    // check if locale_id is valid
-    let locale_c_str = CString::new(locale_id.to_owned()).unwrap();
-    let locale_ptr = locale_c_str.as_ptr();
-    let locale_id = unsafe {
-        // save a copy of original setting
-        let original = setlocale(LC_CTYPE, null());
-        let saved_original = if original.is_null() {
-            CString::new("").unwrap()
-        } else {
-            CStr::from_ptr(original).to_owned()
-        };
-        // try setting `locale_id`
-        let modified = setlocale(LC_CTYPE, locale_ptr);
-        let result = if modified.is_null() { String::new() } else { locale_id };
-        // restore original setting
-        setlocale(LC_CTYPE, saved_original.as_ptr());
-        result
-    };
-
-    env::set_var("LANG", &locale_id);
+    }
 }
 
 const UTF8_ENCODING: usize = 4;
@@ -84,6 +109,3 @@ unsafe fn nsstring_as_str<'a>(nsstring: *const Object) -> &'a str {
     let len: usize = msg_send![nsstring, lengthOfBytesUsingEncoding: UTF8_ENCODING];
     str::from_utf8(slice::from_raw_parts(cstr as *const u8, len)).unwrap()
 }
-
-#[cfg(not(target_os = "macos"))]
-pub fn set_locale_environment() {}
