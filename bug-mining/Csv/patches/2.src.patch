diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java
index 55c21973..0cb637e9 100644
--- a/src/main/java/org/apache/commons/csv/CSVFormat.java
+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java
@@ -38,7 +38,6 @@ public class CSVFormat implements Serializable {
     private final char escape;
     private final boolean leadingSpacesIgnored;
     private final boolean trailingSpacesIgnored;
-    private final boolean unicodeEscapesInterpreted;
     private final boolean emptyLinesIgnored;
     private final String lineSeparator; // for outputs
     private final String[] header;
@@ -53,7 +52,7 @@ public class CSVFormat implements Serializable {
     static final char DISABLED = '\ufffe';
 
     /** Standard comma separated format as defined by <a href="http://tools.ietf.org/html/rfc4180">RFC 4180</a>. */
-    public static final CSVFormat DEFAULT = new CSVFormat(',', '"', DISABLED, DISABLED, true, true, false, true, CRLF, null);
+    public static final CSVFormat DEFAULT = new CSVFormat(',', '"', DISABLED, DISABLED, true, true, true, CRLF, null);
 
     /**
      * Excel file format (using a comma as the value delimiter).
@@ -66,10 +65,10 @@ public class CSVFormat implements Serializable {
      * 
      * <pre>CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');</pre>
      */
-    public static final CSVFormat EXCEL = new CSVFormat(',', '"', DISABLED, DISABLED, false, false, false, false, CRLF, null);
+    public static final CSVFormat EXCEL = new CSVFormat(',', '"', DISABLED, DISABLED, false, false, false, CRLF, null);
 
     /** Tab-delimited format, with quote; leading and trailing spaces ignored. */
-    public static final CSVFormat TDF = new CSVFormat('\t', '"', DISABLED, DISABLED, true, true, false, true, CRLF, null);
+    public static final CSVFormat TDF = new CSVFormat('\t', '"', DISABLED, DISABLED, true, true, true, CRLF, null);
 
     /**
      * Default MySQL format used by the <tt>SELECT INTO OUTFILE</tt> and
@@ -79,7 +78,7 @@ public class CSVFormat implements Serializable {
      * 
      * @see <a href="http://dev.mysql.com/doc/refman/5.1/en/load-data.html">http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>
      */
-    public static final CSVFormat MYSQL = new CSVFormat('\t', DISABLED, DISABLED, '\\', false, false, false, false, "\n", null);
+    public static final CSVFormat MYSQL = new CSVFormat('\t', DISABLED, DISABLED, '\\', false, false, false, "\n", null);
 
 
     /**
@@ -91,7 +90,6 @@ public class CSVFormat implements Serializable {
      * @param escape                    the char used to escape special characters in values
      * @param leadingSpacesIgnored      <tt>true</tt> when leading whitespaces should be ignored
      * @param trailingSpacesIgnored     <tt>true</tt> when trailing whitespaces should be ignored
-     * @param unicodeEscapesInterpreted <tt>true</tt> when unicode escapes should be interpreted
      * @param emptyLinesIgnored         <tt>true</tt> when the parser should skip emtpy lines
      * @param lineSeparator             the line separator to use for output
      * @param header                    the header
@@ -103,7 +101,6 @@ public class CSVFormat implements Serializable {
             char escape,
             boolean leadingSpacesIgnored,
             boolean trailingSpacesIgnored,
-            boolean unicodeEscapesInterpreted,
             boolean emptyLinesIgnored,
             String lineSeparator,
             String[] header) {
@@ -113,7 +110,6 @@ public class CSVFormat implements Serializable {
         this.escape = escape;
         this.leadingSpacesIgnored = leadingSpacesIgnored;
         this.trailingSpacesIgnored = trailingSpacesIgnored;
-        this.unicodeEscapesInterpreted = unicodeEscapesInterpreted;
         this.emptyLinesIgnored = emptyLinesIgnored;
         this.lineSeparator = lineSeparator;
         this.header = header;
@@ -176,7 +172,7 @@ public class CSVFormat implements Serializable {
             throw new IllegalArgumentException("The delimiter cannot be a line break");
         }
 
-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);
+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);
     }
 
     /**
@@ -200,7 +196,7 @@ public class CSVFormat implements Serializable {
             throw new IllegalArgumentException("The encapsulator cannot be a line break");
         }
         
-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);
+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);
     }
 
     boolean isEncapsulating() {
@@ -228,7 +224,7 @@ public class CSVFormat implements Serializable {
             throw new IllegalArgumentException("The comment start character cannot be a line break");
         }
         
-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);
+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);
     }
 
     /**
@@ -261,7 +257,7 @@ public class CSVFormat implements Serializable {
             throw new IllegalArgumentException("The escape character cannot be a line break");
         }
         
-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);
+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);
     }
 
     boolean isEscaping() {
@@ -285,7 +281,7 @@ public class CSVFormat implements Serializable {
      * @return A copy of this format with the specified left trimming behavior.
      */
     public CSVFormat withLeadingSpacesIgnored(boolean leadingSpacesIgnored) {
-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);
+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);
     }
 
     /**
@@ -305,7 +301,7 @@ public class CSVFormat implements Serializable {
      * @return A copy of this format with the specified right trimming behavior.
      */
     public CSVFormat withTrailingSpacesIgnored(boolean trailingSpacesIgnored) {
-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);
+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);
     }
 
     /**
@@ -316,28 +312,7 @@ public class CSVFormat implements Serializable {
      * @return A copy of this format with the specified trimming behavior.
      */
     public CSVFormat withSurroundingSpacesIgnored(boolean surroundingSpacesIgnored) {
-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, surroundingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);
-    }
-
-    /**
-     * Tells if unicode escape sequences (e.g. {@literal \u1234}) are turned into their corresponding character
-     * when parsing input.
-     * 
-     * @return <tt>true</tt> if unicode escape sequences are interpreted, <tt>false</tt> if they are left as is.
-     */
-    public boolean isUnicodeEscapesInterpreted() {
-        return unicodeEscapesInterpreted;
-    }
-
-    /**
-     * Returns a copy of this format with the specified unicode escaping behavior.
-     *
-     * @param unicodeEscapesInterpreted the escaping behavior, <tt>true</tt> to interpret unicode escape sequences,
-     *                                  <tt>false</tt> to leave the escape sequences as is.
-     * @return A copy of this format with the specified unicode escaping behavior.
-     */
-    public CSVFormat withUnicodeEscapesInterpreted(boolean unicodeEscapesInterpreted) {
-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);
+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);
     }
 
     /**
@@ -357,7 +332,7 @@ public class CSVFormat implements Serializable {
      * @return A copy of this format  with the specified empty line skipping behavior.
      */
     public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {
-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);
+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);
     }
 
     /**
@@ -377,7 +352,7 @@ public class CSVFormat implements Serializable {
      * @return A copy of this format using the specified output line separator
      */
     public CSVFormat withLineSeparator(String lineSeparator) {
-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);
+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);
     }
 
     String[] getHeader() {
@@ -399,7 +374,7 @@ public class CSVFormat implements Serializable {
      * @return A copy of this format using the specified header
      */
     public CSVFormat withHeader(String... header) {
-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);
+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java
index 00ec7aab..82b6d668 100644
--- a/src/main/java/org/apache/commons/csv/CSVParser.java
+++ b/src/main/java/org/apache/commons/csv/CSVParser.java
@@ -92,10 +92,6 @@ public class CSVParser implements Iterable<CSVRecord> {
     public CSVParser(Reader input, CSVFormat format) throws IOException {
         format.validate();
         
-        if (format.isUnicodeEscapesInterpreted()) {
-            input = new UnicodeUnescapeReader(input);
-        }
-        
         this.lexer = new CSVLexer(format, new ExtendedBufferedReader(input));
         
         initializeHeader(format);
diff --git a/src/main/java/org/apache/commons/csv/UnicodeUnescapeReader.java b/src/main/java/org/apache/commons/csv/UnicodeUnescapeReader.java
deleted file mode 100644
index 101ab2ed..00000000
--- a/src/main/java/org/apache/commons/csv/UnicodeUnescapeReader.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.csv;
-
-import java.io.IOException;
-import java.io.PushbackReader;
-import java.io.Reader;
-
-/**
- * Reader transforming unicode escape sequences (i.e \u0065) in the provided
- * stream into the corresponding unicode character.
- * 
- * @author Emmanuel Bourg
- * @version $Revision$, $Date$
- */
-class UnicodeUnescapeReader extends Reader {
-    private final PushbackReader reader;
-
-    /** The buffer used to read unicode escape sequences. */
-    private final char[] sequence = new char[5];
-
-    UnicodeUnescapeReader(Reader reader) {
-        this.reader = new PushbackReader(reader, sequence.length);
-    }
-
-    @Override
-    public int read(char[] cbuf, int offset, int length) throws IOException {
-        int count = 0;
-        for (int i = 0; i < length; i++) {
-            int c = reader.read();
-            
-            if (c == -1) {
-                return count == 0 ? -1 : count;
-            }
-            
-            if (c == '\\') {
-                int len = reader.read(sequence);
-                if (len == sequence.length && isUnicodeSequence(sequence)) {
-                    // unicode escape found
-                    c = Integer.parseInt(new String(sequence, 1, 4), 16);
-                    
-                } else if (len > 0) {
-                    // put the characters back in the stream
-                    reader.unread(sequence, 0, len);
-                }
-            }
-
-            cbuf[offset + i] = (char) c;
-            count++;
-        }
-        
-        return count;
-    }
-
-    private boolean isUnicodeSequence(char[] sequence) {
-        return 'u' == sequence[0]
-                && isHexadecimal(sequence[1])
-                && isHexadecimal(sequence[2])
-                && isHexadecimal(sequence[3])
-                && isHexadecimal(sequence[4]);
-    }
-
-    private boolean isHexadecimal(char c) {
-        return ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F');
-    }
-
-    @Override
-    public void close() throws IOException {
-        if (reader != null) {
-            reader.close();
-        }
-    }
-}
diff --git a/src/test/java/org/apache/commons/csv/CSVFormatTest.java b/src/test/java/org/apache/commons/csv/CSVFormatTest.java
index 33afeacb..81f52a77 100644
--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java
+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java
@@ -30,7 +30,7 @@ public class CSVFormatTest {
 
     @Test
     public void testImmutalibity() {
-        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, true, "\r\n", null);
+        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, "\r\n", null);
         
         format.withDelimiter('?');
         format.withEncapsulator('?');
@@ -40,7 +40,6 @@ public class CSVFormatTest {
         format.withLeadingSpacesIgnored(false);
         format.withTrailingSpacesIgnored(false);
         format.withEmptyLinesIgnored(false);
-        format.withUnicodeEscapesInterpreted(false);
         
         assertEquals('!', format.getDelimiter());
         assertEquals('!', format.getEncapsulator());
@@ -51,12 +50,11 @@ public class CSVFormatTest {
         assertTrue(format.isLeadingSpacesIgnored());
         assertTrue(format.isTrailingSpacesIgnored());
         assertTrue(format.isEmptyLinesIgnored());
-        assertTrue(format.isUnicodeEscapesInterpreted());
     }
 
     @Test
     public void testMutators() {
-        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, true, "\r\n", null);
+        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, "\r\n", null);
         
         assertEquals('?', format.withDelimiter('?').getDelimiter());
         assertEquals('?', format.withEncapsulator('?').getEncapsulator());
@@ -69,7 +67,6 @@ public class CSVFormatTest {
         assertFalse(format.withSurroundingSpacesIgnored(false).isLeadingSpacesIgnored());
         assertFalse(format.withSurroundingSpacesIgnored(false).isTrailingSpacesIgnored());
         assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());
-        assertFalse(format.withUnicodeEscapesInterpreted(false).isUnicodeEscapesInterpreted());
     }
 
     @Test
@@ -172,7 +169,6 @@ public class CSVFormatTest {
         assertEquals("comment start", CSVFormat.DEFAULT.getCommentStart(), format.getCommentStart());
         assertEquals("line separator", CSVFormat.DEFAULT.getLineSeparator(), format.getLineSeparator());
         assertEquals("escape", CSVFormat.DEFAULT.getEscape(), format.getEscape());
-        assertEquals("unicode escape", CSVFormat.DEFAULT.isUnicodeEscapesInterpreted(), format.isUnicodeEscapesInterpreted());
         assertEquals("trim left", CSVFormat.DEFAULT.isLeadingSpacesIgnored(), format.isLeadingSpacesIgnored());
         assertEquals("trim right", CSVFormat.DEFAULT.isTrailingSpacesIgnored(), format.isTrailingSpacesIgnored());
         assertEquals("empty lines", CSVFormat.DEFAULT.isEmptyLinesIgnored(), format.isEmptyLinesIgnored());
diff --git a/src/test/java/org/apache/commons/csv/CSVParserTest.java b/src/test/java/org/apache/commons/csv/CSVParserTest.java
index fe8fcbba..f9eee6f9 100644
--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java
+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java
@@ -283,7 +283,7 @@ public class CSVParserTest {
         };
 
 
-        CSVFormat format = new CSVFormat(',', '\'', CSVFormat.DISABLED, '/', false, false, true, true, "\r\n", null);
+        CSVFormat format = new CSVFormat(',', '\'', CSVFormat.DISABLED, '/', false, false, true, "\r\n", null);
 
         CSVParser parser = new CSVParser(code, format);
         List<CSVRecord> records = parser.getRecords();
@@ -312,7 +312,7 @@ public class CSVParserTest {
         };
 
 
-        CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, false, true, true, "\r\n", null);
+        CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, false, true, "\r\n", null);
 
         CSVParser parser = new CSVParser(code, format);
         List<CSVRecord> records = parser.getRecords();
@@ -356,30 +356,6 @@ public class CSVParserTest {
         assertTrue(CSVPrinterTest.equals(res_comments, records));
     }
 
-    @Test
-    public void testUnicodeEscape() throws Exception {
-        String code = "abc,\\u0070\\u0075\\u0062\\u006C\\u0069\\u0063";
-        CSVParser parser = new CSVParser(code, CSVFormat.DEFAULT.withUnicodeEscapesInterpreted(true));
-        final Iterator<CSVRecord> iterator = parser.iterator();
-        CSVRecord record = iterator.next();
-        assertEquals(2, record.size());
-        assertEquals("abc", record.get(0));
-        assertEquals("public", record.get(1));
-        assertFalse("Should not have any more records", iterator.hasNext());
-    }
-
-    @Test
-    public void testUnicodeEscapeMySQL() throws Exception {
-        String code = "abc\t\\u0070\\u0075\\u0062\\u006C\\u0069\\u0063";
-        CSVParser parser = new CSVParser(code, CSVFormat.MYSQL.withUnicodeEscapesInterpreted(true));
-        final Iterator<CSVRecord> iterator = parser.iterator();
-        CSVRecord record = iterator.next();
-        assertEquals(2, record.size());
-        assertEquals("abc", record.get(0));
-        assertEquals("public", record.get(1));
-        assertFalse("Should not have any more records", iterator.hasNext());
-    }
-
     @Test
     public void testCarriageReturnLineFeedEndings() throws IOException {
         String code = "foo\r\nbaar,\r\nhello,world\r\n,kanu";
