{"url":"https://api.github.com/repos/redis/redis/issues/3016","repository_url":"https://api.github.com/repos/redis/redis","labels_url":"https://api.github.com/repos/redis/redis/issues/3016/labels{/name}","comments_url":"https://api.github.com/repos/redis/redis/issues/3016/comments","events_url":"https://api.github.com/repos/redis/redis/issues/3016/events","html_url":"https://github.com/redis/redis/issues/3016","id":126952640,"node_id":"MDU6SXNzdWUxMjY5NTI2NDA=","number":3016,"title":"Bugs introduced in variadic MIGRATE on errors","user":{"login":"kevinmcgehee","id":7883533,"node_id":"MDQ6VXNlcjc4ODM1MzM=","avatar_url":"https://avatars.githubusercontent.com/u/7883533?v=4","gravatar_id":"","url":"https://api.github.com/users/kevinmcgehee","html_url":"https://github.com/kevinmcgehee","followers_url":"https://api.github.com/users/kevinmcgehee/followers","following_url":"https://api.github.com/users/kevinmcgehee/following{/other_user}","gists_url":"https://api.github.com/users/kevinmcgehee/gists{/gist_id}","starred_url":"https://api.github.com/users/kevinmcgehee/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kevinmcgehee/subscriptions","organizations_url":"https://api.github.com/users/kevinmcgehee/orgs","repos_url":"https://api.github.com/users/kevinmcgehee/repos","events_url":"https://api.github.com/users/kevinmcgehee/events{/privacy}","received_events_url":"https://api.github.com/users/kevinmcgehee/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":155760,"node_id":"MDU6TGFiZWwxNTU3NjA=","url":"https://api.github.com/repos/redis/redis/labels/critical%20bug","name":"critical bug","color":"e10c02","default":false,"description":null},{"id":158983717,"node_id":"MDU6TGFiZWwxNTg5ODM3MTc=","url":"https://api.github.com/repos/redis/redis/labels/cluster","name":"cluster","color":"fbca04","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":8,"created_at":"2016-01-15T20:29:25Z","updated_at":"2017-07-15T12:00:23Z","closed_at":"2017-07-15T12:00:23Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"In looking through the latest commits to the MIGRATE command to make it variadic, I’ve noticed some problems and am not clear about the expected behavior in error scenarios.\n\nhttps://github.com/antirez/redis/blob/d975baa35b7c1386bca4665e3fac5c7196a7dfa6/src/cluster.c#L4592\n\nFirst, the new lists allocated on 4603 and 4604 are not freed under all error scenarios, for example on lines 4639, 4645, 4647, 4674, leading to memory leaks. Similarly for newargv allocated on 4748 – it is not freed in the socket_err case.\n\nMore concerning, however, is the undefined behavior of migrating multiple keys where they are not all acknowledged by the receiver. In the loop on 4750, we will retry the entire command in some cases on socket errors. This is after we have potentially already queued a reply to the client with an error and potentially already deleted some of the keys from the source. If we retry (or even if we fail out) we never translate the command to a DEL to propagate what has been deleted to the replication/AOF stream. When we retry, if we’ve already deleted the item from the database, we're referencing invalid values, as well as doubly refcounting keys, etc.\n\nFor example, if I issue a MIGRATE dst port “” db timeout REPLACE KEY1 KEY2 KEY3 KEY4, we will send a RESTORE command for each of the four keys. Assume we process KEY1 and KEY2 appropriately, and delete them from the database. Let’s say we have trouble reading the response for KEY3 from the socket. We’ll possibly retry the command (going to try_again mark). We will again try to RESTORE all four keys to the destination. Meanwhile, the values corresponding to KEY1 and KEY2 have been freed.  If we’re able to get successful responses, we’ll try to delete the keys again (L4764). L4770 will increase the refcount of KEY1 and KEY2 a second time, which will result in the key being incorrectly refcounted twice and never freed.\n\nCould you take a look at the error handling here and clarify the expected behavior?\n","closed_by":{"login":"antirez","id":65632,"node_id":"MDQ6VXNlcjY1NjMy","avatar_url":"https://avatars.githubusercontent.com/u/65632?v=4","gravatar_id":"","url":"https://api.github.com/users/antirez","html_url":"https://github.com/antirez","followers_url":"https://api.github.com/users/antirez/followers","following_url":"https://api.github.com/users/antirez/following{/other_user}","gists_url":"https://api.github.com/users/antirez/gists{/gist_id}","starred_url":"https://api.github.com/users/antirez/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/antirez/subscriptions","organizations_url":"https://api.github.com/users/antirez/orgs","repos_url":"https://api.github.com/users/antirez/repos","events_url":"https://api.github.com/users/antirez/events{/privacy}","received_events_url":"https://api.github.com/users/antirez/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/redis/redis/issues/3016/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/redis/redis/issues/3016/timeline","performed_via_github_app":null,"state_reason":"completed"}