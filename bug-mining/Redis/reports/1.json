{"url":"https://api.github.com/repos/redis/redis/issues/121","repository_url":"https://api.github.com/repos/redis/redis","labels_url":"https://api.github.com/repos/redis/redis/issues/121/labels{/name}","comments_url":"https://api.github.com/repos/redis/redis/issues/121/comments","events_url":"https://api.github.com/repos/redis/redis/issues/121/events","html_url":"https://github.com/redis/redis/issues/121","id":1841372,"node_id":"MDU6SXNzdWUxODQxMzcy","number":121,"title":"Redis Cluster: implement the ASKING command","user":{"login":"antirez","id":65632,"node_id":"MDQ6VXNlcjY1NjMy","avatar_url":"https://avatars.githubusercontent.com/u/65632?v=4","gravatar_id":"","url":"https://api.github.com/users/antirez","html_url":"https://github.com/antirez","followers_url":"https://api.github.com/users/antirez/followers","following_url":"https://api.github.com/users/antirez/following{/other_user}","gists_url":"https://api.github.com/users/antirez/gists{/gist_id}","starred_url":"https://api.github.com/users/antirez/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/antirez/subscriptions","organizations_url":"https://api.github.com/users/antirez/orgs","repos_url":"https://api.github.com/users/antirez/repos","events_url":"https://api.github.com/users/antirez/events{/privacy}","received_events_url":"https://api.github.com/users/antirez/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":155760,"node_id":"MDU6TGFiZWwxNTU3NjA=","url":"https://api.github.com/repos/redis/redis/labels/critical%20bug","name":"critical bug","color":"e10c02","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"antirez","id":65632,"node_id":"MDQ6VXNlcjY1NjMy","avatar_url":"https://avatars.githubusercontent.com/u/65632?v=4","gravatar_id":"","url":"https://api.github.com/users/antirez","html_url":"https://github.com/antirez","followers_url":"https://api.github.com/users/antirez/followers","following_url":"https://api.github.com/users/antirez/following{/other_user}","gists_url":"https://api.github.com/users/antirez/gists{/gist_id}","starred_url":"https://api.github.com/users/antirez/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/antirez/subscriptions","organizations_url":"https://api.github.com/users/antirez/orgs","repos_url":"https://api.github.com/users/antirez/repos","events_url":"https://api.github.com/users/antirez/events{/privacy}","received_events_url":"https://api.github.com/users/antirez/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"antirez","id":65632,"node_id":"MDQ6VXNlcjY1NjMy","avatar_url":"https://avatars.githubusercontent.com/u/65632?v=4","gravatar_id":"","url":"https://api.github.com/users/antirez","html_url":"https://github.com/antirez","followers_url":"https://api.github.com/users/antirez/followers","following_url":"https://api.github.com/users/antirez/following{/other_user}","gists_url":"https://api.github.com/users/antirez/gists{/gist_id}","starred_url":"https://api.github.com/users/antirez/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/antirez/subscriptions","organizations_url":"https://api.github.com/users/antirez/orgs","repos_url":"https://api.github.com/users/antirez/repos","events_url":"https://api.github.com/users/antirez/events{/privacy}","received_events_url":"https://api.github.com/users/antirez/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":2,"created_at":"2011-10-07T08:32:05Z","updated_at":"2014-09-07T23:41:39Z","closed_at":"2013-07-22T06:41:41Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"(Please see http://groups.google.com/group/redis-db/browse_thread/thread/67d1b0bbe7669071 for full details, here I'm just summarizing the problem with some cut&paste from that thread).\n\nIf you are familiar with the design you know that the key space is split into 4096 parts. \nEvery part is called an \"hash slot\", and every node has a routing table to map every hash slot with a cluster node. \nThis way if a client sends a query to a node that is not responsible for the keys mentioned in the query, it gets a -MOVED message redirecting it to the right node. However we also have the ability to reconfigure the cluster while it \nis running. So for instance I've hash slot 100 that is assigned to node A. And I want to move it to node B. \n\nThis is accomplished (and redis-trib is already able to do it for you automatically) with the following steps. \n\n1) Node A hash slot 100 is marked as \"Migrating to B\" (using the CLUSTER SETSLOT <slot> MIGRATING <ndoe> command). \n2) Node B hash slot 100 is marked as \"Importing from A\" (using the \nCLUSTER SETSLOT <slot> IMPORTING <node> command). \n3) An external client, usually redis-trib, starts using the commands \nCLUSTER GETKEYSINSLOT and the MIGRATE command to atomically move keys from A to B.\n\nWhat is interesting is that while the hash slot is set as \"Migrating  to B\", node A will reply to all the requests about this hash slot of keys that are _still_ present in the hash slot, but if a request is about a key that is in hash slot 100 but is not \nfound inside the key space, it generates a \"-ASK\" error, that is like \"-MOVED\" but means: please only ask this exact query to the specified node, but don't update your table about it. Ask new queries about hash \nslot 100 to me again. \n\nThis way all the new keys about hash slot 100 are created directly in B, but A handles all the queries about keys that are still in A. At the same time redis-trib moves keys from A to B. Eventually all the keys are moved and the hash slot configuration is consolidated to the new one, using other CLUSTER SETSLOT subcommands. \nSo far this is pretty cool. But there is a subtle problem about this. \n# The Problem \n\nWhen the cluster is stable, that is, there no resharding in progress, a client may ask a query to a random node. \nThere is only one node that will reply to queries related to a specific hash slot. All the other nodes will redirect the client to \nthis node. However when rehashing is in progress there are two nodes that will reply to queries for a given hash slot, that is, the MIGRATING node and the IMPORTING node. \n\nIf the client is a \"smart\" client with an internal routing table, it starts every connection to a cluster asking for the slot->node map, and makes sure to update the table when -MOVED messages are received. But there are also clients that are not smart, without a table, or even clients that are smart but perhaps don't update the table since a lot of time since they are idle, and the cluster moved a lot of hash slots recently. But to make things simpler let's just focus on the stupid client that has no internal map. It just send queries to a random node among a list of configured nodes, expecting to get \nredirected if the wrong node was selected. \n\nSuch a simple client is only able to deal with -MOVED and -ASK redirections. And the two messages are handled in the same way, that is, just asking to the node specified in the redirection message. It is easy to see how this client may create a race condition, like that:\n\n1) We are migrating slot 100 from A to B. \n2) Node A will only accept queries about slot 100 that are related to keys already in the key space. Otherwise it will reply with -ASK. \n3) Node B instead will accept all queries about hash slot 100. \n4) Our stupid client need to perform an LPUSH against a key in hash slot 100. It picks a random client. \n5) If it picks \"C\" or \"D\" it will be redirected to \"A\". \"A\" in turn will redirect it to \"B\" with -ASK if the key is not present in A key space. \n6) If it picks \"B\" directly the query will be accepted by \"B\", but what about if \"A\" already had that key? RACE! \n# The proposed fix \n\n1) Node B is importing hash slot 100. \n2) Node B receives a query about key \"foo\" in hash slot 100. If it already hash \"foo\" the query is served. Otherwise it issues a \"-MOVED\" to redirect the client to A. \n3) Node B however will serve the query if the client started the chat using the command \"ASKING\", that indicates that this query was issued after being redirected by a -ASK message. If the client comes from a -ASK redirection we are sure we can serve the client.\n\nSo in the case above what happens is that all the smart clients will have no problems, after a -ASK redirection they will send: \n\nASKING\nLPUSH foo bar \n\nASKING sets a flag that is cleared after the command is executed. If a client is dummy (no internal routing tables caching) but still is able to remember that after a -ASK redirection it should start the next query with ASKING, everything is fine as well. \nA completely stupid client that is not able to start the chat with ASKING will simply ping/pong from A to B until the hash slot migration is completed, and will finally be served. \n","closed_by":{"login":"antirez","id":65632,"node_id":"MDQ6VXNlcjY1NjMy","avatar_url":"https://avatars.githubusercontent.com/u/65632?v=4","gravatar_id":"","url":"https://api.github.com/users/antirez","html_url":"https://github.com/antirez","followers_url":"https://api.github.com/users/antirez/followers","following_url":"https://api.github.com/users/antirez/following{/other_user}","gists_url":"https://api.github.com/users/antirez/gists{/gist_id}","starred_url":"https://api.github.com/users/antirez/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/antirez/subscriptions","organizations_url":"https://api.github.com/users/antirez/orgs","repos_url":"https://api.github.com/users/antirez/repos","events_url":"https://api.github.com/users/antirez/events{/privacy}","received_events_url":"https://api.github.com/users/antirez/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/redis/redis/issues/121/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/redis/redis/issues/121/timeline","performed_via_github_app":null,"state_reason":"completed"}