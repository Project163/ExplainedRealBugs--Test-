diff --git a/src/t_stream.c b/src/t_stream.c
index e78cef6ab..e4b8162c9 100644
--- a/src/t_stream.c
+++ b/src/t_stream.c
@@ -2300,14 +2300,13 @@ void xreadCommand(client *c) {
                                 "just return an empty result set.");
                 goto cleanup;
             }
-            if (o) {
+            if (o && ((stream *)o->ptr)->length) {
                 stream *s = o->ptr;
-                ids[id_idx] = s->last_id;
-                if (streamDecrID(&ids[id_idx]) != C_OK) {
-                    /* shouldn't happen */
-                    addReplyError(c,"the stream last element ID is 0-0");
-                    goto cleanup;
-                }
+                /* We need to get the last valid ID.
+                 * It is impossible to use s->last_id because
+                 * entry with s->last_id may have been removed. */
+                streamLastValidID(s, &ids[id_idx]);
+                streamDecrID(&ids[id_idx]);
             } else {
                 ids[id_idx].ms = 0;
                 ids[id_idx].seq = 0;
diff --git a/tests/unit/type/stream.tcl b/tests/unit/type/stream.tcl
index 06f58c8a2..b54b48d15 100644
--- a/tests/unit/type/stream.tcl
+++ b/tests/unit/type/stream.tcl
@@ -435,6 +435,17 @@ start_server {
 
         # verify nil is still received when reading last entry
         assert_equal [r XREAD STREAMS lestream +] {}
+
+        # case when stream created empty
+
+        # make sure the stream is not initialized
+        r DEL lestream
+
+        # create empty stream with XGROUP CREATE
+        r XGROUP CREATE lestream legroup $ MKSTREAM
+
+        # verify nil is received when reading last entry
+        assert_equal [r XREAD STREAMS lestream +] {}
     }
 
     test {XREAD last element blocking from empty stream} {
@@ -510,6 +521,22 @@ start_server {
         assert_equal $res {{lestream {{3-0 {k3 v3}}}}}
     }
 
+    test "XREAD: read last element after XDEL (issue #13628)" {
+        # Should return actual last element after XDEL of current last element
+
+        # Add 2 entries to a stream and delete last one
+        r DEL stream
+        r XADD stream 1-0 f 1
+        r XADD stream 2-0 f 2
+        r XDEL stream 2-0
+
+        # Read last entry
+        set res [r XREAD STREAMS stream +]
+
+        # Verify the last entry was read
+        assert_equal $res {{stream {{1-0 {f 1}}}}}
+    }
+
     test "XREAD: XADD + DEL should not awake client" {
         set rd [redis_deferring_client]
         r del s1
