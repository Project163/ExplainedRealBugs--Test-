{"id":696,"status":"Fixed","summary":"Make it easier to duplicate goog.isNull and friends","labels":["Type-Defect","Priority-Medium"],"stars":0,"commentCount":7,"comments":[{"id":0,"commenterId":-2236042086396273250,"content":"Hi,\r\n\r\nI would like to write some functions like goog.isNull, goog.isDef, etc in a codebase that does not use closure library.\r\n\r\nThe following code fails with a warning:\r\n/**\r\n * @param {*} val\r\n * @return {boolean}\r\n */\r\nisNull \u003d function(val) {\r\n  return val \u003d\u003d\u003d null;\r\n};\r\n\r\n/** @param {number} x */\r\nfunction notNullsOnly(x) {\r\n  window.console.log(x);\r\n}\r\n\r\n/** @param {number|null} x */\r\nfunction maybeNulls(x) {\r\n  if (!isNull(x)) notNullsOnly(x);\r\n}\r\n\r\nmaybeNulls(null);\r\nmaybeNulls(3)\r\n\r\n------------------------\r\nJSC_TYPE_MISMATCH: actual parameter 1 of notNullsOnly does not match formal parameter\r\nfound   : (null|number)\r\nrequired: number at line 17 character 29\r\nif (!isNull(x)) notNullsOnly(x);\r\n                             ^\r\n\r\n\r\nthough passes with no issues in a closure-library world using goog.isNull instead.\r\nI think that most of the magic to make this happens is in ClosureCodingConvention#isPropertyTestFunction and more importantly, ClosureReverseAbstractInterpreter.java\r\n\r\nCreating a new CodingConvention is relatively straightforward but I don\u0027t want to exactly copy/paste the code in ClosureReverseAbstractInterpreter.java. Even if I did, I don\u0027t have access to SemanticReverseAbstractInterpreter.java for some of the utilities and base behavior.\r\n\r\nThoughts?","timestamp":1333044449,"attachments":[]},{"id":1,"commenterId":-7699928860083865744,"content":"do you just need a clone of goog.isNull? or did you want to build more complicated type-inferring stuff?\r\n\r\nyou\u0027re probably the better judge of what api you need than i am...","timestamp":1333061607,"attachments":[]},{"id":2,"commenterId":-2236042086396273250,"content":"Just clones of goog.isNull, goog.isDef, goog.isDefAndNotNull","timestamp":1333062709,"attachments":[]},{"id":3,"commenterId":8173196008570380122,"content":"While it may be beyond the scope of this issue, we need a more generalized way to recognize common patterns for these tests - especially for cases not using Closure-library.\r\n\r\ngoog.isNull -\u003e varName !\u003d\u003d null\r\ngoog.isDef -\u003e varName !\u003d\u003d undefined\r\ngoog.isDefAndNotNull -\u003e varName !\u003d\u003d undefined \u0026\u0026 varName !\u003d\u003d null\r\n\r\nAlso, in jQuery they have the following code:\r\n\r\nif( typeof define \u003d\u003d\u003d \"function\" \u0026\u0026 define.amd \u0026\u0026 define.amd.jQuery ) {\r\n  define( \"jquery\", [], function() { return jQuery; } );\r\n}\r\n\r\nIt would be great if there was a way to write this that didn\u0027t require referencing the variables as properties of the global object (ex: window[\"define\"]).","timestamp":1333132394,"attachments":[]},{"id":4,"commenterId":-6098463528315836415,"content":"i moved a bunch of classes into c.g.javascript.jscomp.type, and made them public, so in theory you should be able to use and extend them? in practice, i probably need to make a few more things public.","timestamp":1333579730,"attachments":[]},{"id":5,"commenterId":-6289268304558982259,"content":"Yup, almost! If you patch the following I am good to go:\r\n\r\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\r\n--- src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t(revision 1866)\r\n+++ src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t(working copy)\r\n@@ -113,7 +113,7 @@\r\n    * name whose type is capable of being refined.\r\n    * @return The current type of the node if it can be refined, null otherwise.\r\n    */\r\n-  JSType getTypeIfRefinable(Node node, FlowScope scope) {\r\n+  protected JSType getTypeIfRefinable(Node node, FlowScope scope) {\r\n     switch (node.getType()) {\r\n       case Token.NAME:\r\n         StaticSlot\u003cJSType\u003e nameVar \u003d scope.getSlot(node.getString());\r\n@@ -590,14 +590,14 @@\r\n   /**\r\n    * Returns a version of type where undefined is not present.\r\n    */\r\n-  final JSType getRestrictedWithoutUndefined(JSType type) {\r\n+  protected final JSType getRestrictedWithoutUndefined(JSType type) {\r\n     return type \u003d\u003d null ? null : type.visit(restrictUndefinedVisitor);\r\n   }\r\n \r\n   /**\r\n    * Returns a version of type where null is not present.\r\n    */\r\n-  final JSType getRestrictedWithoutNull(JSType type) {\r\n+  protected final JSType getRestrictedWithoutNull(JSType type) {\r\n     return type \u003d\u003d null ? null : type.visit(restrictNullVisitor);\r\n   }","timestamp":1333636562,"attachments":[]},{"id":6,"commenterId":-7699928860083865744,"content":"This issue was closed by revision r1870.","timestamp":1333736646,"attachments":[]}]}