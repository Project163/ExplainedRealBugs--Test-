{"id":689,"status":"Fixed","summary":"Bug in ComposeWarningsGaurd class","labels":["Type-Defect","Priority-Medium"],"stars":0,"commentCount":7,"comments":[{"id":0,"commenterId":8040195245096286172,"content":"I had posted this as a discussion here: https://groups.google.com/d/topic/closure-compiler-discuss/LA7k7EzrvwU/discussion\r\n\r\nI\u0027ll paste the content of my original post here as well.\r\n\r\n---\r\n\r\nI\u0027ve been looking at a stacktrace generated by a load test of a Apache \r\nShindig server: \r\n\r\nException created : java.util.ConcurrentModificationException \r\n        at java.util.TreeMap$DescendingSubMapIterator.getNext(TreeMap.java: \r\n419) \r\n        at java.util.TreeMap$DescendingSubMapKeyIterator.next(TreeMap.java: \r\n498) \r\n        at \r\ncom.google.javascript.jscomp.ComposeWarningsGuard.addGuards(ComposeWarningsGuard.java: \r\n99) \r\n        at \r\ncom.google.javascript.jscomp.ComposeWarningsGuard.addGuard(ComposeWarningsGuard.java: \r\n89) \r\n        at \r\ncom.google.javascript.jscomp.ComposeWarningsGuard.addGuards(ComposeWarningsGuard.java: \r\n99) \r\n        at \r\ncom.google.javascript.jscomp.ComposeWarningsGuard.\u0026lt;init\u0026gt;(ComposeWarningsGuard.java: \r\n79) \r\n        at com.google.javascript.jscomp.Compiler.initOptions(Compiler.java: \r\n276) \r\n        at com.google.javascript.jscomp.Compiler.initModules(Compiler.java: \r\n331) \r\n        at com.google.javascript.jscomp.Compiler.init(Compiler.java:311) \r\n        at com.google.javascript.jscomp.Compiler.compile(Compiler.java:510) \r\n\r\nA pretty interesting stack trace... I\u0027m not familiar with this class \r\nin particular but after some investigation, it has nothing to do with \r\nbeing thread-safe. \r\nIt appears there\u0027s a condition where the code is modifying the backing \r\nTreeSet from which a Iterable descendingSet() is continued to be \r\nnavigated over. \r\nI believe the solution would be to clone the descendingSet before \r\npassing it to addGuards(Iterable\u0026lt;WarningsGuard\u0026gt; guards) \r\n","timestamp":1332422345,"attachments":[{"id":6890000000,"fileName":"ComposeWarningsGuard.java.patch","fileSize":799}]},{"id":1,"commenterId":-7699928860083865744,"content":"do you know how you were able to get this?\r\n\r\nfrom the stack trace, it looks like you\u0027ve got a cycle in you warnings guards.","timestamp":1332885447,"attachments":[]},{"id":2,"commenterId":8040195245096286172,"content":"No.  I agree it looks like a cycle in the warnings, and I\u0027m kind of confused about how it\u0027s happening.  Would you say the proposed patch inadvertently causes any harm in guarding against this situation? ","timestamp":1332885778,"attachments":[]},{"id":3,"commenterId":-7699928860083865744,"content":"i just wanted to make sure we weren\u0027t silencing a deeper problem","timestamp":1332892289,"attachments":[]},{"id":4,"commenterId":8040195245096286172,"content":"If you\u0027re curious, I can show you the code in shindig where the compiler is being created and run.\r\n\r\nOtherwise, I can create an issue to dig deeper later when I free up a bit.\r\n\r\nIf you\u0027re worried about burying it, maybe you can add a log statement right before\r\naddGuards(Lists.newLinkedList(composeGuard.guards.descendingSet()));\r\nif (this.guards \u003d\u003d composeGuard.guards)\r\n\r\nYou might even be able to do away with calling it all together if that is true.  I was just unsure if this situation was valid for closure or not.","timestamp":1332894522,"attachments":[]},{"id":5,"commenterId":1328304962299559429,"content":"This issue was closed by revision r1851.","timestamp":1332951490,"attachments":[]},{"id":6,"commenterId":8040195245096286172,"content":"Thanks!","timestamp":1333028135,"attachments":[]}]}