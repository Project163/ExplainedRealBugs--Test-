{"id":312,"status":"Fixed","summary":"javascript file order causes namespace creation problem in compiled code","labels":["Type-Defect","Priority-Medium"],"stars":1,"commentCount":6,"comments":[{"id":0,"commenterId":-5432602070528872646,"content":"\u003cb\u003eWhat steps will reproduce the problem?\u003c/b\u003e\n\r\n1. I have attached a tar.gz file with three javascript files (file1.js, file2.js, and file3.js) and two output files (out123.js and out213.js).\r\n\r\n2. I compiled the outputs using the following commands:\r\n\r\njava -jar ../compiler.jar --js\u003dfile1.js --js\u003dfile2.js --js\u003dfile3.js --formatting\u003dPRETTY_PRINT --js_output_file\u003dout123.js\r\n\r\njava -jar ../compiler.jar --js\u003dfile2.js --js\u003dfile1.js --js\u003dfile3.js --formatting\u003dPRETTY_PRINT --js_output_file\u003dout213.js\r\n\r\n\r\n\u003cb\u003eWhat is the expected output? What do you see instead?\u003c/b\u003e\n\r\nOne output will work when run in a browser (output123.js) and one will not (output213.js).  The problem in output213.js is it cannot declare xFuncs because file1.Obj is not declared yet, error on line 2.\r\n\r\nIt appears that when file2 is added to the compiled file it realizes that file1.Obj will be declared in the file that goog.provides that namespace, and thus skips that declaration.  Then when file1 is added to the compiled file the declaration occurs.\r\n\r\n\r\n\u003cb\u003eWhat version of the product are you using? On what operating system?\u003c/b\u003e\n\r\nJust to make sure that it was easy to repeat, I downloaded the most recent version (Version: 20100917 (revision 440)) of the jscompiler from code.google.com/p/closure-compiler/downloads/list.  I am running it on a variant of Ubuntu linux.\r\n\r\n\r\n\u003cb\u003ePlease provide any additional information below.\u003c/b\u003e\n\r\nThis issue arose in a project I am working on where:\r\na.  file2 is automatically generated\r\nb.  file3 represents the overarching project that will be compiled into a single javascript file\r\nc.  The order in which the files are given to the compiler is automatically generated by two other programs.\r\n","timestamp":1294357391,"attachments":[{"id":-8202647893425350547,"fileName":"provide_issue.tar.gz","fileSize":504}]},{"id":1,"commenterId":-7699928860083865744,"content":"I think we\u0027ve said in the past we don\u0027t plan on fixing this, because the behavior is not well-defined. \r\n\r\nI honestly think it should be a compiler error if one file tried to goog.provide a property on a function that\u0027s defined in another file.\r\n\r\nwhat do you think?","timestamp":1294361551,"attachments":[]},{"id":2,"commenterId":-7699928860083865744,"content":"It\u0027s also worth pointing out that this is also broken in uncompiled code, but breaks in a much more subtle way. (the property is just overwritten by the 3rd file).","timestamp":1294371512,"attachments":[]},{"id":3,"commenterId":-5432602070528872646,"content":"Ok, thank you.  I will watch my namespaces to ensure this doesn\u0027t happen in my project.\r\n\r\nI do like the idea of an error though.  It would make catching such an issue easier and would occur much sooner while developing.\r\n\r\nAlso, I am not sure if my opinion should matter too much as I am relatively new to javascript and probably have a number of biases from other languages I use.  However, I can give some of my thoughts while I was discovering this issue in case that is useful.  Otherwise, feel free to ignore the rest of this comment.\r\n\r\n\r\nWhat I had been expecting was that all the files would be processed, the namespaces would be determined, and then the namespaces would be declared in the appropriate order.  Two examples hinted this two me.  First, the one given in this report which was the compiler seemed to realize that Obj was not an empty object, but a function, and thus deferred initialization (perhaps coincidence).  Second, when the compiler generates an extern file it sorts the properties, functions, globals, etc into groups.  Thus a global variable declared in one file and one in another file would be lumped together at the top of the externs file.  Thus, it appears that the compiler tracks these things and can do some ordering.\r\n\r\nThus the results I had expected was to inject the non-empty object associated with the goog.provide (Obj) where it is first declared and leave the rest of the associated code from the file where ever it normally would go.  At least for functions, the code is not executed immediately upon declaration thus its order should not matter.  That said, I guess if someone wanted file order to be maintained and tried to call the function before the function was technically declared that should be an error and would be masked by out of order declarations.  Plus I am not clear on how that affects goog.provide when associated with a object/variable rather than a function.\r\n\r\n","timestamp":1294442447,"attachments":[]},{"id":4,"commenterId":-7699928860083865744,"content":"There are plenty of examples where it\u0027s not safe for us to move the function. For example, suppose you have:\r\n\r\ngoog.provide(\u0027Foo.bar\u0027);\r\nFoo.bar \u003d true;\r\nalert(Foo);\r\nvar Foo \u003d function() {};\r\n\r\nPutting the function at the top would cause different behavior.\r\n\r\nOne of the things I like about Java is that it forces you to be very explicit about where the entry points of your code are, and tries to re-order top-level statements to make sense. But JS does not do this. And as a matter of principle, we try not to \"fix\" broken uncompiled code. (It\u0027s really a PITA when your compiled code works, but when you try to debug the uncompiled code it breaks).","timestamp":1294675102,"attachments":[]},{"id":5,"commenterId":-7699928860083865744,"content":"This issue was closed by revision r1045.","timestamp":1304379506,"attachments":[]}]}