{"id":685,"status":"Fixed","summary":"Memory leak from Tracer.ThreadTrace when setTracerMode is set to OFF","labels":["Type-Defect","Priority-Low"],"stars":0,"commentCount":8,"comments":[{"id":0,"commenterId":-7204040140939939612,"content":"This was originally reported by tom@sproutbuilder.com in closure-library bug list:\r\nhttp://code.google.com/p/closure-library/issues/detail?id\u003d438\r\n\r\n\r\n\u003cb\u003eWhat steps will reproduce the problem?\u003c/b\u003e\n1. Disable your tracer via  options.setTracerMode(CompilerOptions.TracerMode.OFF);\r\n2. Run compiler in a Java project.\r\n3. Stop Tomcat 7 server.\r\n4. View logs:\r\n\r\nSEVERE: The web application [/translator] created a ThreadLocal with key of type [java.lang.ThreadLocal] (value [java.lang.ThreadLocal@62add0e8]) and a value of type [com.google.javascript.jscomp.Tracer.ThreadTrace] (value []) but failed to remove it when the web application was stopped. Threads are going to be renewed over time to try and avoid a probable memory leak.\r\n\r\n4. MaxPermSize JVM setting helps mask the issue, but over time we have gotten OutOfMemory exceptions on our development and staging servers.\r\n\r\n\u003cb\u003eWhat is the expected output? What do you see instead?\u003c/b\u003e\nNo errors or memory leaks should be expected output, because the tracer should be disabled.\r\n\r\n\u003cb\u003eWhat version of the product are you using? On what operating system?\u003c/b\u003e\nclosure-compiler r1811\r\n\r\n\u003cb\u003ePlease provide any additional information below.\u003c/b\u003e","timestamp":1332271382,"attachments":[]},{"id":1,"commenterId":-5060162230523776870,"content":"Should we be calling traces.remove() rather than traces.set(null) (traces being the ThreadLocal object)?","timestamp":1332276752,"attachments":[]},{"id":2,"commenterId":-5060162230523776870,"content":"It seems likely that this will need to be debugged in the environment in which it is running.  Chris did you have more details about the server?","timestamp":1332283854,"attachments":[]},{"id":3,"commenterId":-5060162230523776870,"content":"Lowering the priority of this.","timestamp":1332342458,"attachments":[]},{"id":4,"commenterId":-7699928860083865744,"content":"This issue was closed by revision r1940.","timestamp":1335901009,"attachments":[]},{"id":5,"commenterId":1482372669392377590,"content":"I\u0027m still experiencing this problem with recent versions. Could it be that the ThreadLocal is only removed if com.google.javascript.jscomp.Compiler.useThreads is true AND com.google.javascript.jscomp.CompilerOptions.tracer \u003d\u003d ON?","timestamp":1377092352,"attachments":[]},{"id":6,"commenterId":1482372669392377590,"content":"As the problem is not fixed, could this please be reopened?","timestamp":1378362646,"attachments":[]},{"id":7,"commenterId":1482372669392377590,"content":"From reading the code, I assume the following:\r\nThe `ThreadLocal` is created from the `Tracer.getThreadTrace()` method which is called in the constructor.\r\nThe ThreadLocal is only removed from within `Tracer.clearThreadTrace`. This is called from `clearCurrentThreadTrace()` - which is completely unused - and from `logAndClearCurrentThreadTrace()`. The latter is only called from within the `bootCompilerThread` `Callable`. And that - despite being created unconditionally - is only used if `Compiler.useThreads` is `true`.\r\nThat means that if `Compiler.useThreads` is `false`, the `ThreadLocal` is created but never removed. So could we please reopen this ticket? ","timestamp":1378981375,"attachments":[]}]}