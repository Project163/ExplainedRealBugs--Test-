{"id":1260,"status":"Fixed","summary":"\"new RegExp\" compiles to just \"RegExp\" in advanced mode","labels":["Type-Defect","Priority-Medium"],"stars":0,"commentCount":7,"comments":[{"id":0,"commenterId":-3271850922741451692,"content":"\u003cb\u003eWhat steps will reproduce the problem?\u003c/b\u003e\n1. Run the code snippet below. The output should be\r\n\r\na\r\na\r\n\r\n2. Compile it in advanced mode on http://closure-compiler.appspot.com/home and run the output. The output will be\r\n\r\na\r\nb\r\n\r\n3. This happens because \u0026quot;new RegExp\u0026quot; turns into just \u0026quot;RegExp\u0026quot; which doesn\u0027t work because regular expression are not stateless in JS.\r\n\r\nCode:\r\nvar re \u003d /./g;\r\nvar s \u003d \u0027abc\u0027;\r\nvar re1 \u003d new RegExp(re);\r\nvar re2 \u003d new RegExp(re);\r\nwindow.console.log(re1.exec(s)[0]);\r\nwindow.console.log(re2.exec(s)[0]);\r\n\r\nCompiler output:\r\nvar a\u003d/./g,b\u003dRegExp(a);window.console.log(RegExp(a).exec(\u0026quot;abc\u0026quot;)[0]);window.console.log(b.exec(\u0026quot;abc\u0026quot;)[0]);","timestamp":1393591915,"attachments":[]},{"id":1,"commenterId":1711074370877082584,"content":"","timestamp":1393636800,"attachments":[]},{"id":2,"commenterId":1711074370877082584,"content":"It looks like this happens in PeepholeSubstituteAlternateSyntax#tryFoldStandardConstructors. I think the rationale was that \"new RegExp(\u0027somestring\u0027)\" is equivalent to \"RegExp(\u0027somestring\u0027)\". But if you pass another RegExp to the RegExp constructor, then apparently it\u0027s not equivalent.\r\n\r\nAs a simple quickfix we could remove RegExp from the STANDARD_OBJECT_CONSTRUCTORS set, but the real fix is probably to do the replacement only if the argument is known to be a string.","timestamp":1393638013,"attachments":[]},{"id":3,"commenterId":-3271850922741451692,"content":"Wouldn\u0027t it be better to turn new RegExp(\u0027foo\u0027) into /foo/ rather than RegExp(\u0027foo\u0027)?","timestamp":1393839273,"attachments":[]},{"id":4,"commenterId":1711074370877082584,"content":"Actually, it looks like we already do that if the argument is a string literal. If it\u0027s a variable, we just drop the \u0027new.\u0027 So the cases are:\r\n\r\n// string literal\r\nnew RegExp(\u0027foo\u0027) \u003d\u003e /foo/\r\n\r\n// variable known to be of type {string}\r\nnew RegExp(stringVar) \u003d\u003e RegExp(stringVar)\r\n\r\n// variable that is not a string, or has an unknown type\r\nnew RegExp(nonStringVar) \u003d\u003e new RegExp(nonStringVar)\r\n\r\nCurrently the third case is the one we get wrong. Since we\u0027re already switching to /foo/ for string literals (which are, I would guess, the most common case) maybe we should actually just remove RegExp from the list of standard constructors.","timestamp":1393872743,"attachments":[]},{"id":5,"commenterId":1711074370877082584,"content":"","timestamp":1393885475,"attachments":[]},{"id":6,"commenterId":-8769171937076622550,"content":"This issue was closed by revision 27a73fe08dcb.","timestamp":1393952804,"attachments":[]}]}