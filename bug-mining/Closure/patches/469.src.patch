diff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java
index 0a67d0ea1..c4c5d1c23 100644
--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java
+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java
@@ -513,6 +513,11 @@ public final class DefaultPassConfig extends PassConfig {
       // it would be safe to always recompute side effects even if not using precompiled libraries
       // (the else case) but it's unecessary so skip it to improve build times.
       passes.add(checkRegExpForOptimizations);
+
+      // This runs during getChecks(), so only needs to be run here if using precompiled .typedasts
+      if (options.j2clPassMode.shouldAddJ2clPasses()) {
+        passes.add(j2clSourceFileChecker);
+      }
     } else {
       addNonTypedAstNormalizationPasses(passes);
     }
diff --git a/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java b/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
index 09c36f25a..1eba770f3 100644
--- a/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
@@ -306,6 +306,32 @@ public final class TypedAstIntegrationTest extends IntegrationTestCase {
         .isEqualTo(expectedRoot);
   }
 
+  @Test
+  public void runsJ2clOptimizations() throws IOException {
+    SourceFile f =
+        SourceFile.fromCode(
+            "f.java.js",
+            lines(
+                "function InternalWidget(){}",
+                "InternalWidget.$clinit = function () {",
+                "  InternalWidget.$clinit = function() {};",
+                "  InternalWidget.$clinit();",
+                "};",
+                "InternalWidget.$clinit();"));
+    sourceFiles.add(f);
+    precompileLibrary(f);
+
+    CompilerOptions options = new CompilerOptions();
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
+
+    Compiler compiler = compileTypedAstShards(options);
+
+    Node expectedRoot = parseExpectedCode("");
+    assertNode(compiler.getRoot().getSecondChild())
+        .usingSerializer(compiler::toSource)
+        .isEqualTo(expectedRoot);
+  }
+
   // use over 'compileTypedAstShards' if you want to validate reported errors or warnings in your
   // @Test case.
   private Compiler compileTypedAstShardsWithoutErrorChecks(CompilerOptions options)
