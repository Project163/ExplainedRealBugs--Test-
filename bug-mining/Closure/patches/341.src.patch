diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
index 99ec4aa45..23502e852 100644
--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
@@ -996,6 +996,8 @@ public final class JsDocInfoParser {
               }
             }
 
+            boolean isAnnotationNext = lookAheadForAnnotation();
+
             switch (annotation) {
               case CONSTANT:
                 if (!jsdocBuilder.recordConstancy()) {
@@ -1009,7 +1011,10 @@ public final class JsDocInfoParser {
                   parser.addParserWarning("msg.jsdoc.define",
                       lineno, charno);
                 }
-                return recordDescription(token);
+                if (!isAnnotationNext) {
+                  return recordDescription(token);
+                }
+                break;
 
               case PRIVATE:
                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
@@ -1017,7 +1022,10 @@ public final class JsDocInfoParser {
                       "msg.jsdoc.visibility.private",
                       lineno, charno);
                 }
-                return recordDescription(token);
+                if (!isAnnotationNext) {
+                  return recordDescription(token);
+                }
+                break;
 
               case PROTECTED:
                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
@@ -1025,7 +1033,10 @@ public final class JsDocInfoParser {
                       "msg.jsdoc.visibility.protected",
                       lineno, charno);
                 }
-                return recordDescription(token);
+                if (!isAnnotationNext) {
+                  return recordDescription(token);
+                }
+                break;
 
               case PUBLIC:
                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
@@ -1033,7 +1044,10 @@ public final class JsDocInfoParser {
                       "msg.jsdoc.visibility.public",
                       lineno, charno);
                 }
-                return recordDescription(token);
+                if (!isAnnotationNext) {
+                  return recordDescription(token);
+                }
+                break;
 
               case RETURN:
                 if (type == null) {
@@ -1051,8 +1065,6 @@ public final class JsDocInfoParser {
                 // last token read, so we don't want to read the first
                 // "STRING" out of the stream.
 
-                boolean isAnnotationNext = lookAheadForAnnotation();
-
                 // Find the return's description (if applicable).
                 if (jsdocBuilder.shouldParseDocumentation()
                     && !isAnnotationNext) {
diff --git a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
index 624fd6aa9..873875b5d 100644
--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
@@ -1432,6 +1432,34 @@ public class JsDocInfoParserTest extends BaseJSTypeTestCase {
     assertTrue(info.isConstructor());
   }
 
+  public void testStackedAnnotation9() throws Exception {
+    JSDocInfo info = parse("@const @private {string} */", true);
+    assertTrue(info.isConstant());
+    assertTrue(info.hasType());
+    assertTypeEquals(STRING_TYPE, info.getType());
+  }
+
+  public void testStackedAnnotation10() throws Exception {
+    JSDocInfo info = parse("@private @const {string} */", true);
+    assertEquals(Visibility.PRIVATE, info.getVisibility());
+    assertTrue(info.hasType());
+    assertTypeEquals(STRING_TYPE, info.getType());
+    assertTrue(info.isConstant());
+  }
+
+  public void testStackedAnnotation11() throws Exception {
+    JSDocInfo info = parse("@private @const */", true);
+    assertFalse(info.hasType());
+    assertEquals(Visibility.PRIVATE, info.getVisibility());
+    assertTrue(info.isConstant());
+  }
+
+  public void testStackedAnnotation12() throws Exception {
+    JSDocInfo info = parse("@const @private */", true);
+    assertFalse(info.hasType());
+    assertEquals(Visibility.PRIVATE, info.getVisibility());
+    assertTrue(info.isConstant());
+  }
 
   public void testParsePreserve() throws Exception {
     Node node = new Node(1);
