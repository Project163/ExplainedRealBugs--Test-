diff --git a/src/com/google/javascript/jscomp/CoalesceVariableNames.java b/src/com/google/javascript/jscomp/CoalesceVariableNames.java
index 6f1d939f9..9e8550d90 100644
--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java
+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java
@@ -199,7 +199,8 @@ class CoalesceVariableNames extends AbstractPostOrderCallback implements
       n.setString(coalescedVar.name);
       compiler.reportChangeToEnclosingScope(n);
 
-      if (NodeUtil.isNameDeclaration(parent)) {
+      if (NodeUtil.isNameDeclaration(parent)
+          || NodeUtil.getEnclosingType(n, Token.DESTRUCTURING_LHS) != null) {
         makeDeclarationVar(coalescedVar);
         removeVarDeclaration(n);
       }
@@ -233,7 +234,9 @@ class CoalesceVariableNames extends AbstractPostOrderCallback implements
       n.setString(pseudoName);
       compiler.reportChangeToEnclosingScope(n);
 
-      if (!vNode.getValue().equals(coalescedVar) && NodeUtil.isNameDeclaration(parent)) {
+      if (!vNode.getValue().equals(coalescedVar)
+          && (NodeUtil.isNameDeclaration(parent)
+              || NodeUtil.getEnclosingType(n, Token.DESTRUCTURING_LHS) != null)) {
         makeDeclarationVar(coalescedVar);
         removeVarDeclaration(n);
       }
@@ -396,12 +399,12 @@ class CoalesceVariableNames extends AbstractPostOrderCallback implements
    * Tries to remove variable declaration if the variable has been coalesced with another variable
    * that has already been declared. Any lets or consts are redeclared as vars because at this point
    * in the compilation, the code is normalized, so we can safely hoist variables without worrying
-   * about shaddowing.
+   * about shadowing.
    *
    * @param name name node of the variable being coalesced
    */
   private static void removeVarDeclaration(Node name) {
-    Node var = name.getParent();
+    Node var = NodeUtil.getEnclosingNode(name, NodeUtil.isNameDeclaration);
     Node parent = var.getParent();
 
     if (!var.isVar()) {
@@ -443,11 +446,11 @@ class CoalesceVariableNames extends AbstractPostOrderCallback implements
    * Because the code has already been normalized by the time this pass runs, we can safely
    * redeclare any let and const coalesced variables as vars
    */
-  public static void makeDeclarationVar(Var coalescedName) {
-    Node coalesceVarParent = coalescedName.getParentNode();
-    if (coalesceVarParent.isLet() || coalesceVarParent.isConst()) {
-      coalesceVarParent.setToken(Token.VAR);
-      checkState(coalesceVarParent.isVar());
+  private static void makeDeclarationVar(Var coalescedName) {
+    if (coalescedName.isLet() || coalescedName.isConst()) {
+      Node declNode =
+          NodeUtil.getEnclosingNode(coalescedName.getParentNode(), NodeUtil.isNameDeclaration);
+      declNode.setToken(Token.VAR);
     }
   }
 
diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java
index 880403d4b..2c166087e 100644
--- a/src/com/google/javascript/jscomp/NodeUtil.java
+++ b/src/com/google/javascript/jscomp/NodeUtil.java
@@ -2363,6 +2363,13 @@ public final class NodeUtil {
     return n != null && (n.isVar() || n.isLet() || n.isConst());
   }
 
+  static final Predicate<Node> isNameDeclaration = new Predicate<Node>() {
+    @Override
+    public boolean apply(Node n) {
+      return isNameDeclaration(n);
+    }
+  };
+
   /**
    * @param n The node
    * @return True if {@code n} is a VAR, LET or CONST that contains a
diff --git a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java
index 2a10a0fed..30d5ea819 100644
--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java
+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java
@@ -275,6 +275,36 @@ public final class CoalesceVariableNamesTest extends CompilerTestCase {
     inFunction("function x() {} var y = 1; y; x = 1; x");
   }
 
+  public void testBug65688660() {
+    test(
+        LINE_JOINER.join(
+            "function f(param) {",
+            "  if (true) {",
+            "    const b1 = [];",
+            "    for (const [key, value] of []) {}",
+            "  }",
+            "  if (true) {",
+            "    const b2 = [];",
+            "    for (const kv of []) {",
+            "      const key2 = kv.key;",
+            "    }",
+            "  }",
+            "}"),
+        LINE_JOINER.join(
+            "function f(param) {",
+            "  if (true) {",
+            "    param = [];",
+            "    for (var [key, value] of []) {}",
+            "  }",
+            "  if (true) {",
+            "    key = [];",
+            "    for (const kv of []) {",
+            "      key = kv.key;",
+            "    }",
+            "  }",
+            "}"));
+  }
+
   public void testBug1401831() {
     // Verify that we don't wrongly merge "opt_a2" and "i" without considering
     // arguments[0] aliasing it.
