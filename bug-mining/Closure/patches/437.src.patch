diff --git a/src/com/google/javascript/jscomp/ExportTestFunctions.java b/src/com/google/javascript/jscomp/ExportTestFunctions.java
index f1c367734..530a3416b 100644
--- a/src/com/google/javascript/jscomp/ExportTestFunctions.java
+++ b/src/com/google/javascript/jscomp/ExportTestFunctions.java
@@ -57,7 +57,6 @@ public class ExportTestFunctions implements CompilerPass {
   private class ExportTestFunctionsNodes extends NodeTraversal.AbstractShallowCallback {
     @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
-
       if (parent == null) {
         return;
       }
@@ -76,6 +75,10 @@ public class ExportTestFunctions implements CompilerPass {
           if (isTestFunction(functionName)) {
             exportTestFunctionAsSymbol(functionName, n, parent);
           }
+        } else if (isNameDeclaredClass(n)) {
+          Node classNode = n.getFirstFirstChild();
+          String className = NodeUtil.getName(classNode);
+          exportClass(parent, classNode, className, n);
         } else if (n.isClass()) {
           exportClass(parent, n);
         }
@@ -83,13 +86,23 @@ public class ExportTestFunctions implements CompilerPass {
         // Check for a test method assignment.
         Node grandparent = parent.getParent();
         if (grandparent != null && grandparent.isScript()) {
-          String functionName = n.getFirstChild().getQualifiedName();
-          if (isTestFunction(functionName)) {
-            if (n.getFirstChild().isName()) {
-              exportTestFunctionAsSymbol(functionName, parent, grandparent);
-            } else {
-              exportTestFunctionAsProperty(functionName, parent, n, grandparent);
+          //                                    NAME/(GETPROP -> ... -> NAME)
+          // SCRIPT -> EXPR_RESULT -> ASSIGN ->
+          //                                    FUNCTION/CLASS
+          Node firstChild = n.getFirstChild();
+          Node lastChild = n.getLastChild();
+          String nodeName = firstChild.getQualifiedName();
+
+          if (lastChild.isFunction()) {
+            if (isTestFunction(nodeName)) {
+              if (n.getFirstChild().isName()) {
+                exportTestFunctionAsSymbol(nodeName, parent, grandparent);
+              } else {
+                exportTestFunctionAsProperty(nodeName, parent, n, grandparent);
+              }
             }
+          } else if (lastChild.isClass()) {
+            exportClass(grandparent, lastChild, nodeName, parent);
           }
         }
       } else if (n.isObjectLit()
@@ -106,13 +119,18 @@ public class ExportTestFunctions implements CompilerPass {
     }
 
     private void exportClass(Node scriptNode, Node classNode) {
+      String className = NodeUtil.getName(classNode);
+      exportClass(scriptNode, classNode, className, classNode);
+    }
+
+    private void exportClass(Node scriptNode, Node classNode, String className, Node baseNode) {
       Node classMembers = classNode.getLastChild();
       for (Node maybeMemberFunctionDef : classMembers.children()) {
         if (maybeMemberFunctionDef.isMemberFunctionDef()) {
           String methodName = maybeMemberFunctionDef.getString();
-          if (TEST_FUNCTIONS_NAME_PATTERN.matcher(methodName).matches()) {
-            String functionRef = NodeUtil.getName(classNode) + ".prototype." + methodName;
-            String classRef = NodeUtil.getName(classNode) + ".prototype";
+          if (isTestFunction(methodName)) {
+            String functionRef = className + ".prototype." + methodName;
+            String classRef = className + ".prototype";
 
             Node exportCallTarget =
                 NodeUtil.newQName(
@@ -130,7 +148,7 @@ public class ExportTestFunctions implements CompilerPass {
 
             Node expression = IR.exprResult(call);
 
-            scriptNode.addChildAfter(expression, classNode);
+            scriptNode.addChildAfter(expression, baseNode);
             compiler.reportChangeToEnclosingScope(expression);
           }
         }
@@ -151,6 +169,18 @@ public class ExportTestFunctions implements CompilerPass {
       return (n.isCall() && n.getFirstChild().matchesQualifiedName(qname));
     }
 
+    /**
+     * Get the node that corresponds to an expression declared with var, let or const.
+     * This has the AST structure VAR/LET/CONST -> NAME -> NODE
+     * @param node
+     */
+    private Node getNameDeclaredGrandchild(Node node) {
+      if (!NodeUtil.isNameDeclaration(node)) {
+        return null;
+      }
+      return node.getFirstFirstChild();
+    }
+
     /**
      * Whether node corresponds to a function expression declared with var, let
      * or const which is of the form:
@@ -163,12 +193,25 @@ public class ExportTestFunctions implements CompilerPass {
      * @param node
      */
     private boolean isNameDeclaredFunction(Node node) {
-      if (!NodeUtil.isNameDeclaration(node)) {
-        return false;
-      }
-      Node grandchild = node.getFirstFirstChild();
+      Node grandchild = getNameDeclaredGrandchild(node);
       return grandchild != null && grandchild.isFunction();
     }
+
+    /**
+     * Whether node corresponds to a class declared with var, let or const which
+     * is of the form:
+     * <pre>
+     * var/let/const className = class {
+     *   // Implementation
+     * };
+     * </pre>
+     * This has the AST structure VAR/LET/CONST -> NAME -> CLASS
+     * @param node
+     */
+    private boolean isNameDeclaredClass(Node node) {
+      Node grandchild = getNameDeclaredGrandchild(node);
+      return grandchild != null && grandchild.isClass();
+    }
   }
 
   @Override
diff --git a/test/com/google/javascript/jscomp/ExportTestFunctionsTest.java b/test/com/google/javascript/jscomp/ExportTestFunctionsTest.java
index 7a1e7d084..f15f793fd 100644
--- a/test/com/google/javascript/jscomp/ExportTestFunctionsTest.java
+++ b/test/com/google/javascript/jscomp/ExportTestFunctionsTest.java
@@ -253,4 +253,38 @@ public final class ExportTestFunctionsTest extends CompilerTestCase {
             + "google_exportProperty(MyTest.prototype, 'testFoo', MyTest.prototype.testFoo);"
             + "goog.testing.testSuite(new MyTest());");
   }
+
+  // https://github.com/google/closure-compiler/issues/2563
+  public void testES6ClassAssignmentsAreExported() {
+    testSame("Foo = class {bar() {}}");
+
+    test(
+        "Foo = class {testBar() {}}",
+        "Foo = class {testBar() {}}; "
+            + "google_exportProperty(Foo.prototype, 'testBar', Foo.prototype.testBar);");
+  }
+
+  public void testEs6Class_testClassExpressionMethod() {
+    test(
+        "var MyTest=class{testFoo() {}}; goog.testing.testSuite(new MyTest());",
+        "var MyTest=class{testFoo() {}}; "
+            + "google_exportProperty(MyTest.prototype, 'testFoo', MyTest.prototype.testFoo); "
+            + "goog.testing.testSuite(new MyTest());");
+  }
+
+  public void testEs6Class_testClassExpressionByLetMethod() {
+    test(
+        "let MyTest=class{testFoo() {}}; goog.testing.testSuite(new MyTest());",
+        "let MyTest=class{testFoo() {}}; "
+            + "google_exportProperty(MyTest.prototype, 'testFoo', MyTest.prototype.testFoo); "
+            + "goog.testing.testSuite(new MyTest());");
+  }
+
+  public void testEs6Class_testClassExpressionByConstMethod() {
+    test(
+        "const MyTest=class{testFoo() {}}; goog.testing.testSuite(new MyTest());",
+        "const MyTest=class{testFoo() {}}; "
+            + "google_exportProperty(MyTest.prototype, 'testFoo', MyTest.prototype.testFoo); "
+            + "goog.testing.testSuite(new MyTest());");
+  }
 }
