diff --git a/src/com/google/javascript/jscomp/parsing/NewIRFactory.java b/src/com/google/javascript/jscomp/parsing/NewIRFactory.java
index 660149c59..7c5422db7 100644
--- a/src/com/google/javascript/jscomp/parsing/NewIRFactory.java
+++ b/src/com/google/javascript/jscomp/parsing/NewIRFactory.java
@@ -1549,6 +1549,21 @@ class NewIRFactory {
       return n;
     }
 
+    @Override
+    Node processTemplateString(LiteralExpressionTree tree) {
+      maybeWarnEs6Feature(tree, "template strings");
+      LiteralToken token = tree.literalToken.asLiteral();
+      Preconditions.checkState(token.type == TokenType.TEMPLATE_STRING);
+      if (Pattern.compile("[^\\\\]\\$\\{").matcher(token.value).find()) {
+        errorReporter.warning(
+            "Placeholders in template strings are not supported yet.",
+            sourceName, lineno(tree), "", charno(tree));
+      }
+
+      Node node = newStringNode(Token.STRING, normalizeString(token));
+      setSourceInfo(node, token);
+      return node;
+    }
 
     @Override
     Node processSwitchCase(CaseClauseTree caseNode) {
diff --git a/src/com/google/javascript/jscomp/parsing/NewTypeSafeDispatcher.java b/src/com/google/javascript/jscomp/parsing/NewTypeSafeDispatcher.java
index a4377b566..2ddfca788 100644
--- a/src/com/google/javascript/jscomp/parsing/NewTypeSafeDispatcher.java
+++ b/src/com/google/javascript/jscomp/parsing/NewTypeSafeDispatcher.java
@@ -110,6 +110,7 @@ abstract class NewTypeSafeDispatcher<T> {
   abstract T processSwitchCase(CaseClauseTree tree);
   abstract T processSwitchStatement(SwitchStatementTree tree);
   abstract T processThrowStatement(ThrowStatementTree tree);
+  abstract T processTemplateString(LiteralExpressionTree tree);
   abstract T processTryStatement(TryStatementTree tree);
   abstract T processUnaryExpression(UnaryExpressionTree tree);
   abstract T processVariableStatement(VariableStatementTree tree);
@@ -156,6 +157,8 @@ abstract class NewTypeSafeDispatcher<T> {
         return processNumberLiteral(expr);
       case STRING:
         return processStringLiteral(expr);
+      case TEMPLATE_STRING:
+        return processTemplateString(expr);
       case FALSE:
       case TRUE:
         return processBooleanLiteral(expr);
diff --git a/src/com/google/javascript/jscomp/parsing/parser/Parser.java b/src/com/google/javascript/jscomp/parsing/parser/Parser.java
index 5ca175acd..9978fef37 100644
--- a/src/com/google/javascript/jscomp/parsing/parser/Parser.java
+++ b/src/com/google/javascript/jscomp/parsing/parser/Parser.java
@@ -1244,6 +1244,7 @@ public class Parser {
     case TRUE:
     case FALSE:
     case NULL:
+    case TEMPLATE_STRING:
       return parseLiteralExpression();
     case OPEN_SQUARE:
       return parseArrayLiteral();
@@ -1515,6 +1516,7 @@ public class Parser {
     case SLASH: // regular expression literal
     case SLASH_EQUAL:
     case STRING:
+    case TEMPLATE_STRING:
     case SUPER:
     case THIS:
     case TILDE:
@@ -1981,7 +1983,7 @@ public class Parser {
    * Whether we have a spread expression or an assignment next.
    *
    * This does not peek the operand for the spread expression. This means that
-   * {@code parseAssignmentOrSpred} might still fail when this returns true.
+   * {@code parseAssignmentOrSpread} might still fail when this returns true.
    */
   private boolean peekAssignmentOrSpread() {
     return peek(TokenType.SPREAD) || peekAssignmentExpression();
diff --git a/src/com/google/javascript/jscomp/parsing/parser/Scanner.java b/src/com/google/javascript/jscomp/parsing/parser/Scanner.java
index c256176c1..b5cd00768 100644
--- a/src/com/google/javascript/jscomp/parsing/parser/Scanner.java
+++ b/src/com/google/javascript/jscomp/parsing/parser/Scanner.java
@@ -542,6 +542,8 @@ public class Scanner {
       case '"':
       case '\'':
         return scanStringLiteral(beginToken, ch);
+      case '`':
+        return scanTemplateString(beginToken);
       default:
         return scanIdentifierOrKeyword(beginToken, ch);
       }
@@ -707,6 +709,22 @@ public class Scanner {
         TokenType.STRING, getTokenString(beginIndex), getTokenRange(beginIndex));
   }
 
+  private Token scanTemplateString(int beginIndex) {
+    while (peekTemplateStringChar()) {
+      if (!skipStringLiteralChar()) {
+        return new LiteralToken(
+            TokenType.TEMPLATE_STRING, getTokenString(beginIndex), getTokenRange(beginIndex));
+      }
+    }
+    if (peekChar() != '`') {
+      reportError(getPosition(beginIndex), "Unterminated template string");
+    } else {
+      nextChar();
+    }
+    return new LiteralToken(
+        TokenType.TEMPLATE_STRING, getTokenString(beginIndex), getTokenRange(beginIndex));
+  }
+
   private String getTokenString(int beginIndex) {
     return this.source.contents.substring(beginIndex, this.index);
   }
@@ -723,6 +741,10 @@ public class Scanner {
     return true;
   }
 
+  private boolean peekTemplateStringChar() {
+    return !isAtEnd() && peekChar() != '`';
+  }
+
   private boolean skipStringLiteralEscapeSequence() {
     nextChar();
     if (isAtEnd()) {
@@ -737,6 +759,7 @@ public class Scanner {
     switch (nextChar()) {
     case '\'':
     case '"':
+    case '`':
     case '\\':
     case 'b':
     case 'f':
diff --git a/src/com/google/javascript/jscomp/parsing/parser/TokenType.java b/src/com/google/javascript/jscomp/parsing/parser/TokenType.java
index db029c7d2..d9d9b09cc 100644
--- a/src/com/google/javascript/jscomp/parsing/parser/TokenType.java
+++ b/src/com/google/javascript/jscomp/parsing/parser/TokenType.java
@@ -131,6 +131,7 @@ public enum TokenType {
   FALSE,
   NUMBER("number literal"),
   STRING("string literal"),
+  TEMPLATE_STRING("template string"),
   REGULAR_EXPRESSION("regular expression literal"),
 
   // Harmony extensions
diff --git a/test/com/google/javascript/jscomp/parsing/NewParserTest.java b/test/com/google/javascript/jscomp/parsing/NewParserTest.java
index 78c3765af..4a8c9fa5f 100644
--- a/test/com/google/javascript/jscomp/parsing/NewParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/NewParserTest.java
@@ -1188,6 +1188,44 @@ public class NewParserTest extends BaseJSTypeTestCase {
     parse("'\\\n';");
   }
 
+  private void testTemplateString(String s) {
+    mode = LanguageMode.ECMASCRIPT5;
+    parseWarning(s,
+        "this language feature is only supported in es6 mode: template strings");
+
+    mode = LanguageMode.ECMASCRIPT6;
+    parse(s);
+  }
+
+  public void testTemplateString() {
+    testTemplateString("`hello world`;");
+    testTemplateString("`hello\nworld`;");
+    testTemplateString("`string containing \\`escaped\\` backticks`;");
+  }
+
+  public void testTemplateStringPlaceholder() {
+    mode = LanguageMode.ECMASCRIPT6;
+
+    parse("`hello \\${name}`;");
+    parseWarning("`hello ${name}`;",
+        "Placeholders in template strings are not supported yet.");
+  }
+
+  public void testUnterminatedTemplateString() {
+    mode = LanguageMode.ECMASCRIPT6;
+    parseError("`hello",
+        "Unterminated template string");
+    parseError("`hello\\`",
+        "Unterminated template string");
+  }
+
+  public void testIncorrectEscapeSequenceInTemplateString() {
+    parseError("`hello\\x",
+        "Hex digit expected");
+    parseError("`hello\\x`",
+        "Hex digit expected");
+  }
+
   public void testBinaryLiterals() {
     mode = LanguageMode.ECMASCRIPT3;
     parseWarning("0b0001;",
