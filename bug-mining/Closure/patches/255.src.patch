diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java
index 89ddf3382..781fc3c30 100644
--- a/src/com/google/javascript/jscomp/NameAnalyzer.java
+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java
@@ -19,6 +19,8 @@ package com.google.javascript.jscomp;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.LinkedListMultimap;
+import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -29,10 +31,10 @@ import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.jscomp.NodeTraversal.Callback;
 import com.google.javascript.jscomp.Scope.Var;
 import com.google.javascript.jscomp.graph.DiGraph;
-import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;
-import com.google.javascript.jscomp.graph.LinkedDirectedGraph;
 import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;
+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;
 import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;
+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -92,7 +94,8 @@ final class NameAnalyzer implements CompilerPass {
    * If scopes.get(node).equals(name) && node2 is a child of node, then node2
    * will not get executed unless name is referenced via a get operation
    */
-  private final Map<Node, NameInformation> scopes = Maps.newHashMap();
+  private final ListMultimap<Node, NameInformation> scopes =
+      LinkedListMultimap.create();
 
   /** Used to parse prototype names */
   private static final String PROTOTYPE_SUBSTRING = ".prototype.";
@@ -463,9 +466,9 @@ final class NameAnalyzer implements CompilerPass {
     public void visit(NodeTraversal t, Node n, Node parent) {
       NameInformation ns = null;
       if (NodeUtil.isVarDeclaration(n)) {
-        ns = createNameInformation(t, n, parent);
+        ns = createNameInformation(t, n);
       } else if (NodeUtil.isFunctionDeclaration(n)) {
-        ns = createNameInformation(t, n.getFirstChild(), n);
+        ns = createNameInformation(t, n.getFirstChild());
       }
       if (ns != null) {
         JsName jsName = getName(ns.name, true);
@@ -504,48 +507,85 @@ final class NameAnalyzer implements CompilerPass {
       }
 
       if (n.isAssign()) {
-        Node nameNode = n.getFirstChild();
-        NameInformation ns = createNameInformation(t, nameNode, n);
-        if (ns != null) {
-          if (parent.isFor() && !NodeUtil.isForIn(parent)) {
-            // Patch for assignments that appear in the init,
-            // condition or iteration part of a FOR loop.  Without
-            // this change, all 3 of those parts try to claim the for
-            // loop as their dependency scope.  The last assignment in
-            // those three fields wins, which can result in incorrect
-            // reference edges between referenced and assigned variables.
-            //
-            // TODO(user) revisit the dependency scope calculation
-            // logic.
-            if (parent.getFirstChild().getNext() != n) {
-              recordDepScope(n, ns);
-            } else {
-              recordDepScope(nameNode, ns);
-            }
-          } else {
-            recordDepScope(n, ns);
-          }
+        recordAssignment(t, n, n);
+        if (!NodeUtil.isImmutableResult(n.getLastChild())) {
+          recordConsumers(t, n, n);
         }
       } else if (NodeUtil.isVarDeclaration(n)) {
-        NameInformation ns = createNameInformation(t, n, parent);
+        NameInformation ns = createNameInformation(t, n);
         recordDepScope(n, ns);
       } else if (NodeUtil.isFunctionDeclaration(n)) {
-        NameInformation ns = createNameInformation(t, n.getFirstChild(), n);
+        NameInformation ns = createNameInformation(t, n.getFirstChild());
         recordDepScope(n, ns);
       } else if (NodeUtil.isExprCall(n)) {
         Node callNode = n.getFirstChild();
         Node nameNode = callNode.getFirstChild();
-        NameInformation ns = createNameInformation(t, nameNode, callNode);
+        NameInformation ns = createNameInformation(t, nameNode);
         if (ns != null && ns.onlyAffectsClassDef) {
           recordDepScope(n, ns);
         }
       }
     }
 
+    private void recordConsumers(NodeTraversal t, Node n, Node recordNode) {
+      Node parent = n.getParent();
+      switch (parent.getType()) {
+        case Token.ASSIGN:
+          if (n == parent.getLastChild()) {
+            recordAssignment(t, parent, recordNode);
+          }
+          recordConsumers(t, parent, recordNode);
+          break;
+        case Token.NAME:
+          NameInformation ns = createNameInformation(t, parent);
+          recordDepScope(recordNode, ns);
+          break;
+        case Token.OR:
+          recordConsumers(t, parent, recordNode);
+          break;
+        case Token.AND:
+          // In "a && b" only "b" can be meaningfully aliased.
+          // "a" must be falsy, which it must be an immutable, non-Object
+        case Token.COMMA:
+        case Token.HOOK:
+          if (n != parent.getFirstChild()) {
+            recordConsumers(t, parent, recordNode);
+          }
+          break;
+      }
+    }
+
+    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
+      Node nameNode = n.getFirstChild();
+      Node parent = n.getParent();
+      NameInformation ns = createNameInformation(t, nameNode);
+      if (ns != null) {
+        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
+          // Patch for assignments that appear in the init,
+          // condition or iteration part of a FOR loop.  Without
+          // this change, all 3 of those parts try to claim the for
+          // loop as their dependency scope.  The last assignment in
+          // those three fields wins, which can result in incorrect
+          // reference edges between referenced and assigned variables.
+          //
+          // TODO(user) revisit the dependency scope calculation
+          // logic.
+          if (parent.getFirstChild().getNext() != n) {
+            recordDepScope(recordNode, ns);
+          } else {
+            recordDepScope(nameNode, ns);
+          }
+        } else {
+          recordDepScope(recordNode, ns);
+        }
+      }
+    }
+
     /**
      * Defines a dependency scope.
      */
     private void recordDepScope(Node node, NameInformation name) {
+      Preconditions.checkNotNull(name);
       scopes.put(node, name);
     }
   }
@@ -562,12 +602,12 @@ final class NameAnalyzer implements CompilerPass {
     @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
       if (NodeUtil.isVarDeclaration(n)) {
-        NameInformation ns = createNameInformation(t, n, parent);
+        NameInformation ns = createNameInformation(t, n);
         Preconditions.checkNotNull(ns, "NameInformation is null");
         createName(ns.name);
       } else if (NodeUtil.isFunctionDeclaration(n)) {
         Node nameNode = n.getFirstChild();
-        NameInformation ns = createNameInformation(t, nameNode, n);
+        NameInformation ns = createNameInformation(t, nameNode);
         Preconditions.checkNotNull(ns, "NameInformation is null");
         createName(nameNode.getString());
       }
@@ -590,18 +630,18 @@ final class NameAnalyzer implements CompilerPass {
       // Record global variable and function declarations
       if (t.inGlobalScope()) {
         if (NodeUtil.isVarDeclaration(n)) {
-          NameInformation ns = createNameInformation(t, n, parent);
+          NameInformation ns = createNameInformation(t, n);
           Preconditions.checkNotNull(ns);
           recordSet(ns.name, n);
         } else if (NodeUtil.isFunctionDeclaration(n)) {
           Node nameNode = n.getFirstChild();
-          NameInformation ns = createNameInformation(t, nameNode, n);
+          NameInformation ns = createNameInformation(t, nameNode);
           if (ns != null) {
             JsName nameInfo = getName(nameNode.getString(), true);
             recordSet(nameInfo.name, nameNode);
           }
         } else if (NodeUtil.isObjectLitKey(n, parent)) {
-          NameInformation ns = createNameInformation(t, n, parent);
+          NameInformation ns = createNameInformation(t, n);
           if (ns != null) {
             recordSet(ns.name, n);
           }
@@ -612,7 +652,7 @@ final class NameAnalyzer implements CompilerPass {
       if (n.isAssign()) {
         Node nameNode = n.getFirstChild();
 
-        NameInformation ns = createNameInformation(t, nameNode, n);
+        NameInformation ns = createNameInformation(t, nameNode);
         if (ns != null) {
           if (ns.isPrototype) {
             recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
@@ -622,7 +662,7 @@ final class NameAnalyzer implements CompilerPass {
         }
       } else if (n.isCall()) {
         Node nameNode = n.getFirstChild();
-        NameInformation ns = createNameInformation(t, nameNode, n);
+        NameInformation ns = createNameInformation(t, nameNode);
         if (ns != null && ns.onlyAffectsClassDef) {
           JsName name = getName(ns.name, true);
           refNodes.add(new ClassDefiningFunctionNode(name, n));
@@ -811,7 +851,7 @@ final class NameAnalyzer implements CompilerPass {
         return;
       }
 
-      NameInformation nameInfo = createNameInformation(t, n, parent);
+      NameInformation nameInfo = createNameInformation(t, n);
       if (nameInfo == null) {
         // The name is not a global name
         return;
@@ -849,7 +889,20 @@ final class NameAnalyzer implements CompilerPass {
       // looking up the nearest enclosing dependency scope. It's unnecessary to
       // determine all enclosing dependency scopes because this callback should
       // create a chain of references between them.
-      NameInformation referring = getDependencyScope(n);
+      List<NameInformation> referers = getDependencyScope(n);
+      if (referers.isEmpty()) {
+        maybeRecordReferenceOrAlias(t, n, parent, nameInfo, null);
+      } else {
+        for (NameInformation referring : referers) {
+          maybeRecordReferenceOrAlias(t, n, parent, nameInfo, referring);
+        }
+        recordAliases(referers);
+      }
+    }
+
+    private void maybeRecordReferenceOrAlias(
+        NodeTraversal t, Node n, Node parent,
+        NameInformation nameInfo, NameInformation referring) {
       String referringName = "";
       if (referring != null) {
         referringName = referring.isPrototype
@@ -885,11 +938,17 @@ final class NameAnalyzer implements CompilerPass {
       }
 
       if (nodesToKeep.contains(n)) {
-        NameInformation functionScope = getEnclosingFunctionDependencyScope(t);
-        if (functionScope != null) {
-          recordReference(functionScope.name, name, RefType.REGULAR);
+        List<NameInformation> functionScopes =
+            getEnclosingFunctionDependencyScope(t);
+        if (!functionScopes.isEmpty()) {
+          for (NameInformation functionScope : functionScopes) {
+            recordReference(functionScope.name, name, RefType.REGULAR);
+          }
         } else {
           recordReference(WINDOW, name, RefType.REGULAR);
+          if (referring != null) {
+            maybeRecordAlias(name, parent, referring, referringName);
+          }
         }
       } else if (referring != null) {
         if (!maybeRecordAlias(name, parent, referring, referringName)) {
@@ -912,6 +971,16 @@ final class NameAnalyzer implements CompilerPass {
       }
     }
 
+    private void recordAliases(List<NameInformation> referers) {
+      int size = referers.size();
+      for (int i = 0; i < size; i++) {
+        for (int j = i + 1; j < size; j++) {
+          recordAlias(referers.get(i).name, referers.get(j).name);
+          recordAlias(referers.get(j).name, referers.get(i).name);
+        }
+      }
+    }
+
     /**
      * A value whose result is the return value of a function call
      * can be an alias to global object. The dependency on the call target will
@@ -959,7 +1028,7 @@ final class NameAnalyzer implements CompilerPass {
           parent.isAssign()) &&
           !isPrototypePropAssignment &&
           referring != null &&
-          scopes.get(parent) == referring) {
+          scopes.get(parent).contains(referring)) {
         recordAlias(referringName, name);
         return true;
       }
@@ -1321,12 +1390,11 @@ final class NameAnalyzer implements CompilerPass {
    *
    * @param t The node traversal
    * @param n The current node
-   * @param parent The parent of n
    * @return The name information, or null if the name is irrelevant to this
    *     pass
    */
-  private NameInformation createNameInformation(NodeTraversal t, Node n,
-      Node parent) {
+  private NameInformation createNameInformation(NodeTraversal t, Node n) {
+    Node parent = n.getParent();
     // Build the full name and find its root node by iterating down through all
     // GETPROP/GETELEM nodes.
     String name = "";
@@ -1398,7 +1466,7 @@ final class NameAnalyzer implements CompilerPass {
             n.isGetProp() &&
             parent.isAssign() &&
             "prototype".equals(n.getLastChild().getString())) {
-          if (createNameInformation(t, n.getFirstChild(), n) != null) {
+          if (createNameInformation(t, n.getFirstChild()) != null) {
             name = rootNameNode.getString() + name;
             name = name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);
             NameInformation nameInfo = new NameInformation();
@@ -1492,15 +1560,15 @@ final class NameAnalyzer implements CompilerPass {
   /**
    * Gets the nearest enclosing dependency scope, or null if there isn't one.
    */
-  private NameInformation getDependencyScope(Node n) {
+  private List<NameInformation> getDependencyScope(Node n) {
     for (Node node : n.getAncestors()) {
-      NameInformation ref = scopes.get(node);
-      if (ref != null) {
-        return ref;
+      List<NameInformation> refs = scopes.get(node);
+      if (!refs.isEmpty()) {
+        return refs;
       }
     }
 
-    return null;
+    return Collections.emptyList();
   }
 
   /**
@@ -1509,15 +1577,16 @@ final class NameAnalyzer implements CompilerPass {
    * its parent if the parent node is a variable declaration or
    * assignment.
    */
-  private NameInformation getEnclosingFunctionDependencyScope(NodeTraversal t) {
+  private List<NameInformation> getEnclosingFunctionDependencyScope(
+      NodeTraversal t) {
     Node function = t.getEnclosingFunction();
     if (function == null) {
-      return null;
+      return Collections.emptyList();
     }
 
-    NameInformation ref = scopes.get(function);
-    if (ref != null) {
-      return ref;
+    List<NameInformation> refs = scopes.get(function);
+    if (!refs.isEmpty()) {
+      return refs;
     }
 
     // Function expression.  try to get a name from the parent var
@@ -1539,7 +1608,7 @@ final class NameAnalyzer implements CompilerPass {
       }
     }
 
-    return null;
+    return Collections.emptyList();
   }
 
   /**
@@ -1679,7 +1748,8 @@ final class NameAnalyzer implements CompilerPass {
         break;
       case Token.ASSIGN:
         Preconditions.checkArgument(parent.isFor(),
-            "Unsupported assignment in replaceWithRhs. parent: %s", Token.name(parent.getType()));
+            "Unsupported assignment in replaceWithRhs. parent: %s",
+            Token.name(parent.getType()));
         break;
       default:
         throw new IllegalArgumentException(
diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java
index 91e3e805c..e36d1fecd 100644
--- a/src/com/google/javascript/jscomp/NodeUtil.java
+++ b/src/com/google/javascript/jscomp/NodeUtil.java
@@ -1261,6 +1261,17 @@ public final class NodeUtil {
     return n.isNull() || isUndefined(n);
   }
 
+  static final Predicate<Node> IMMUTABLE_PREDICATE = new Predicate<Node>() {
+    @Override
+    public boolean apply(Node n) {
+      return isImmutableValue(n);
+    }
+  };
+
+  static boolean isImmutableResult(Node n) {
+    return allResultsMatch(n, IMMUTABLE_PREDICATE);
+  }
+
   /**
    * Apply the supplied predicate against
    * all possible result Nodes of the expression.
diff --git a/test/com/google/javascript/jscomp/NameAnalyzerTest.java b/test/com/google/javascript/jscomp/NameAnalyzerTest.java
index 1d2c31239..0bc5ae4df 100644
--- a/test/com/google/javascript/jscomp/NameAnalyzerTest.java
+++ b/test/com/google/javascript/jscomp/NameAnalyzerTest.java
@@ -47,43 +47,84 @@ public class NameAnalyzerTest extends CompilerTestCase {
     return 1;
   }
 
-  public void testRemoveVarDeclartion1() {
+  public void testRemoveVarDeclaration1() {
     test("var foo = 3;", "");
   }
 
-  public void testRemoveVarDeclartion2() {
+  public void testRemoveVarDeclaration2() {
     test("var foo = 3, bar = 4; externfoo = foo;",
          "var foo = 3; externfoo = foo;");
   }
 
-  public void testRemoveVarDeclartion3() {
+  public void testRemoveVarDeclaration3() {
     test("var a = f(), b = 1, c = 2; b; c", "f();var b = 1, c = 2; b; c");
   }
 
-  public void testRemoveVarDeclartion4() {
+  public void testRemoveVarDeclaration4() {
     test("var a = 0, b = f(), c = 2; a; c", "var a = 0;f();var c = 2; a; c");
   }
 
-  public void testRemoveVarDeclartion5() {
+  public void testRemoveVarDeclaration5() {
     test("var a = 0, b = 1, c = f(); a; b", "var a = 0, b = 1; f(); a; b");
   }
 
-  public void testRemoveVarDeclartion6() {
+  public void testRemoveVarDeclaration6() {
     test("var a = 0, b = a = 1; a", "var a = 0; a = 1; a");
   }
 
-  public void testRemoveVarDeclartion7() {
+  public void testRemoveVarDeclaration7() {
     test("var a = 0, b = a = 1", "");
   }
 
-  public void testRemoveVarDeclartion8() {
+  public void testRemoveVarDeclaration8() {
     test("var a;var b = 0, c = a = b = 1", "");
   }
 
-  public void testRemoveFunction() {
+
+  public void testRemoveDeclaration1() {
+    test("var a;var b = 0, c = a = b = 1", "");
+  }
+
+  public void testRemoveDeclaration2() {
+    test("var a,b,c; c = a = b = 1", "");
+  }
+
+  public void testRemoveDeclaration3() {
+    test("var a,b,c; c = a = b = {}; a.x = 1;", "");
+  }
+
+  public void testRemoveDeclaration4() {
+    testSame("var a,b,c; c = a = b = {}; a.x = 1;alert(c.x);");
+  }
+
+  public void testRemoveDeclaration5() {
+    test("var a,b,c; c = a = b = null; use(b)", "var b;b=null;use(b)");
+  }
+
+  public void testRemoveDeclaration6() {
+    test("var a,b,c; c = a = b = 'str';use(b)", "var b;b='str';use(b)");
+  }
+
+  public void testRemoveDeclaration7() {
+    test("var a,b,c; c = a = b = true;use(b)", "var b;b=true;use(b)");
+  }
+
+  public void testRemoveFunction1() {
+    test("var foo = function(){};", "");
+  }
+
+  public void testRemoveFunction2() {
+    test("var foo; foo = function(){};", "");
+  }
+
+  public void testRemoveFunction3() {
     test("var foo = {}; foo.bar = function() {};", "");
   }
 
+  public void testRemoveFunction4() {
+    test("var a = {}; a.b = {}; a.b.c = function() {};", "");
+  }
+
   public void testReferredToByWindow() {
     testSame("var foo = {}; foo.bar = function() {}; window['fooz'] = foo.bar");
   }
@@ -104,12 +145,16 @@ public class NameAnalyzerTest extends CompilerTestCase {
     test("var f = function (){f()}", "");
   }
 
+  public void testRemoveRecursiveFunction2a() {
+    test("var f = function g(){g()}", "");
+  }
+
   public void testRemoveRecursiveFunction3() {
     test("var f;f = function (){f()}", "");
   }
 
   public void testRemoveRecursiveFunction4() {
-    // TODO(user) bug?  not removed if name definition doesn't exist.
+    // don't removed if name definition doesn't exist.
     testSame("f = function (){f()}");
   }
 
@@ -570,6 +615,22 @@ public class NameAnalyzerTest extends CompilerTestCase {
          "var e = false;if(e);");
   }
 
+  public void testIf4a() {
+    // TODO(johnlenz): fix this.
+    testSame("var e = [], f;if(f=e);f[0] = 1;");
+  }
+
+  public void testIf4b() {
+    // TODO(johnlenz): fix this.
+    test("var e = [], f;if(e=f);f[0] = 1;",
+         "var f;if(f);f[0] = 1;");
+  }
+
+  public void testIf4c() {
+    test("var e = [], f;if(f=e);e[0] = 1;",
+         "var e = [];if(e);e[0] = 1;");
+  }
+
   public void testIf5() {
     test("var e = false, f;var foo = {};if(f = e + 1)foo.bar=function(){};",
          "var e = false;if(e + 1);");
@@ -692,17 +753,11 @@ public class NameAnalyzerTest extends CompilerTestCase {
   }
 
   public void testSetterInForIn3() {
-    // TODO(user) Fix issue similar to b/2316773: bar should be preserved
-    // but isn't due to missing references between e and foo.a
-    test("var foo = {}; var bar; for(e in bar = foo.a); bar.b = 3",
-         "var foo = {}; for(e in foo.a);");
+    testSame("var foo = {}; var bar; for(e in bar = foo.a); bar.b = 3");
   }
 
   public void testSetterInForIn4() {
-    // TODO(user) Fix issue similar to b/2316773: bar should be preserved
-    // but isn't due to missing references between e and foo.a
-    test("var foo = {}; var bar; for (e in bar = foo.a); bar.b = 3; foo.a",
-         "var foo = {}; for (e in foo.a); foo.a");
+    testSame("var foo = {}; var bar; for (e in bar = foo.a); bar.b = 3; foo.a");
   }
 
   public void testSetterInForIn5() {
@@ -751,11 +806,15 @@ public class NameAnalyzerTest extends CompilerTestCase {
     testSame("var x = 0; x += 3; x *= 5;");
   }
 
-  public void testNestedAssigns() {
+  public void testNestedAssigns1() {
     test("var x = 0; var y = x = 3; window.alert(y);",
          "var y = 3; window.alert(y);");
   }
 
+  public void testNestedAssigns2() {
+    testSame("var x = 0; var y = x = {}; x.b = 3; window.alert(y);");
+  }
+
   public void testComplexNestedAssigns1() {
     // TODO(nicksantos): Make NameAnalyzer smarter, so that we can eliminate y.
     testSame("var x = 0; var y = 2; y += x = 3; window.alert(x);");
@@ -873,6 +932,11 @@ public class NameAnalyzerTest extends CompilerTestCase {
     testSame("var g; 1 || (externfoo.x = function() { g; })");
   }
 
+  public void testConditionallyDefinedFunction3() {
+      testSame("var a = {};" +
+           "rand() % 2 || (a.f = function() { externfoo = 1; } || alert());");
+  }
+
   public void testGetElemOnThis() {
     testSame("var a = 3; this['foo'] = a;");
     testSame("this['foo'] = 3;");
@@ -1084,6 +1148,13 @@ public class NameAnalyzerTest extends CompilerTestCase {
         "");
   }
 
+  public void testAssignWithHook2a() {
+    test("function Foo(){} var foo = null;" +
+        "var f; f = window.a ? " +
+        "    function () {return new Foo()} : function () {return foo};",
+        "");
+  }
+
   public void testAssignWithHook3() {
     testSame("function Foo(){} var foo = null; var f = {};" +
         "f.b = window.a ? " +
@@ -1112,6 +1183,55 @@ public class NameAnalyzerTest extends CompilerTestCase {
         "");
   }
 
+  public void testAssignWithHook7() {
+    testSame("function Foo(){} var foo = null;" +
+        "var f = window.a ? new Foo() : foo;" +
+        "f()");
+  }
+
+  public void testAssignWithHook8() {
+    test("function Foo(){} var foo = null;" +
+        "var f = window.a ? new Foo() : foo;",
+        "function Foo(){}" +
+        "window.a && new Foo()");
+  }
+
+  public void testAssignWithHook9() {
+    test("function Foo(){} var foo = null; var f = {};" +
+        "f.b = window.a ? new Foo() : foo;",
+        "function Foo(){} window.a && new Foo()");
+  }
+
+  public void testAssign1() {
+    test("function Foo(){} var foo = null; var f = {};" +
+        "f.b = window.a;",
+        "");
+  }
+
+  public void testAssign2() {
+    test("function Foo(){} var foo = null; var f = {};" +
+        "f.b = window;",
+        "");
+  }
+
+  public void testAssign3() {
+    test("var f = {};" +
+        "f.b = window;",
+        "");
+  }
+
+  public void testAssign4() {
+    test("function Foo(){} var foo = null; var f = {};" +
+        "f.b = new Foo();",
+        "function Foo(){} new Foo()");
+  }
+
+  public void testAssign5() {
+    test("function Foo(){} var foo = null; var f = {};" +
+        "f.b = foo;",
+        "");
+  }
+
   public void testNestedAssign1() {
     test("var a, b = a = 1, c = 2", "");
   }
@@ -1451,13 +1571,7 @@ public class NameAnalyzerTest extends CompilerTestCase {
         "this.x = Foo.getInstance();");
   }
 
-  // TODO(user): Make NameAnalyzer handle this. The OR subexpressions may
-  // modify global state.
-  // public void testConditionallyDefinedFunction3() {
-  //    test("var a = {};" +
-  //         "rand() % 2 || (a.f = function() { externfoo = 1; } || alert());",
-  //         "rand() % 2 || function() { externfoo = 1; } || alert();");
-  // }
+
 
   public void testNoRemoveWindowPropertyAlias1() {
      testSame(
@@ -1477,6 +1591,62 @@ public class NameAnalyzerTest extends CompilerTestCase {
         "self_['qs'] = function() {};");
   }
 
+  public void testNoRemoveWindowPropertyAlias4() {
+    // TODO(johnlenz): fix this. "self_" should remain.
+    test(
+        "var self_ = window['gbar'] || {};\n" +
+        "self_.qs = function() {};",
+        "");
+ }
+
+  public void testNoRemoveWindowPropertyAlias4a() {
+    // TODO(johnlenz): fix this. "self_" should remain.
+    test(
+        "var self_; self_ = window.gbar || {};\n" +
+        "self_.qs = function() {};",
+        "");
+ }
+
+  public void testNoRemoveWindowPropertyAlias5() {
+    // TODO(johnlenz): fix this. "self_" should remain.
+    test(
+        "var self_ = window || {};\n" +
+        "self_['qs'] = function() {};",
+        "");
+  }
+
+  public void testNoRemoveWindowPropertyAlias5a() {
+    // TODO(johnlenz): fix this.
+    test(
+        "var self_; self_ = window || {};\n" +
+        "self_['qs'] = function() {};",
+        "");
+  }
+
+  public void testNoRemoveWindowPropertyAlias6() {
+    testSame(
+        "var self_ = (window.gbar = window.gbar || {});\n" +
+        "self_.qs = function() {};");
+  }
+
+  public void testNoRemoveWindowPropertyAlias6a() {
+    testSame(
+        "var self_; self_ = (window.gbar = window.gbar || {});\n" +
+        "self_.qs = function() {};");
+  }
+
+  public void testNoRemoveWindowPropertyAlias7() {
+    testSame(
+        "var self_ = (window = window || {});\n" +
+        "self_['qs'] = function() {};");
+  }
+
+  public void testNoRemoveWindowPropertyAlias7a() {
+    testSame(
+        "var self_; self_ = (window = window || {});\n" +
+        "self_['qs'] = function() {};");
+  }
+
   public void testNoRemoveAlias0() {
     testSame(
         "var x = {}; function f() { return x; }; " +
@@ -1678,6 +1848,80 @@ public class NameAnalyzerTest extends CompilerTestCase {
         "");
   }
 
+  public void testIssue838a() {
+    testSame("var z = window['z'] || (window['z'] = {});\n" +
+         "z['hello'] = 'Hello';\n" +
+         "z['world'] = 'World';");
+  }
+
+  public void testIssue838b() {
+    testSame(
+         "var z;" +
+         "window['z'] = z || (z = {});\n" +
+         "z['hello'] = 'Hello';\n" +
+         "z['world'] = 'World';");
+  }
+
+
+  public void testIssue874a() {
+    testSame(
+        "var a = a || {};\n" +
+        "var b = a;\n" +
+        "b.View = b.View || {}\n" +
+        "var c = b.View;\n" +
+        "c.Editor = function f(d, e) {\n" +
+        "  return d + e\n" +
+        "};\n" +
+        "window.ImageEditor.View.Editor = a.View.Editor;");
+  }
+
+  public void testIssue874b() {
+    testSame(
+        "var b;\n" +
+        "var c = b = {};\n" +
+        "c.Editor = function f(d, e) {\n" +
+        "  return d + e\n" +
+        "};\n" +
+        "window['Editor'] = b.Editor;");
+  }
+
+  public void testIssue874c() {
+    testSame(
+        "var b, c;\n" +
+        "c = b = {};\n" +
+        "c.Editor = function f(d, e) {\n" +
+        "  return d + e\n" +
+        "};\n" +
+        "window['Editor'] = b.Editor;");
+  }
+
+  public void testIssue874d() {
+    testSame(
+        "var b = {}, c;\n" +
+        "c = b;\n" +
+        "c.Editor = function f(d, e) {\n" +
+        "  return d + e\n" +
+        "};\n" +
+        "window['Editor'] = b.Editor;");
+  }
+
+  public void testIssue874e() {
+    testSame(
+        "var a;\n" +
+        "var b = a || (a = {});\n" +
+        "var c = b.View || (b.View = {});\n" +
+        "c.Editor = function f(d, e) {\n" +
+        "  return d + e\n" +
+        "};\n" +
+        "window.ImageEditor.View.Editor = a.View.Editor;");
+  }
+
+  public void testBug6575051() {
+    testSame(
+        "var hackhack = window['__o_o_o__'] = window['__o_o_o__'] || {};\n" +
+        "window['__o_o_o__']['va'] = 1;\n" +
+        "hackhack['Vb'] = 1;");
+  }
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
