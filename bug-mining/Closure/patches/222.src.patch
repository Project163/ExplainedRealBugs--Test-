diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
index 20196bf79..d1836e6a0 100644
--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
@@ -20,13 +20,16 @@ import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
 import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;
 import com.google.javascript.jscomp.ControlFlowGraph.Branch;
 import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;
+import com.google.javascript.jscomp.MustBeReachingVariableDef.Definition;
 import com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;
 import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;
+import com.google.javascript.jscomp.Scope.Var;
 import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;
 import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;
 import com.google.javascript.rhino.Node;
@@ -34,6 +37,7 @@ import com.google.javascript.rhino.Token;
 
 import java.util.Collection;
 import java.util.List;
+import java.util.Set;
 
 /**
  * Inline variables when possible. Using the information from
@@ -70,6 +74,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
    * need two separate dataflow result.
    */
   private final AbstractCompiler compiler;
+  private final Set<Var> inlinedNewDependencies = Sets.newHashSet();
 
   // These two pieces of data is persistent in the whole execution of enter
   // scope.
@@ -149,6 +154,17 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
     for (Candidate c : candidates) {
       if (c.canInline()) {
         c.inlineVariable();
+
+        // If definition c has dependencies, then inlining it may have
+        // introduced new dependencies for our other inlining candidates.
+        //
+        // MustBeReachingVariableDef uses this dependency graph in its
+        // analysis, so some of these candidates may no longer be valid.
+        // We keep track of when the variable dependency graph changed
+        // so that we can back off appropriately.
+        if (!c.defMetadata.depends.isEmpty()) {
+          inlinedNewDependencies.add(t.getScope().getVar(c.varName));
+        }
       }
     }
   }
@@ -213,12 +229,12 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
               return;
             }
 
-            Node defNode = reachingDef.getDef(name, cfgNode);
+            Definition def = reachingDef.getDef(name, cfgNode);
             // TODO(nicksantos): We need to add some notion of @const outer
             // scope vars. We can inline those just fine.
-            if (defNode != null &&
-                !reachingDef.dependsOnOuterScopeVars(name, cfgNode)) {
-              candidates.add(new Candidate(name, defNode, n, cfgNode));
+            if (def != null &&
+                !reachingDef.dependsOnOuterScopeVars(def)) {
+              candidates.add(new Candidate(name, def, n, cfgNode));
             }
           }
         }
@@ -238,7 +254,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
 
     // Nodes related to the definition.
     private Node def;
-    private final Node defCfgNode;
+    private final Definition defMetadata;
 
     // Nodes related to the use.
     private final Node use;
@@ -248,22 +264,35 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
     // use in the CFG.
     private int numUseWithinUseCfgNode;
 
-    Candidate(String varName, Node defCfgNode, Node use, Node useCfgNode) {
+    Candidate(String varName, Definition defMetadata,
+        Node use, Node useCfgNode) {
       Preconditions.checkArgument(use.isName());
       this.varName = varName;
-      this.defCfgNode = defCfgNode;
+      this.defMetadata = defMetadata;
       this.use = use;
       this.useCfgNode = useCfgNode;
     }
 
-    private boolean canInline() {
+    private Node getDefCfgNode() {
+      return defMetadata.node;
+    }
 
+    private boolean canInline() {
       // Cannot inline a parameter.
-      if (defCfgNode.isFunction()) {
+      if (getDefCfgNode().isFunction()) {
         return false;
       }
 
-      getDefinition(defCfgNode, null);
+      // If one of our dependencies has been inlined, then our dependency
+      // graph is wrong. Re-computing it would take another CFG computation,
+      // so we just back off for now.
+      for (Var dependency : defMetadata.depends) {
+        if (inlinedNewDependencies.contains(dependency)) {
+          return false;
+        }
+      }
+
+      getDefinition(getDefCfgNode(), null);
       getNumUseInUseCfgNode(useCfgNode, null);
 
       // Definition was not found.
@@ -277,11 +306,10 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
         return false;
       }
 
-
       // The right of the definition has side effect:
       // Example, for x:
       // x = readProp(b), modifyProp(b); print(x);
-      if (checkRightOf(def, defCfgNode, SIDE_EFFECT_PREDICATE)) {
+      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {
         return false;
       }
 
@@ -292,7 +320,6 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
         return false;
       }
 
-
       // TODO(user): Side-effect is OK sometimes. As long as there are no
       // side-effect function down all paths to the use. Once we have all the
       // side-effect analysis tool.
@@ -315,7 +342,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
       }
 
 
-      Collection<Node> uses = reachingUses.getUses(varName, defCfgNode);
+      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());
 
       if (uses.size() != 1) {
         return false;
@@ -356,15 +383,15 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
 
       // We can skip the side effect check along the paths of two nodes if
       // they are just next to each other.
-      if (NodeUtil.isStatementBlock(defCfgNode.getParent()) &&
-          defCfgNode.getNext() != useCfgNode) {
+      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&
+          getDefCfgNode().getNext() != useCfgNode) {
         // Similar side effect check as above but this time the side effect is
         // else where along the path.
         // x = readProp(b); while(modifyProp(b)) {}; print(x);
         CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>
           pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(
                  cfg,
-                 cfg.getDirectedGraphNode(defCfgNode),
+                 cfg.getDirectedGraphNode(getDefCfgNode()),
                  cfg.getDirectedGraphNode(useCfgNode),
                  SIDE_EFFECT_PREDICATE,
                  Predicates.
diff --git a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java
index b0e535c52..e374ca07a 100644
--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java
+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java
@@ -65,7 +65,7 @@ final class MustBeReachingVariableDef extends
    * this definition reads from. For example N: a = b + foo.bar(c). The
    * definition node will be N, the depending set would be {b,c}.
    */
-  private static class Definition {
+  static class Definition {
     final Node node;
     final Set<Var> depends = Sets.newHashSet();
     private boolean unknownDependencies = false;
@@ -407,31 +407,26 @@ final class MustBeReachingVariableDef extends
   }
 
   /**
-   * Gets the must reaching definition of a given node. The node must be one of
-   * the control flow graph nodes.
+   * Gets the must reaching definition of a given node.
    *
    * @param name name of the variable. It can only be names of local variable
    *     that are not function parameters, escaped variables or variables
    *     declared in catch.
    * @param useNode the location of the use where the definition reaches.
    */
-  Node getDef(String name, Node useNode) {
+  Definition getDef(String name, Node useNode) {
     Preconditions.checkArgument(getCfg().hasNode(useNode));
     GraphNode<Node, Branch> n = getCfg().getNode(useNode);
     FlowState<MustDef> state = n.getAnnotation();
-    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
-    if (def == null) {
-      return null;
-    } else {
-      return def.node;
-    }
+    return state.getIn().reachingDef.get(jsScope.getVar(name));
   }
 
-  boolean dependsOnOuterScopeVars(String name, Node useNode) {
-    Preconditions.checkArgument(getCfg().hasNode(useNode));
-    GraphNode<Node, Branch> n = getCfg().getNode(useNode);
-    FlowState<MustDef> state = n.getAnnotation();
-    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
+  Node getDefNode(String name, Node useNode) {
+    Definition def = getDef(name, useNode);
+    return def == null ? null : def.node;
+  }
+
+  boolean dependsOnOuterScopeVars(Definition def) {
     if (def.unknownDependencies) {
       return true;
     }
diff --git a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java
index 371a756c8..103262c23 100644
--- a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java
+++ b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java
@@ -29,6 +29,10 @@ public class FlowSensitiveInlineVariablesTest extends CompilerTestCase  {
       "/** @nosideeffects */ function noSFX() {} \n" +
       "                      function hasSFX() {} \n";
 
+  public FlowSensitiveInlineVariablesTest() {
+    enableNormalize(true);
+  }
+
   @Override
   public int getNumRepetitions() {
     // Test repeatedly inline.
@@ -323,9 +327,10 @@ public class FlowSensitiveInlineVariablesTest extends CompilerTestCase  {
   }
 
   public void testRemoveWithLabels() {
-    inline("var x = 1; L: x = 2; print(x)", "var x = 1; print(2)");
-    inline("var x = 1; L: M: x = 2; print(x)", "var x = 1; print(2)");
-    inline("var x = 1; L: M: N: x = 2; print(x)", "var x = 1; print(2)");
+    inline("var x = 1; L: x = 2; print(x)", "var x = 1; L:{} print(2)");
+    inline("var x = 1; L: M: x = 2; print(x)", "var x = 1; L:M:{} print(2)");
+    inline("var x = 1; L: M: N: x = 2; print(x)",
+           "var x = 1; L:M:N:{} print(2)");
   }
 
   public void testInlineAcrossSideEffect1() {
@@ -449,6 +454,52 @@ public class FlowSensitiveInlineVariablesTest extends CompilerTestCase  {
         + "return x;");
   }
 
+  public void testIssue777() {
+    test(
+        "function f(cmd, ta) {" +
+        "  var temp = cmd;" +
+        "  var temp2 = temp >> 2;" +
+        "  cmd = STACKTOP;" +
+        "  for (var src = temp2, dest = cmd >> 2, stop = src + 37;" +
+        "       src < stop;" +
+        "       src++, dest++) {" +
+        "    HEAP32[dest] = HEAP32[src];" +
+        "  }" +
+        "  temp = ta;" +
+        "  temp2 = temp >> 2;" +
+        "  ta = STACKTOP;" +
+        "  STACKTOP += 8;" +
+        "  HEAP32[ta >> 2] = HEAP32[temp2];" +
+        "  HEAP32[ta + 4 >> 2] = HEAP32[temp2 + 1];" +
+        "}",
+        "function f(cmd, ta){" +
+        "  var temp;" +
+        "  var temp2 = cmd >> 2;" +
+        "  cmd = STACKTOP;" +
+        "  var src = temp2;" +
+        "  var dest = cmd >> 2;" +
+        "  var stop = src + 37;" +
+        "  for(;src<stop;src++,dest++)HEAP32[dest]=HEAP32[src];" +
+        "  temp2 = ta >> 2;" +
+        "  ta = STACKTOP;" +
+        "  STACKTOP += 8;" +
+        "  HEAP32[ta>>2] = HEAP32[temp2];" +
+        "  HEAP32[ta+4>>2] = HEAP32[temp2+1];" +
+        "}");
+  }
+
+  public void testTransitiveDependencies1() {
+    test(
+        "function f(x) { var a = x; var b = a; x = 3; return b; }",
+        "function f(x) { var a;     var b = x; x = 3; return b; }");
+  }
+
+  public void testTransitiveDependencies2() {
+    test(
+        "function f(x) { var a = x; var b = a; var c = b; x = 3; return c; }",
+        "function f(x) { var a    ; var b = x; var c    ; x = 3; return b; }");
+  }
+
   private void noInline(String input) {
     inline(input, input);
   }
diff --git a/test/com/google/javascript/jscomp/IntegrationTest.java b/test/com/google/javascript/jscomp/IntegrationTest.java
index 5306ccea6..62179cde7 100644
--- a/test/com/google/javascript/jscomp/IntegrationTest.java
+++ b/test/com/google/javascript/jscomp/IntegrationTest.java
@@ -1840,7 +1840,8 @@ public class IntegrationTest extends IntegrationTestCase {
         "  a = a + 'y';\n" +
         "  return a;\n" +
         "}",
-        "function f(a) {return a + 'xy'}");
+        // This should eventually get inlined completely.
+        "function f(a) { a += 'x'; return a += 'y'; }");
   }
 
   public void testIssue284() {
diff --git a/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java b/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java
index 8b3befcdc..19a6f7a08 100644
--- a/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java
+++ b/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java
@@ -125,22 +125,22 @@ public class MustBeReachingVariableDefTest extends TestCase {
 
   public void testFunctionParams1() {
     computeDefUse("if (param2) { D: param1 = 1; U: param1 }");
-    assertSame(def, defUse.getDef("param1", use));
+    assertSame(def, defUse.getDefNode("param1", use));
   }
 
   public void testFunctionParams2() {
     computeDefUse("if (param2) { D: param1 = 1} U: param1");
-    assertNotSame(def, defUse.getDef("param1", use));
+    assertNotSame(def, defUse.getDefNode("param1", use));
   }
 
   public void testArgumentsObjectModifications() {
     computeDefUse("D: param1 = 1; arguments[0] = 2; U: param1");
-    assertNotSame(def, defUse.getDef("param1", use));
+    assertNotSame(def, defUse.getDefNode("param1", use));
   }
 
   public void testArgumentsObjectEscaped() {
     computeDefUse("D: param1 = 1; var x = arguments; x[0] = 2; U: param1");
-    assertNotSame(def, defUse.getDef("param1", use));
+    assertNotSame(def, defUse.getDefNode("param1", use));
   }
 
   public void testArgumentsObjectEscapedDependents() {
@@ -152,7 +152,7 @@ public class MustBeReachingVariableDefTest extends TestCase {
    */
   private void assertMatch(String src) {
     computeDefUse(src);
-    assertSame(def, defUse.getDef("x", use));
+    assertSame(def, defUse.getDefNode("x", use));
   }
 
   /**
@@ -160,7 +160,7 @@ public class MustBeReachingVariableDefTest extends TestCase {
    */
   private void assertNotMatch(String src) {
     computeDefUse(src);
-    assertNotSame(def, defUse.getDef("x", use));
+    assertNotSame(def, defUse.getDefNode("x", use));
   }
 
   /**
