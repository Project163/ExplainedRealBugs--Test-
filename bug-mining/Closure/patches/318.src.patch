diff --git a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java
index a09e9835a..a387957a5 100644
--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java
+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java
@@ -17,6 +17,7 @@
 package com.google.javascript.jscomp;
 
 import com.google.common.base.Preconditions;
+import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
@@ -278,6 +279,18 @@ class PeepholeRemoveDeadCode extends AbstractPeepholeOptimization {
     return result;
   }
 
+  /**
+   * A predicate for matching anything except function nodes.
+   */
+  private static class MatchUnnamedBreak implements Predicate<Node>{
+    @Override
+    public boolean apply(Node n) {
+      return n.isBreak() && !n.hasChildren();
+    }
+  }
+
+  static final Predicate<Node> MATCH_UNNAMED_BREAK = new MatchUnnamedBreak();
+
   /**
    * Remove useless switches and cases.
    */
@@ -320,12 +333,14 @@ class PeepholeRemoveDeadCode extends AbstractPeepholeOptimization {
         }
         if (caseMatches != TernaryValue.UNKNOWN) {
           Node block, lastStm;
-          // Skip cases until you find one whose last stm is a break
+          // Skip cases until you find one whose last stm is a removable break
           while (cur != null) {
             block = cur.getLastChild();
             lastStm = block.getLastChild();
             cur = cur.getNext();
-            if (lastStm != null && lastStm.isBreak()) {
+            if (lastStm != null
+                && lastStm.isBreak()
+                && !lastStm.hasChildren()) {
               block.removeChild(lastStm);
               reportCodeChange();
               break;
@@ -340,9 +355,10 @@ class PeepholeRemoveDeadCode extends AbstractPeepholeOptimization {
           cur = cond.getNext();
           if (cur != null && cur.getNext() == null) {
             block = cur.getLastChild();
-            if (!(NodeUtil.containsType(block, Token.BREAK,
+            if (!(NodeUtil.has(block, MATCH_UNNAMED_BREAK,
                 NodeUtil.MATCH_NOT_FUNCTION))) {
               cur.removeChild(block);
+              block.setIsSyntheticBlock(false);
               n.getParent().replaceChild(n, block);
               reportCodeChange();
               return block;
diff --git a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java
index 50c8532b5..a6b89b4ab 100644
--- a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java
+++ b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java
@@ -336,7 +336,7 @@ public class PeepholeRemoveDeadCodeTest extends CompilerTestCase {
         "  var x=0;\n" +
         "  break;\n" +
         "}",
-        "var x; {foo();}");
+        "var x; foo();");
 
     // Can't remove cases if something useful is done.
     foldSame("switch(a){case 1: var c =2; break;}");
@@ -351,7 +351,7 @@ public class PeepholeRemoveDeadCodeTest extends CompilerTestCase {
         "  bar();\n" +
         "  break;\n" +
         "}",
-        "{foo();}");
+        "foo();");
     fold("switch ('noMatch') {\n" +
         "case 'foo':\n" +
         "  foo();\n" +
@@ -393,7 +393,7 @@ public class PeepholeRemoveDeadCodeTest extends CompilerTestCase {
         "  bar();\n" +
         "  break;\n" +
         "}",
-        "{foo();}");
+        "foo();");
     fold("switch ('foo') {\n" +
         "case 'bar':\n" +
         "  bar();\n" +
@@ -421,7 +421,7 @@ public class PeepholeRemoveDeadCodeTest extends CompilerTestCase {
         "  bar();\n" +
         "  break;\n" +
         "}",
-        "{foo();}");
+        "foo();");
     fold("switch (1) {\n" +
         "case 1.1:\n" +
         "  foo();\n" +
@@ -453,6 +453,28 @@ public class PeepholeRemoveDeadCodeTest extends CompilerTestCase {
         "}");
   }
 
+  public void testOptimizeSwitchBug11536863() {
+    fold(
+        "outer: {" +
+        "  switch (2) {\n" +
+        "    case 2:\n" +
+        "      f();\n" +
+        "      break outer;\n" +
+        "  }" +
+        "}",
+        "outer: {f(); break outer;}");
+  }
+
+  public void testOptimizeSwitch2() {
+    fold(
+        "outer: switch (2) {\n" +
+        "  case 2:\n" +
+        "    f();\n" +
+        "    break outer;\n" +
+        "}",
+        "outer: {f(); break outer;}");
+  }
+
   public void testRemoveNumber() {
     test("3", "");
   }
