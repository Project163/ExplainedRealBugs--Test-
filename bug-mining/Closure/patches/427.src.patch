diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
index 421d88ece..843f12669 100644
--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
@@ -533,11 +533,12 @@ public final class ReferenceCollectingCallback implements ScopedCallback,
         return false;
       }
 
-      // Make sure this assignment is not in a loop.
+      // Make sure this assignment is not in a loop or an enclosing function.
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
-          if (ref.getSymbol().getScope() != ref.scope) {
+          if (ref.getSymbol().getScope().getClosestHoistScope()
+              != ref.scope.getClosestHoistScope()) {
             return false;
           }
           break;
diff --git a/test/com/google/javascript/jscomp/InferConstsTest.java b/test/com/google/javascript/jscomp/InferConstsTest.java
index 9233ba016..a005dba76 100644
--- a/test/com/google/javascript/jscomp/InferConstsTest.java
+++ b/test/com/google/javascript/jscomp/InferConstsTest.java
@@ -136,8 +136,7 @@ public final class InferConstsTest extends TestCase {
   }
 
   public void testVarInBlock() {
-    // TODO(tbreisacher): x should be const.
-    testNotConsts("function f() { if (true) { var x = function() {}; x(); } }", "x");
+    testConsts("function f() { if (true) { var x = function() {}; x(); } }", "x");
   }
 
   private void testConsts(String js, String... constants) {
diff --git a/test/com/google/javascript/jscomp/ReferenceCollectingCallbackTest.java b/test/com/google/javascript/jscomp/ReferenceCollectingCallbackTest.java
index 4cd94a116..e40d7d08e 100644
--- a/test/com/google/javascript/jscomp/ReferenceCollectingCallbackTest.java
+++ b/test/com/google/javascript/jscomp/ReferenceCollectingCallbackTest.java
@@ -25,19 +25,102 @@ import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;
 
 public final class ReferenceCollectingCallbackTest extends CompilerTestCase {
   private Behavior behavior;
+  private boolean es6ScopeCreator;
 
   @Override
   public void setUp() {
     setLanguage(ECMASCRIPT_NEXT, ECMASCRIPT_NEXT);
     behavior = null;
+    es6ScopeCreator = true;
   }
 
   @Override
   protected CompilerPass getProcessor(final Compiler compiler) {
+    ScopeCreator scopeCreator =
+        es6ScopeCreator
+            ? new Es6SyntacticScopeCreator(compiler)
+            : SyntacticScopeCreator.makeUntyped(compiler);
     return new ReferenceCollectingCallback(
         compiler,
         this.behavior,
-        new Es6SyntacticScopeCreator(compiler));
+        scopeCreator);
+  }
+
+  public void testVarInBlock_oldScopeCreator() {
+    es6ScopeCreator = false;
+    behavior = new Behavior() {
+      @Override
+      public void afterExitScope(NodeTraversal t, ReferenceMap rm) {
+        if (t.getScope().isFunctionScope()) {
+          ReferenceCollection y = rm.getReferences(t.getScope().getVar("y"));
+          assertThat(y.isAssignedOnceInLifetime()).isTrue();
+          assertThat(y.isWellDefined()).isTrue();
+        }
+      }
+    };
+    testSame(
+        LINE_JOINER.join(
+            "function f(x) {",
+            "  if (true) {",
+            "    var y = x;",
+            "    y;",
+            "    y;",
+            "  }",
+            "}"));
+  }
+
+  public void testVarInBlock() {
+    behavior = new Behavior() {
+      @Override
+      public void afterExitScope(NodeTraversal t, ReferenceMap rm) {
+        if (t.getScope().isBlockScope() && t.getScope().getParent().isFunctionBlockScope()) {
+          ReferenceCollection y = rm.getReferences(t.getScope().getVar("y"));
+          assertThat(y.isAssignedOnceInLifetime()).isTrue();
+          assertThat(y.isWellDefined()).isTrue();
+        }
+      }
+    };
+    testSame(
+        LINE_JOINER.join(
+            "function f(x) {",
+            "  if (true) {",
+            "    var y = x;",
+            "    y;",
+            "    y;",
+            "  }",
+            "}"));
+  }
+
+  public void testVarInLoopNotAssignedOnlyOnceInLifetime() {
+    behavior = new Behavior() {
+      @Override
+      public void afterExitScope(NodeTraversal t, ReferenceMap rm)  {
+        if (t.getScope().isBlockScope()) {
+          ReferenceCollection x = rm.getReferences(t.getScope().getVar("x"));
+          assertThat(x.isAssignedOnceInLifetime()).isFalse();
+        }
+      }
+    };
+    testSame("while (true) { var x = 0; }");
+    testSame("while (true) { let x = 0; }");
+  }
+
+  /**
+   * Although there is only one assignment to x in the code, it's in a function which could be
+   * called multiple times, so {@code isAssignedOnceInLifetime()} returns false.
+   */
+  public void testVarInFunctionNotAssignedOnlyOnceInLifetime() {
+    behavior = new Behavior() {
+      @Override
+      public void afterExitScope(NodeTraversal t, ReferenceMap rm)  {
+        if (t.getScope().isGlobal()) {
+          ReferenceCollection x = rm.getReferences(t.getScope().getVar("x"));
+          assertThat(x.isAssignedOnceInLifetime()).isFalse();
+        }
+      }
+    };
+    testSame("var x; function f() { x = 0; }");
+    testSame("let x; function f() { x = 0; }");
   }
 
   public void testParameterAssignedOnlyOnceInLifetime() {
