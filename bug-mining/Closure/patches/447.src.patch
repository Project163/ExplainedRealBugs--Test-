diff --git a/src/com/google/javascript/jscomp/AstValidator.java b/src/com/google/javascript/jscomp/AstValidator.java
index 96fac3715..53ebd4704 100644
--- a/src/com/google/javascript/jscomp/AstValidator.java
+++ b/src/com/google/javascript/jscomp/AstValidator.java
@@ -256,10 +256,16 @@ public final class AstValidator implements CompilerPass {
     }
     switch (n.getToken()) {
       // Childless expressions
-      case FALSE:
       case NEW_TARGET:
-      case NULL:
+        validateFeature(Feature.NEW_TARGET, n);
+        validateChildless(n);
+        return;
       case SUPER:
+        validateFeature(Feature.SUPER, n);
+        validateChildless(n);
+        return;
+      case FALSE:
+      case NULL:
       case THIS:
       case TRUE:
         validateChildless(n);
@@ -286,6 +292,10 @@ public final class AstValidator implements CompilerPass {
       case ASSIGN:
         validateAssignmentExpression(n);
         return;
+      case ASSIGN_EXPONENT:
+        validateFeature(Feature.EXPONENT_OP, n);
+        validateCompoundAssignmentExpression(n);
+        return;
       case ASSIGN_BITOR:
       case ASSIGN_BITXOR:
       case ASSIGN_BITAND:
@@ -297,7 +307,6 @@ public final class AstValidator implements CompilerPass {
       case ASSIGN_MUL:
       case ASSIGN_DIV:
       case ASSIGN_MOD:
-      case ASSIGN_EXPONENT:
         validateCompoundAssignmentExpression(n);
         return;
 
@@ -319,6 +328,10 @@ public final class AstValidator implements CompilerPass {
         return;
 
       // General binary ops
+      case EXPONENT:
+        validateFeature(Feature.EXPONENT_OP, n);
+        validateBinaryOp(n);
+        return;
       case GETELEM:
       case COMMA:
       case OR:
@@ -344,7 +357,6 @@ public final class AstValidator implements CompilerPass {
       case MUL:
       case MOD:
       case DIV:
-      case EXPONENT:
         validateBinaryOp(n);
         return;
 
@@ -542,6 +554,7 @@ public final class AstValidator implements CompilerPass {
   }
 
   private void validateExport(Node n, boolean isAmbient) {
+    validateFeature(Feature.MODULES, n);
     validateNodeType(Token.EXPORT, n);
     if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) { // export * from "mod"
       validateChildCount(n, 2);
@@ -718,6 +731,8 @@ public final class AstValidator implements CompilerPass {
   private void validateClassMember(Node n, boolean isAmbient) {
     switch (n.getToken()) {
       case MEMBER_FUNCTION_DEF:
+        validateFeature(Feature.MEMBER_DECLARATIONS, n);
+        // fall through
       case GETTER_DEF:
       case SETTER_DEF:
         validateObjectLiteralKeyName(n);
@@ -832,6 +847,11 @@ public final class AstValidator implements CompilerPass {
     validateName(n.getFirstChild());
     validateParameters(n.getSecondChild());
     validateFunctionBody(n.getLastChild(), false);
+    validateFunctionFeatures(n);
+    if (n.getParent().isBlock() && !n.getGrandparent().isFunction()) {
+      // e.g. if (true) { function f() {} }
+      validateFeature(Feature.BLOCK_SCOPED_FUNCTION_DECLARATION, n);
+    }
   }
 
   private void validateFunctionExpression(Node n) {
@@ -851,7 +871,6 @@ public final class AstValidator implements CompilerPass {
     Node name = n.getFirstChild();
     Node body = n.getLastChild();
     if (n.isArrowFunction()) {
-      validateFeature(Feature.ARROW_FUNCTIONS, n);
       validateEmptyName(name);
       if (body.isBlock()) {
         validateBlock(body);
@@ -862,6 +881,19 @@ public final class AstValidator implements CompilerPass {
       validateOptionalName(name);
       validateFunctionBody(body, isAmbient);
     }
+    validateFunctionFeatures(n);
+  }
+
+  private void validateFunctionFeatures(Node n) {
+    if (n.isArrowFunction()) {
+      validateFeature(Feature.ARROW_FUNCTIONS, n);
+    }
+    if (n.isGeneratorFunction()) {
+      validateFeature(Feature.GENERATORS, n);
+    }
+    if (n.isAsyncFunction()) {
+      validateFeature(Feature.ASYNC_FUNCTIONS, n);
+    }
   }
 
   private void validateFunctionBody(Node n, boolean noBlock) {
@@ -945,9 +977,14 @@ public final class AstValidator implements CompilerPass {
         if (n == parent.getFirstChild()) {
           violation("SPREAD node is not callable.", n);
         }
+        validateFeature(Feature.SPREAD_EXPRESSIONS, n);
         break;
-      case ARRAYLIT:
       case OBJECTLIT:
+        validateFeature(Feature.OBJECT_LITERALS_WITH_SPREAD, n);
+        validateFeature(Feature.SPREAD_EXPRESSIONS, n);
+        break;
+      case ARRAYLIT:
+        validateFeature(Feature.SPREAD_EXPRESSIONS, n);
         break;
       default:
         violation("SPREAD node should not be the child of a " + parent.getToken() + " node.", n);
@@ -1113,6 +1150,7 @@ public final class AstValidator implements CompilerPass {
   }
 
   private void validateForOf(Node n) {
+    validateFeature(Feature.FOR_OF, n);
     validateNodeType(Token.FOR_OF, n);
     validateChildCount(n);
     validateVarOrAssignmentTarget(n.getFirstChild());
@@ -1408,6 +1446,7 @@ public final class AstValidator implements CompilerPass {
   }
 
   private void validateObjectLitGetKey(Node n) {
+    validateFeature(Feature.GETTER, n);
     validateNodeType(Token.GETTER_DEF, n);
     validateChildCount(n);
     validateObjectLiteralKeyName(n);
@@ -1424,6 +1463,7 @@ public final class AstValidator implements CompilerPass {
   }
 
   private void validateObjectLitSetKey(Node n) {
+    validateFeature(Feature.SETTER, n);
     validateNodeType(Token.SETTER_DEF, n);
     validateChildCount(n);
     validateObjectLiteralKeyName(n);
@@ -1445,6 +1485,9 @@ public final class AstValidator implements CompilerPass {
 
     validateChildCount(n, 1);
     validateExpression(n.getFirstChild());
+    if (n.getBooleanProp(Node.IS_SHORTHAND_PROPERTY)) {
+      validateFeature(Feature.EXTENDED_OBJECT_LITERALS, n);
+    }
   }
 
   private void validateObjectPatternStringKey(Token type, Node n) {
@@ -1463,6 +1506,7 @@ public final class AstValidator implements CompilerPass {
   }
 
   private void validateObjectLitComputedPropKey(Node n) {
+    validateFeature(Feature.COMPUTED_PROPERTIES, n);
     validateNodeType(Token.COMPUTED_PROP, n);
     validateChildCount(n);
     validateExpression(n.getFirstChild());
@@ -1470,6 +1514,7 @@ public final class AstValidator implements CompilerPass {
   }
 
   private void validateObjectPatternComputedPropKey(Token type, Node n) {
+    validateFeature(Feature.COMPUTED_PROPERTIES, n);
     validateNodeType(Token.COMPUTED_PROP, n);
     validateChildCount(n);
     validateExpression(n.getFirstChild());
@@ -1481,6 +1526,7 @@ public final class AstValidator implements CompilerPass {
   }
 
   private void validateComputedPropClassMethod(Node n) {
+    validateFeature(Feature.COMPUTED_PROPERTIES, n);
     validateNodeType(Token.COMPUTED_PROP, n);
     validateExpression(n.getFirstChild());
     if (n.getBooleanProp(Node.COMPUTED_PROP_VARIABLE)) {
@@ -1687,7 +1733,9 @@ public final class AstValidator implements CompilerPass {
   }
 
   private void validateFeature(Feature feature, Node n) {
-    if (!compiler.getFeatureSet().has(feature)) {
+    if (!n.isFromExterns() && !compiler.getFeatureSet().has(feature)) {
+      // Skip this check for externs because we don't need to complete transpilation on externs,
+      // and currently only transpile externs so that we can typecheck ES6+ features in externs.
       violation("AST should not contain " + feature, n);
     }
     // Note: currentScript may be null if someone called validateStatement or validateExpression
diff --git a/src/com/google/javascript/jscomp/Es6ConvertSuper.java b/src/com/google/javascript/jscomp/Es6ConvertSuper.java
index 79339df20..a76e9b4b7 100644
--- a/src/com/google/javascript/jscomp/Es6ConvertSuper.java
+++ b/src/com/google/javascript/jscomp/Es6ConvertSuper.java
@@ -267,12 +267,11 @@ public final class Es6ConvertSuper extends NodeTraversal.AbstractPostOrderCallba
     // Might need to synthesize constructors for ambient classes in .d.ts externs
     TranspilationPasses.processTranspile(compiler, externs, transpiledFeatures, this);
     TranspilationPasses.processTranspile(compiler, root, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
   public void hotSwapScript(Node scriptRoot, Node originalRoot) {
     TranspilationPasses.hotSwapTranspile(compiler, scriptRoot, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 }
diff --git a/src/com/google/javascript/jscomp/Es6ConvertSuperConstructorCalls.java b/src/com/google/javascript/jscomp/Es6ConvertSuperConstructorCalls.java
index c1fc7760e..d6df9bb80 100644
--- a/src/com/google/javascript/jscomp/Es6ConvertSuperConstructorCalls.java
+++ b/src/com/google/javascript/jscomp/Es6ConvertSuperConstructorCalls.java
@@ -51,8 +51,7 @@ implements NodeTraversal.Callback, HotSwapCompilerPass {
   private final AbstractCompiler compiler;
   private final Deque<ConstructorData> constructorDataStack;
   private GlobalNamespace globalNamespace;
-  private static final FeatureSet transpiledFeatures =
-      FeatureSet.BARE_MINIMUM.with(Feature.CLASSES, Feature.SUPER);
+  private static final FeatureSet transpiledFeatures = FeatureSet.BARE_MINIMUM.with(Feature.SUPER);
 
   public Es6ConvertSuperConstructorCalls(AbstractCompiler compiler) {
     this.compiler = compiler;
@@ -492,6 +491,7 @@ implements NodeTraversal.Callback, HotSwapCompilerPass {
     // Might need to synthesize constructors for ambient classes in .d.ts externs
     TranspilationPasses.processTranspile(compiler, externs, transpiledFeatures, this);
     TranspilationPasses.processTranspile(compiler, root, transpiledFeatures, this);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
diff --git a/src/com/google/javascript/jscomp/Es6ForOfConverter.java b/src/com/google/javascript/jscomp/Es6ForOfConverter.java
index b4c62869a..d906b3dc6 100644
--- a/src/com/google/javascript/jscomp/Es6ForOfConverter.java
+++ b/src/com/google/javascript/jscomp/Es6ForOfConverter.java
@@ -66,13 +66,13 @@ public final class Es6ForOfConverter implements NodeTraversal.Callback, HotSwapC
   public void process(Node externs, Node root) {
     TranspilationPasses.processTranspile(compiler, externs, transpiledFeatures, this);
     TranspilationPasses.processTranspile(compiler, root, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
   public void hotSwapScript(Node scriptRoot, Node originalRoot) {
     TranspilationPasses.hotSwapTranspile(compiler, scriptRoot, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
diff --git a/src/com/google/javascript/jscomp/Es6NormalizeShorthandProperties.java b/src/com/google/javascript/jscomp/Es6NormalizeShorthandProperties.java
index f819fe180..053633877 100644
--- a/src/com/google/javascript/jscomp/Es6NormalizeShorthandProperties.java
+++ b/src/com/google/javascript/jscomp/Es6NormalizeShorthandProperties.java
@@ -39,6 +39,7 @@ public final class Es6NormalizeShorthandProperties extends AbstractPostOrderCall
   public void process(Node externs, Node root) {
     TranspilationPasses.processTranspile(compiler, externs, transpiledFeatures, this);
     TranspilationPasses.processTranspile(compiler, root, transpiledFeatures, this);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
diff --git a/src/com/google/javascript/jscomp/Es6RewriteArrowFunction.java b/src/com/google/javascript/jscomp/Es6RewriteArrowFunction.java
index 6c6ec745b..25c18abda 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteArrowFunction.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteArrowFunction.java
@@ -51,13 +51,13 @@ public class Es6RewriteArrowFunction implements NodeTraversal.Callback, HotSwapC
   public void process(Node externs, Node root) {
     TranspilationPasses.processTranspile(compiler, externs, transpiledFeatures, this);
     TranspilationPasses.processTranspile(compiler, root, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
   public void hotSwapScript(Node scriptRoot, Node originalRoot) {
     TranspilationPasses.hotSwapTranspile(compiler, scriptRoot, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
diff --git a/src/com/google/javascript/jscomp/Es6RewriteBlockScopedDeclaration.java b/src/com/google/javascript/jscomp/Es6RewriteBlockScopedDeclaration.java
index aad31f9a0..37c97794d 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteBlockScopedDeclaration.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteBlockScopedDeclaration.java
@@ -110,7 +110,7 @@ public final class Es6RewriteBlockScopedDeclaration extends AbstractPostOrderCal
     NodeTraversal.traverse(compiler, root, transformer);
     transformer.transformLoopClosure();
     rewriteDeclsToVars();
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
@@ -123,7 +123,7 @@ public final class Es6RewriteBlockScopedDeclaration extends AbstractPostOrderCal
     NodeTraversal.traverse(compiler, scriptRoot, transformer);
     transformer.transformLoopClosure();
     rewriteDeclsToVars();
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   private boolean getShouldAddTypesOnNewAstNodes() {
diff --git a/src/com/google/javascript/jscomp/Es6RewriteBlockScopedFunctionDeclaration.java b/src/com/google/javascript/jscomp/Es6RewriteBlockScopedFunctionDeclaration.java
index 8a7c723bf..1258dacac 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteBlockScopedFunctionDeclaration.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteBlockScopedFunctionDeclaration.java
@@ -42,13 +42,13 @@ public final class Es6RewriteBlockScopedFunctionDeclaration extends AbstractPost
   public void process(Node externs, Node root) {
     TranspilationPasses.processTranspile(compiler, externs, transpiledFeatures, this);
     TranspilationPasses.processTranspile(compiler, root, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
   public void hotSwapScript(Node scriptRoot, Node originalRoot) {
     TranspilationPasses.hotSwapTranspile(compiler, scriptRoot, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
diff --git a/src/com/google/javascript/jscomp/Es6RewriteClass.java b/src/com/google/javascript/jscomp/Es6RewriteClass.java
index 70480fc93..333374e97 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteClass.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteClass.java
@@ -75,12 +75,7 @@ public final class Es6RewriteClass implements NodeTraversal.Callback, HotSwapCom
   public void process(Node externs, Node root) {
     TranspilationPasses.processTranspile(compiler, externs, features, this);
     TranspilationPasses.processTranspile(compiler, root, features, this);
-    // Don't mark features as transpiled away if we had errors that prevented transpilation.
-    // We don't want a redundant error from the AstValidator complaining that the features are still
-    // there
-    if (!compiler.hasHaltingErrors()) {
-      TranspilationPasses.markFeaturesAsTranspiledAway(compiler, features);
-    }
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, features);
   }
 
   @Override
@@ -90,7 +85,7 @@ public final class Es6RewriteClass implements NodeTraversal.Callback, HotSwapCom
     // We don't want a redundant error from the AstValidator complaining that the features are still
     // there
     if (!compiler.hasHaltingErrors()) {
-      TranspilationPasses.markFeaturesAsTranspiledAway(compiler, features);
+      TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, features);
     }
   }
 
diff --git a/src/com/google/javascript/jscomp/Es6RewriteDestructuring.java b/src/com/google/javascript/jscomp/Es6RewriteDestructuring.java
index fd3f5567f..d6dc2bd0b 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteDestructuring.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteDestructuring.java
@@ -50,13 +50,13 @@ public final class Es6RewriteDestructuring implements NodeTraversal.Callback, Ho
   public void process(Node externs, Node root) {
     TranspilationPasses.processTranspile(compiler, externs, transpiledFeatures, this);
     TranspilationPasses.processTranspile(compiler, root, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
   public void hotSwapScript(Node scriptRoot, Node originalRoot) {
     TranspilationPasses.hotSwapTranspile(compiler, scriptRoot, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
diff --git a/src/com/google/javascript/jscomp/Es6RewriteGenerators.java b/src/com/google/javascript/jscomp/Es6RewriteGenerators.java
index 7f79f2d7b..cd005905e 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteGenerators.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteGenerators.java
@@ -119,14 +119,14 @@ final class Es6RewriteGenerators implements HotSwapCompilerPass {
   public void process(Node externs, Node root) {
     TranspilationPasses.processTranspile(
         compiler, root, transpiledFeatures, new GeneratorFunctionsTranspiler());
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
   public void hotSwapScript(Node scriptRoot, Node originalRoot) {
     TranspilationPasses.hotSwapTranspile(
         compiler, scriptRoot, transpiledFeatures, new GeneratorFunctionsTranspiler());
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   /**
diff --git a/src/com/google/javascript/jscomp/Es6RewriteRestAndSpread.java b/src/com/google/javascript/jscomp/Es6RewriteRestAndSpread.java
index 3a570af12..a929be9d4 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteRestAndSpread.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteRestAndSpread.java
@@ -90,13 +90,13 @@ public final class Es6RewriteRestAndSpread extends NodeTraversal.AbstractPostOrd
   public void process(Node externs, Node root) {
     TranspilationPasses.processTranspile(compiler, externs, transpiledFeatures, this);
     TranspilationPasses.processTranspile(compiler, root, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
   public void hotSwapScript(Node scriptRoot, Node originalRoot) {
     TranspilationPasses.hotSwapTranspile(compiler, scriptRoot, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
diff --git a/src/com/google/javascript/jscomp/Es7RewriteExponentialOperator.java b/src/com/google/javascript/jscomp/Es7RewriteExponentialOperator.java
index 12bc38eee..5f0fcb4ff 100644
--- a/src/com/google/javascript/jscomp/Es7RewriteExponentialOperator.java
+++ b/src/com/google/javascript/jscomp/Es7RewriteExponentialOperator.java
@@ -62,13 +62,13 @@ public final class Es7RewriteExponentialOperator
   public void process(Node externs, Node root) {
     TranspilationPasses.processTranspile(compiler, externs, transpiledFeatures, this);
     TranspilationPasses.processTranspile(compiler, root, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
   public void hotSwapScript(Node scriptRoot, Node originalRoot) {
     TranspilationPasses.hotSwapTranspile(compiler, scriptRoot, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
diff --git a/src/com/google/javascript/jscomp/EsNextToEs8Converter.java b/src/com/google/javascript/jscomp/EsNextToEs8Converter.java
index 64bfbc1e3..d527e6ff6 100644
--- a/src/com/google/javascript/jscomp/EsNextToEs8Converter.java
+++ b/src/com/google/javascript/jscomp/EsNextToEs8Converter.java
@@ -58,13 +58,13 @@ public final class EsNextToEs8Converter implements NodeTraversal.Callback, HotSw
   public void process(Node externs, Node root) {
     TranspilationPasses.processTranspile(compiler, externs, transpiledFeatures, this);
     TranspilationPasses.processTranspile(compiler, root, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
   public void hotSwapScript(Node scriptRoot, Node originalRoot) {
     TranspilationPasses.hotSwapTranspile(compiler, scriptRoot, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
diff --git a/src/com/google/javascript/jscomp/LateEs6ToEs3Converter.java b/src/com/google/javascript/jscomp/LateEs6ToEs3Converter.java
index e90ba3cd0..af330d029 100644
--- a/src/com/google/javascript/jscomp/LateEs6ToEs3Converter.java
+++ b/src/com/google/javascript/jscomp/LateEs6ToEs3Converter.java
@@ -48,8 +48,6 @@ public final class LateEs6ToEs3Converter implements NodeTraversal.Callback, HotS
   private static final FeatureSet transpiledFeatures =
       FeatureSet.BARE_MINIMUM.with(
           Feature.COMPUTED_PROPERTIES,
-          Feature.EXTENDED_OBJECT_LITERALS,
-          Feature.FOR_OF,
           Feature.MEMBER_DECLARATIONS,
           Feature.TEMPLATE_LITERALS);
   // addTypes indicates whether we should add type information when transpiling.
@@ -73,13 +71,13 @@ public final class LateEs6ToEs3Converter implements NodeTraversal.Callback, HotS
   public void process(Node externs, Node root) {
     TranspilationPasses.processTranspile(compiler, externs, transpiledFeatures, this);
     TranspilationPasses.processTranspile(compiler, root, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
   public void hotSwapScript(Node scriptRoot, Node originalRoot) {
     TranspilationPasses.hotSwapTranspile(compiler, scriptRoot, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
diff --git a/src/com/google/javascript/jscomp/RewriteAsyncFunctions.java b/src/com/google/javascript/jscomp/RewriteAsyncFunctions.java
index f03e86965..bb749d8cb 100644
--- a/src/com/google/javascript/jscomp/RewriteAsyncFunctions.java
+++ b/src/com/google/javascript/jscomp/RewriteAsyncFunctions.java
@@ -136,13 +136,13 @@ public final class RewriteAsyncFunctions implements NodeTraversal.Callback, HotS
   public void process(Node externs, Node root) {
     TranspilationPasses.processTranspile(compiler, externs, transpiledFeatures, this);
     TranspilationPasses.processTranspile(compiler, root, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
   public void hotSwapScript(Node scriptRoot, Node originalRoot) {
     TranspilationPasses.hotSwapTranspile(compiler, scriptRoot, transpiledFeatures, this);
-    TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
+    TranspilationPasses.maybeMarkFeaturesAsTranspiledAway(compiler, transpiledFeatures);
   }
 
   @Override
diff --git a/src/com/google/javascript/jscomp/TranspilationPasses.java b/src/com/google/javascript/jscomp/TranspilationPasses.java
index bbd9efda0..bc8cb6a5b 100644
--- a/src/com/google/javascript/jscomp/TranspilationPasses.java
+++ b/src/com/google/javascript/jscomp/TranspilationPasses.java
@@ -535,15 +535,21 @@ public class TranspilationPasses {
     }
   }
 
-  static void markFeaturesAsTranspiledAway(
+  static void maybeMarkFeaturesAsTranspiledAway(
       AbstractCompiler compiler, FeatureSet transpiledFeatures) {
-    compiler.setFeatureSet(compiler.getFeatureSet().without(transpiledFeatures));
+    // We don't bother to do this if the compiler has halting errors, which avoids unnecessary
+    // warnings from AstValidator warning that the features are still there.
+    if (!compiler.hasHaltingErrors()) {
+      compiler.setFeatureSet(compiler.getFeatureSet().without(transpiledFeatures));
+    }
   }
 
-  static void markFeaturesAsTranspiledAway(
+  static void maybeMarkFeaturesAsTranspiledAway(
       AbstractCompiler compiler, Feature transpiledFeature, Feature... moreTranspiledFeatures) {
-    compiler.setFeatureSet(
-        compiler.getFeatureSet().without(transpiledFeature, moreTranspiledFeatures));
+    if (!compiler.hasHaltingErrors()) {
+      compiler.setFeatureSet(
+          compiler.getFeatureSet().without(transpiledFeature, moreTranspiledFeatures));
+    }
   }
 
   /**
@@ -560,12 +566,12 @@ public class TranspilationPasses {
         return new HotSwapCompilerPass() {
           @Override
           public void hotSwapScript(Node scriptRoot, Node originalRoot) {
-            markFeaturesAsTranspiledAway(compiler, featureToRemove, moreFeaturesToRemove);
+            maybeMarkFeaturesAsTranspiledAway(compiler, featureToRemove, moreFeaturesToRemove);
           }
 
           @Override
           public void process(Node externs, Node root) {
-            markFeaturesAsTranspiledAway(compiler, featureToRemove, moreFeaturesToRemove);
+            maybeMarkFeaturesAsTranspiledAway(compiler, featureToRemove, moreFeaturesToRemove);
           }
         };
       }
diff --git a/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java b/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java
index 6257a0476..3839b98db 100644
--- a/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java
+++ b/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java
@@ -81,8 +81,7 @@ public final class FeatureSet implements Serializable {
           .without(Feature.DEFAULT_PARAMETERS)
           .without(Feature.DESTRUCTURING)
           .without(Feature.MODULES)
-          .without(Feature.NEW_TARGET)
-          .without(Feature.SUPER);
+          .without(Feature.NEW_TARGET);
 
   private enum LangVersion {
     ES3,
diff --git a/test/com/google/javascript/jscomp/AstValidatorTest.java b/test/com/google/javascript/jscomp/AstValidatorTest.java
index ad5f46ce2..cabde3341 100644
--- a/test/com/google/javascript/jscomp/AstValidatorTest.java
+++ b/test/com/google/javascript/jscomp/AstValidatorTest.java
@@ -16,6 +16,8 @@
 
 package com.google.javascript.jscomp;
 
+import static com.google.javascript.jscomp.testing.NodeSubject.assertNode;
+
 import com.google.javascript.jscomp.AstValidator.ViolationHandler;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.parsing.parser.FeatureSet;
@@ -268,8 +270,6 @@ public final class AstValidatorTest extends CompilerTestCase {
   public void testInvalidArrayPattern0() {
     setAcceptedLanguage(LanguageMode.ECMASCRIPT_2015);
 
-    setAcceptedLanguage(LanguageMode.ECMASCRIPT_2015);
-
     // [...x = 1] = [];
     Node n = IR.assign(
         new Node(Token.ARRAY_PATTERN,
@@ -389,6 +389,117 @@ public final class AstValidatorTest extends CompilerTestCase {
     expectInvalid(n, Check.EXPRESSION);
   }
 
+  /** Tests checking that AstValidator validates one particular Feature in the AST. */
+  public void testFeatureValidation_getter() {
+    testFeatureValidation("var obj = {get f() {}};", Feature.GETTER);
+  }
+
+  public void testFeatureValidation_setter() {
+    testFeatureValidation("var obj = {set f(x) {}};", Feature.SETTER);
+  }
+
+  public void testFeatureValidation_arrowFunctions() {
+    testFeatureValidation("var arrow = () => 3", Feature.ARROW_FUNCTIONS);
+    testFeatureValidation("var asyncArrow = async () => 3", Feature.ARROW_FUNCTIONS);
+  }
+
+  public void testFeatureValidation_blockScopedFunctionDeclaration() {
+    testFeatureValidation("{ function f() {} }", Feature.BLOCK_SCOPED_FUNCTION_DECLARATION);
+    testFeatureValidation(
+        "function f() { if (true) { function g() {} } }",
+        Feature.BLOCK_SCOPED_FUNCTION_DECLARATION);
+    valid("function f() {}");
+  }
+
+  public void testFeatureValidation_classes() {
+    testFeatureValidation("class C {}", Feature.CLASSES);
+    testFeatureValidation("var C = class {}", Feature.CLASSES);
+  }
+
+  public void testFeatureValidation_computedProperties() {
+    testFeatureValidation("var obj = { ['foo' + 3]: 4};", Feature.COMPUTED_PROPERTIES);
+    testFeatureValidation("var { ['foo' + 3]: x} = obj;", Feature.COMPUTED_PROPERTIES);
+    testFeatureValidation("class C { ['foobar']() {} }", Feature.COMPUTED_PROPERTIES);
+  }
+
+  public void testFeatureValidation_defaultParameters() {
+    testFeatureValidation("function f(a = 1) {}", Feature.DEFAULT_PARAMETERS);
+    testFeatureValidation("((a = 3) => a)", Feature.DEFAULT_PARAMETERS);
+  }
+
+  public void testFeatureValidation_destructuring() {
+    testFeatureValidation("var x, {a, b} = obj;", Feature.DESTRUCTURING);
+    testFeatureValidation("var x, [a, b] = arr;", Feature.DESTRUCTURING);
+    testFeatureValidation("(x = 0, {a, b} = obj);", Feature.DESTRUCTURING);
+    testFeatureValidation("x = 0, [a, b] = obj;", Feature.DESTRUCTURING);
+    testFeatureValidation("for ({a, b} of c) {}", Feature.DESTRUCTURING);
+    testFeatureValidation("for ([a, b] of c) {}", Feature.DESTRUCTURING);
+  }
+
+  public void testFeatureValidation_extendedObjectLiterals() {
+    testFeatureValidation("var obj = { x };", Feature.EXTENDED_OBJECT_LITERALS);
+  }
+
+  public void testFeatureValidation_forOf() {
+    testFeatureValidation("for (const a of b) {}", Feature.FOR_OF);
+  }
+
+  public void testFeatureValidation_generatorFunctions() {
+    testFeatureValidation("const f = function *() {}", Feature.GENERATORS);
+    testFeatureValidation("function *f() {}", Feature.GENERATORS);
+    testFeatureValidation("class C { *f() {} }", Feature.GENERATORS);
+  }
+
+  public void testFeatureValidation_memberDeclarations() {
+    testFeatureValidation("class C { f() {} }", Feature.MEMBER_DECLARATIONS);
+    testFeatureValidation("var obj = { f() {} };", Feature.MEMBER_DECLARATIONS);
+  }
+
+  public void testFeatureValidation_newTarget() {
+    testFeatureValidation("function f() { new.target }", Feature.NEW_TARGET);
+  }
+
+  public void testFeatureValidation_restParameters() {
+    testFeatureValidation("function f(...rest) {}", Feature.REST_PARAMETERS);
+  }
+
+  public void testFeatureValidation_spreadExpressions() {
+    testFeatureValidation("f(...arr);", Feature.SPREAD_EXPRESSIONS);
+    testFeatureValidation("var arr = [...something];", Feature.SPREAD_EXPRESSIONS);
+    testFeatureValidation("var obj = {...something};", Feature.SPREAD_EXPRESSIONS);
+  }
+
+  public void testFeatureValidation_super() {
+    testFeatureValidation("class C extends B { constructor() { super(); } }", Feature.SUPER);
+    testFeatureValidation("class C extends B { f() { super.method(); } }", Feature.SUPER);
+  }
+
+  public void testFeatureValidation_templateLiterals() {
+    testFeatureValidation("`foo ${3} bar `", Feature.TEMPLATE_LITERALS);
+    testFeatureValidation("tag`foo ${3} bar`", Feature.TEMPLATE_LITERALS);
+  }
+
+  public void testFeatureValidation_modules() {
+    testFeatureValidation("export {x};", Feature.MODULES);
+    testFeatureValidation("import {x} from './foo.js';", Feature.MODULES);
+  }
+
+  public void testFeatureValidation_exponentOp() {
+    testFeatureValidation("2 ** 3", Feature.EXPONENT_OP);
+    testFeatureValidation("x **= 3;", Feature.EXPONENT_OP);
+  }
+
+  public void testFeatureValidation_asyncFunctions() {
+    testFeatureValidation("const f = async function() {}", Feature.ASYNC_FUNCTIONS);
+    testFeatureValidation("async function f() {}", Feature.ASYNC_FUNCTIONS);
+    testFeatureValidation("class C { async f() {} }", Feature.ASYNC_FUNCTIONS);
+    testFeatureValidation("(async () => {})", Feature.ASYNC_FUNCTIONS);
+  }
+
+  public void testFeatureValidation_objectLiteralsWithSpread() {
+    testFeatureValidation("var obj = {...something};", Feature.OBJECT_LITERALS_WITH_SPREAD);
+  }
+
   public void testValidFeatureInScript() {
     setAcceptedLanguage(LanguageMode.ECMASCRIPT_2015);
 
@@ -438,4 +549,33 @@ public final class AstValidatorTest extends CompilerTestCase {
   private void expectValid(Node n, Check level) {
     assertTrue(doCheck(n, level));
   }
+
+  /**
+   * Tests that AstValidator checks for the given feature in the AST
+   *
+   * <p>This will raise an error if a) the AST parsed from {@code code} lacks {@code feature}, or
+   * b) AstValidator does not validate {@code feature}'s presence in the AST.
+   */
+  private void testFeatureValidation(String code, Feature feature) {
+    Node script = parseScriptWithoutCheckingLanguageLevel(code);
+    expectValid(script, Check.SCRIPT);
+
+    // Remove `feature` from the SCRIPT node's feature set, checking that it was originally present,
+    // and then validate that AstValidator errors because it expects `feature` to be present.
+    FeatureSet currentFeatures = NodeUtil.getFeatureSetOfScript(script);
+    assertTrue(currentFeatures.contains(feature));
+
+    script.putProp(Node.FEATURE_SET, currentFeatures.without(feature));
+    expectInvalid(script, Check.SCRIPT);
+  }
+
+  private Node parseScriptWithoutCheckingLanguageLevel(String code) {
+    setAcceptedLanguage(LanguageMode.ECMASCRIPT_NEXT);
+    Node n = parseExpectedJs(code);
+    Node script = n.getFirstChild();
+    assertNode(script).hasType(Token.SCRIPT);
+    script.setInputId(new InputId("something_input"));
+    script.setStaticSourceFile(new SimpleSourceFile("something", false));
+    return script;
+  }
 }
