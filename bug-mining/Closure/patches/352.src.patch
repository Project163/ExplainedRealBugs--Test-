diff --git a/src/com/google/javascript/jscomp/GlobalTypeInfo.java b/src/com/google/javascript/jscomp/GlobalTypeInfo.java
index ef1bcfd84..f1f792487 100644
--- a/src/com/google/javascript/jscomp/GlobalTypeInfo.java
+++ b/src/com/google/javascript/jscomp/GlobalTypeInfo.java
@@ -121,6 +121,20 @@ class GlobalTypeInfo implements CompilerPass {
           "JSC_CONST_WITHOUT_INITIALIZER",
           "Constants must be initialized when they are defined.");
 
+  static final DiagnosticType MISPLACED_CONST_ANNOTATION =
+      DiagnosticType.warning(
+          "JSC_MISPLACED_CONST_ANNOTATION",
+          "This property cannot be @const." +
+          "The @const annotation is only allowed for " +
+          "properties of namespaces, prototype properties, " +
+          "static properties of constructors, " +
+          "and properties of the form this.prop declared inside constructors.");
+
+  static final DiagnosticType CANNOT_OVERRIDE_FINAL_METHOD =
+      DiagnosticType.warning(
+      "JSC_CANNOT_OVERRIDE_FINAL_METHOD",
+      "Final method {0} cannot be overriden.");
+
   // Invariant: if a scope s1 contains a scope s2, then s2 is before s1 in
   // scopes. The type inference relies on this fact to process deeper scopes
   // before shallower scopes.
@@ -342,7 +356,8 @@ class GlobalTypeInfo implements CompilerPass {
             continue add_interface_props;
           }
         }
-        rawNominalType.addProtoProperty(pname, resultType);
+        // TODO(dimvar): check if we can have @const props here
+        rawNominalType.addProtoProperty(pname, resultType, false);
       }
 
       // Warn for a prop declared with @override that isn't overriding anything.
@@ -387,6 +402,15 @@ class GlobalTypeInfo implements CompilerPass {
     PropertyDef localPropDef = propertyDefs.get(current.getId(), pname);
     JSType localPropType = localPropDef == null ? null :
         current.getPropDeclaredType(pname);
+    if (localPropDef != null && superType.isClass() &&
+        localPropType.getFunType() != null &&
+        superType.hasConstantProp(pname)) {
+      // TODO(dimvar): This doesn't work for multiple levels in the hierarchy.
+      // Clean up how we process inherited properties and then fix this.
+      warnings.add(JSError.make(
+          localPropDef.defSite, CANNOT_OVERRIDE_FINAL_METHOD, pname));
+      return;
+    }
     // System.out.println("nominalType: " + current + "'s " + pname +
     //     " localPropType: " + localPropType +
     //     " with super: " + superType +
@@ -527,8 +551,7 @@ class GlobalTypeInfo implements CompilerPass {
               } else if (parent.isCatch()) {
                 currentScope.addLocal(name, JSType.UNKNOWN, false);
               } else {
-                JSDocInfo jsdoc = parent.getJSDocInfo();
-                boolean isConstant = jsdoc != null && jsdoc.isConstant();
+                boolean isConstant = NodeUtil.hasConstAnnotation(parent);
                 if (isConstant && !n.isFromExterns() && initializer == null) {
                   warnings.add(JSError.make(n, CONST_WITHOUT_INITIALIZER));
                 }
@@ -571,7 +594,11 @@ class GlobalTypeInfo implements CompilerPass {
                   getTypeDeclarationFromJsdoc(
                       prop.getJSDocInfo(), currentScope));
             }
+            if (NodeUtil.hasConstAnnotation(prop)) {
+              warnings.add(JSError.make(prop, MISPLACED_CONST_ANNOTATION));
+            }
           }
+          break;
         }
       }
     }
@@ -579,6 +606,10 @@ class GlobalTypeInfo implements CompilerPass {
     private void visitPropertyDeclaration(Node getProp) {
       // Class property
       if (isClassPropAccess(getProp, currentScope)) {
+        if (NodeUtil.hasConstAnnotation(getProp) &&
+            currentScope.isPrototypeMethod()) {
+          warnings.add(JSError.make(getProp, MISPLACED_CONST_ANNOTATION));
+        }
         visitClassPropertyDeclaration(getProp);
         return;
       }
@@ -597,6 +628,11 @@ class GlobalTypeInfo implements CompilerPass {
       if (isPropDecl(getProp) && currentScope.isNamespace(
           getProp.getFirstChild().getQualifiedName())) {
         visitNamespacePropertyDeclaration(getProp);
+        return;
+      }
+      // Other property
+      if (NodeUtil.hasConstAnnotation(getProp)) {
+        warnings.add(JSError.make(getProp, MISPLACED_CONST_ANNOTATION));
       }
     }
 
@@ -660,6 +696,9 @@ class GlobalTypeInfo implements CompilerPass {
       RawNominalType rawType = currentScope.getNominalType(ctorName);
 
       if (rawType == null) {
+        if (initializer != null && initializer.isFunction()) {
+          visitFunctionDef(initializer, null);
+        }
         // We don't look at assignments to prototypes of non-constructors.
         return;
       }
@@ -705,11 +744,12 @@ class GlobalTypeInfo implements CompilerPass {
       propertyDefs.put(rawType.getId(), pname,
           new PropertyDef(getProp, methodType, methodScope));
       // Add the property to the class with the appropriate type.
-      if (propDeclType != null) {
+      boolean isConstant = NodeUtil.hasConstAnnotation(getProp);
+      if (propDeclType != null || isConstant) {
         if (mayWarnAboutExistingProp(rawType, pname, getProp)) {
           return;
         }
-        rawType.addProtoProperty(pname, propDeclType);
+        rawType.addProtoProperty(pname, propDeclType, isConstant);
       } else {
         rawType.addUndeclaredProtoProperty(pname);
       }
@@ -723,14 +763,15 @@ class GlobalTypeInfo implements CompilerPass {
       String pname = getProp.getLastChild().getString();
       JSType propDeclType = getTypeDeclarationFromJsdoc(
           NodeUtil.getBestJSDocInfo(getProp), currentScope);
-      if (propDeclType != null) {
+      boolean isConstant = NodeUtil.hasConstAnnotation(getProp);
+      if (propDeclType != null || isConstant) {
         if (classType.hasCtorProp(pname) &&
             classType.getCtorPropDeclaredType(pname) != null) {
           warnings.add(JSError.make(getProp, REDECLARED_PROPERTY,
                   pname, classType.toString()));
           return;
         }
-        classType.addCtorProperty(pname, propDeclType);
+        classType.addCtorProperty(pname, propDeclType, isConstant);
       } else {
         classType.addUndeclaredCtorProperty(pname);
       }
@@ -741,22 +782,24 @@ class GlobalTypeInfo implements CompilerPass {
       QualifiedName qname = QualifiedName.fromGetprop(getProp);
       String leftmost = qname.getLeftmostName();
       QualifiedName allButLeftmost = qname.getAllButLeftmost();
+      JSType currentType = currentScope.getDeclaredTypeOf(leftmost);
       JSType typeInJsdoc = getTypeDeclarationFromJsdoc(
           NodeUtil.getBestJSDocInfo(getProp), currentScope);
-      JSType currentType = currentScope.getDeclaredTypeOf(leftmost);
-      if (typeInJsdoc == null) {
+      boolean isConstant = NodeUtil.hasConstAnnotation(getProp);
+      if (typeInJsdoc != null || isConstant) {
+        if (currentType.mayHaveProp(allButLeftmost) &&
+            currentType.getDeclaredProp(allButLeftmost) != null) {
+          warnings.add(JSError.make(getProp, REDECLARED_PROPERTY,
+                  allButLeftmost.toString(), currentType.toString()));
+          return;
+        }
+        currentScope.updateTypeOfLocal(leftmost,
+            currentType.withDeclaredProperty(
+                allButLeftmost, typeInJsdoc, isConstant));
+      } else {
         currentScope.updateTypeOfLocal(leftmost,
             currentType.withProperty(allButLeftmost, JSType.UNKNOWN));
-        return;
-      }
-      if (currentType.mayHaveProp(allButLeftmost) &&
-          currentType.getDeclaredProp(allButLeftmost) != null) {
-        warnings.add(JSError.make(getProp, REDECLARED_PROPERTY,
-                getProp.getQualifiedName(), currentType.toString()));
-        return;
       }
-      currentScope.updateTypeOfLocal(leftmost,
-          currentType.withDeclaredProperty(allButLeftmost, typeInJsdoc));
     }
 
     private void visitClassPropertyDeclaration(Node getProp) {
@@ -767,15 +810,17 @@ class GlobalTypeInfo implements CompilerPass {
       // TODO(blickly): Support @param, @return style fun declarations here.
       JSType declaredType = getTypeDeclarationFromJsdoc(
           NodeUtil.getBestJSDocInfo(getProp), currentScope);
-      if (declaredType != null) {
+      boolean isConstant = NodeUtil.hasConstAnnotation(getProp);
+      if (declaredType != null || isConstant) {
         mayWarnAboutExistingProp(rawNominalType, pname, getProp);
-      }
-      if (mayAddPropToType(getProp, rawNominalType)) {
-        if (declaredType != null) {
-          rawNominalType.addClassProperty(pname, declaredType);
-        } else {
-          rawNominalType.addUndeclaredClassProperty(pname);
+        // Intentionally, we keep going even if we warned for redeclared prop.
+        // The reason is that if a prop is defined on a class and on its proto
+        // with conflicting types, we prefer the type of the class.
+        if (mayAddPropToType(getProp, rawNominalType)) {
+          rawNominalType.addClassProperty(pname, declaredType, isConstant);
         }
+      } else if (mayAddPropToType(getProp, rawNominalType)) {
+        rawNominalType.addUndeclaredClassProperty(pname);
       }
       propertyDefs.put(rawNominalType.getId(), pname,
           new PropertyDef(getProp, null, null));
diff --git a/src/com/google/javascript/jscomp/NewTypeInference.java b/src/com/google/javascript/jscomp/NewTypeInference.java
index dea92804c..2bf9c7350 100644
--- a/src/com/google/javascript/jscomp/NewTypeInference.java
+++ b/src/com/google/javascript/jscomp/NewTypeInference.java
@@ -954,7 +954,7 @@ public class NewTypeInference implements CompilerPass {
                 analyzeExprFwd(prop.getFirstChild(), env, reqPtype, specPtype);
             if (jsdocType != null) {
               // First declare it; then set the maybe more precise inferred type
-              result = result.withDeclaredProperty(qname, jsdocType);
+              result = result.withDeclaredProperty(qname, jsdocType, false);
               if (!pair.type.isSubtypeOf(jsdocType)) {
                 warnings.add(JSError.make(
                     prop, NewTypeInference.INVALID_OBJLIT_PROPERTY_TYPE,
@@ -1069,9 +1069,23 @@ public class NewTypeInference implements CompilerPass {
         }
       }
       case Token.INC:
-      case Token.DEC:
+      case Token.DEC: {
         mayWarnAboutConst(expr);
+        Node ch = expr.getFirstChild();
+        if (ch.isGetProp() || ch.isGetElem() && ch.getLastChild().isString()) {
+          // We prefer to analyze the child of INC/DEC one extra time here,
+          // to putting the @const prop check in analyzePropAccessFwd.
+          Node recv = ch.getFirstChild();
+          String pname = ch.getLastChild().getString();
+          EnvTypePair pair = analyzeExprFwd(recv, inEnv);
+          JSType recvType = pair.type;
+          if (mayWarnAboutConstProp(ch, recvType, new QualifiedName(pname))) {
+            pair.type = requiredType;
+            return pair;
+          }
+        }
         // fall through
+      }
       case Token.BITNOT:
       case Token.POS:
       case Token.NEG: { // Unary operations on numbers
@@ -1847,6 +1861,17 @@ public class NewTypeInference implements CompilerPass {
     return false;
   }
 
+  private boolean mayWarnAboutConstProp(
+      Node propAccess, JSType recvType, QualifiedName pname) {
+    if (recvType.hasConstantProp(pname) &&
+        // Don't warn about the prop declaration itself.
+        !NodeUtil.hasConstAnnotation(propAccess.getParent())) {
+      warnings.add(JSError.make(propAccess, CONST_REASSIGNED));
+      return true;
+    }
+    return false;
+  }
+
   //////////////////////////////////////////////////////////////////////////////
 
   private EnvTypePair analyzePropAccessFwd(Node receiver, String pname,
@@ -2515,7 +2540,7 @@ public class NewTypeInference implements CompilerPass {
       }
       case Token.NAME: {
         String varName = expr.getString();
-        JSType varType = envGetType(inEnv, varName);
+        JSType varType = analyzeExprFwd(expr, inEnv).type;
         return new LValueResultFwd(inEnv, varType,
             currentScope.getDeclaredTypeOf(varName),
             varType.hasNonScalar() ? new QualifiedName(varName) : null);
@@ -2576,6 +2601,10 @@ public class NewTypeInference implements CompilerPass {
         mayWarnAboutPropCreation(pname, parent, lvalueType)) {
       return new LValueResultFwd(lvalue.env, type, null, null);
     }
+    if (!insideQualifiedName &&
+        mayWarnAboutConstProp(parent, lvalueType, pname)) {
+      return new LValueResultFwd(lvalue.env, type, null, null);
+    }
     // Warn for inexistent property either on the non-top-level of a qualified
     // name, or for assignment ops that won't create a new property.
     boolean warnForInexistentProp = insideQualifiedName ||
diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java
index dae20c80c..82f394567 100644
--- a/src/com/google/javascript/jscomp/NodeUtil.java
+++ b/src/com/google/javascript/jscomp/NodeUtil.java
@@ -2917,6 +2917,11 @@ public final class NodeUtil {
     return fnNode.getFirstChild().getNext();
   }
 
+  static boolean hasConstAnnotation(Node node) {
+    JSDocInfo jsdoc = getBestJSDocInfo(node);
+    return jsdoc != null && jsdoc.isConstant();
+  }
+
   static boolean isConstantVar(Node node, Scope scope) {
     if (isConstantName(node)) {
       return true;
diff --git a/src/com/google/javascript/jscomp/newtypes/JSType.java b/src/com/google/javascript/jscomp/newtypes/JSType.java
index 7f3d02c91..efcb1ea12 100644
--- a/src/com/google/javascript/jscomp/newtypes/JSType.java
+++ b/src/com/google/javascript/jscomp/newtypes/JSType.java
@@ -733,6 +733,19 @@ public class JSType {
     return true;
   }
 
+  public boolean hasConstantProp(QualifiedName pname) {
+    Preconditions.checkArgument(pname.isIdentifier());
+    if (objs == null) {
+      return false;
+    }
+    for (ObjectType obj : objs) {
+      if (obj.hasConstantProp(pname)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   public JSType getDeclaredProp(QualifiedName qname) {
     if (isUnknown()) {
       return UNKNOWN;
@@ -764,10 +777,15 @@ public class JSType {
         ObjectType.withProperty(this.objs, qname, type), typeVar);
   }
 
-  public JSType withDeclaredProperty(QualifiedName qname, JSType type) {
+  public JSType withDeclaredProperty(
+      QualifiedName qname, JSType type, boolean isConstant) {
     Preconditions.checkState(this.objs != null && this.location == null);
+    if (type == null && isConstant) {
+      type = JSType.UNKNOWN;
+    }
     return new JSType(this.mask, null,
-        ObjectType.withDeclaredProperty(this.objs, qname, type), typeVar);
+        ObjectType.withDeclaredProperty(this.objs, qname, type, isConstant),
+        typeVar);
   }
 
   public JSType withPropertyRequired(String pname) {
diff --git a/src/com/google/javascript/jscomp/newtypes/NominalType.java b/src/com/google/javascript/jscomp/newtypes/NominalType.java
index ed54139ec..cfa998066 100644
--- a/src/com/google/javascript/jscomp/newtypes/NominalType.java
+++ b/src/com/google/javascript/jscomp/newtypes/NominalType.java
@@ -148,7 +148,6 @@ public class NominalType {
     return result.build();
   }
 
-
   Property getProp(String pname) {
     Property p = rawType.getProp(pname);
     return p == null ? null : p.substituteGenerics(typeMap);
@@ -159,6 +158,11 @@ public class NominalType {
     return type == null ? null : type.substituteGenerics(typeMap);
   }
 
+  public boolean hasConstantProp(String pname) {
+    Property p = rawType.getProp(pname);
+    return p != null && p.isConstant();
+  }
+
   JSType createConstructorObject(FunctionType ctorFn) {
     Preconditions.checkState(typeMap.isEmpty());
     return rawType.createConstructorObject(ctorFn);
@@ -504,12 +508,17 @@ public class NominalType {
     //////////// Class Properties
 
     /** Add a new non-optional declared property to instances of this class */
-    public void addClassProperty(String pname, JSType type) {
+    public void addClassProperty(
+        String pname, JSType type, boolean isConstant) {
       Preconditions.checkState(!isFinalized);
-      classProps = classProps.with(pname, new Property(type, type, false));
+      if (type == null && isConstant) {
+        type = JSType.UNKNOWN;
+      }
+      classProps = classProps.with(pname, isConstant ?
+          Property.makeConstant(type, type) : Property.make(type, type));
       // Upgrade any proto props to declared, if present
       if (protoProps.containsKey(pname)) {
-        addProtoProperty(pname, type);
+        addProtoProperty(pname, type, isConstant);
       }
     }
 
@@ -520,20 +529,24 @@ public class NominalType {
       if (mayHaveProp(pname)) {
         return;
       }
-      classProps =
-          classProps.with(pname, new Property(JSType.UNKNOWN, null, false));
+      classProps = classProps.with(pname, Property.make(JSType.UNKNOWN, null));
     }
 
     //////////// Prototype Properties
 
     /** Add a new non-optional declared prototype property to this class */
-    public void addProtoProperty(String pname, JSType type) {
+    public void addProtoProperty(
+        String pname, JSType type, boolean isConstant) {
       Preconditions.checkState(!isFinalized);
+      if (type == null && isConstant) {
+        type = JSType.UNKNOWN;
+      }
       if (classProps.containsKey(pname) &&
           classProps.get(pname).getDeclaredType() == null) {
         classProps = classProps.without(pname);
       }
-      protoProps = protoProps.with(pname, new Property(type, type, false));
+      protoProps = protoProps.with(pname, isConstant ?
+          Property.makeConstant(type, type) : Property.make(type, type));
     }
 
     /** Add a new undeclared prototype property to this class */
@@ -542,7 +555,7 @@ public class NominalType {
       if (!protoProps.containsKey(pname) ||
           protoProps.get(pname).getDeclaredType() == null) {
         protoProps =
-            protoProps.with(pname, new Property(JSType.UNKNOWN, null, false));
+            protoProps.with(pname, Property.make(JSType.UNKNOWN, null));
       }
     }
 
@@ -565,9 +578,13 @@ public class NominalType {
     }
 
     /** Add a new non-optional declared property to this class's constructor */
-    public void addCtorProperty(String pname, JSType type) {
+    public void addCtorProperty(String pname, JSType type, boolean isConstant) {
       Preconditions.checkState(!isFinalized);
-      ctorProps = ctorProps.with(pname, new Property(type, type, false));
+      if (type == null && isConstant) {
+        type = JSType.UNKNOWN;
+      }
+      ctorProps = ctorProps.with(pname, isConstant ?
+          Property.makeConstant(type, type) : Property.make(type, type));
     }
 
     /** Add a new undeclared property to this class's constructor */
@@ -577,7 +594,7 @@ public class NominalType {
         return;
       }
       ctorProps =
-          ctorProps.with(pname, new Property(JSType.UNKNOWN, null, false));
+          ctorProps.with(pname, Property.make(JSType.UNKNOWN, null));
     }
 
     public JSType getCtorPropDeclaredType(String pname) {
@@ -616,7 +633,7 @@ public class NominalType {
       if (this.interfaces == null) {
         this.interfaces = ImmutableSet.of();
       }
-      addCtorProperty("prototype", createProtoObject());
+      addCtorProperty("prototype", createProtoObject(), false);
       this.isFinalized = true;
       return this;
     }
diff --git a/src/com/google/javascript/jscomp/newtypes/ObjectType.java b/src/com/google/javascript/jscomp/newtypes/ObjectType.java
index 658fcc39d..8d806576b 100644
--- a/src/com/google/javascript/jscomp/newtypes/ObjectType.java
+++ b/src/com/google/javascript/jscomp/newtypes/ObjectType.java
@@ -88,7 +88,7 @@ public class ObjectType {
     for (Map.Entry<String, JSType> propTypeEntry : propTypes.entrySet()) {
       String propName = propTypeEntry.getKey();
       JSType propType = propTypeEntry.getValue();
-      props = props.with(propName, new Property(propType, propType, false));
+      props = props.with(propName, Property.make(propType, propType));
     }
     return ObjectType.makeObjectType(
         null, props, null, false, ObjectKind.UNRESTRICTED);
@@ -169,12 +169,14 @@ public class ObjectType {
 
   // If the property is already declared, but isDeclared is false, be careful
   // to not un-declare it.
-  private ObjectType withPropertyHelper(
-      QualifiedName qname, JSType type, boolean isDeclared) {
+  // If the property is already constant, but isConstant is false, be careful
+  // to not un-const it.
+  private ObjectType withPropertyHelper(QualifiedName qname, JSType type,
+      boolean isDeclared, boolean isConstant) {
     // TODO(blickly): If the prop exists with right type, short circuit here.
     PersistentMap<String, Property> newProps = this.props;
-    String objName = qname.getLeftmostName();
     if (qname.isIdentifier()) {
+      String pname = qname.getLeftmostName();
       JSType declType = getDeclaredProp(qname);
       Preconditions.checkState(declType == null || type == null ||
           type.isSubtypeOf(declType),
@@ -183,18 +185,24 @@ public class ObjectType {
       if (type == null) {
         type = declType;
       }
-      if (isDeclared) {
-        declType = type;
-      } else if (declType != null) {
+      if (declType != null) {
         isDeclared = true;
+        if (hasConstantProp(qname)) {
+          isConstant = true;
+        }
+      } else if (isDeclared) {
+        declType = type;
       }
       if (type == null && declType == null) {
-        newProps = newProps.without(objName);
+        newProps = newProps.without(pname);
       } else {
-        newProps = newProps.with(objName,
-            new Property(type, isDeclared ? declType : null, false));
+        newProps = newProps.with(pname,
+            isConstant ?
+            Property.makeConstant(type, declType) :
+            Property.make(type, isDeclared ? declType : null));
       }
     } else { // This has a nested object
+      String objName = qname.getLeftmostName();
       QualifiedName objQname = new QualifiedName(objName);
       if (!mayHaveProp(objQname)) {
         Preconditions.checkState(type == null);
@@ -202,16 +210,18 @@ public class ObjectType {
       }
       QualifiedName innerProps = qname.getAllButLeftmost();
       Property objProp = getLeftmostProp(objQname);
-      newProps = newProps.with(objName,
-          new Property(objProp.getType().withProperty(innerProps, type),
-            objProp.getDeclaredType(), objProp.isOptional()));
+      JSType inferred = objProp.getType().withProperty(innerProps, type);
+      JSType declared = objProp.getDeclaredType();
+      newProps = newProps.with(objName, objProp.isOptional() ?
+          Property.makeOptional(inferred, declared) :
+          Property.make(inferred, declared));
     }
     return ObjectType.makeObjectType(
         nominalType, newProps, fn, isLoose, objectKind);
   }
 
   ObjectType withProperty(QualifiedName qname, JSType type) {
-    return withPropertyHelper(qname, type, false);
+    return withPropertyHelper(qname, type, false, false);
   }
 
   static ImmutableSet<ObjectType> withProperty(
@@ -223,11 +233,11 @@ public class ObjectType {
     return newObjs.build();
   }
 
-  static ImmutableSet<ObjectType> withDeclaredProperty(
-      Set<ObjectType> objs, QualifiedName qname, JSType type) {
+  static ImmutableSet<ObjectType> withDeclaredProperty(Set<ObjectType> objs,
+      QualifiedName qname, JSType type, boolean isConstant) {
     ImmutableSet.Builder<ObjectType> newObjs = ImmutableSet.builder();
     for (ObjectType obj : objs) {
-      newObjs.add(obj.withPropertyHelper(qname, type, true));
+      newObjs.add(obj.withPropertyHelper(qname, type, true, isConstant));
     }
     return newObjs.build();
   }
@@ -235,8 +245,8 @@ public class ObjectType {
   private ObjectType withPropertyRequired(String pname) {
     Property oldProp = this.props.get(pname);
     Property newProp = oldProp == null ?
-        new Property(JSType.UNKNOWN, null, false) :
-        new Property(oldProp.getType(), oldProp.getDeclaredType(), false);
+        Property.make(JSType.UNKNOWN, null) :
+        Property.make(oldProp.getType(), oldProp.getDeclaredType());
     return ObjectType.makeObjectType(
         nominalType, this.props.with(pname, newProp), fn,
         isLoose, this.objectKind);
@@ -252,8 +262,7 @@ public class ObjectType {
   }
 
   private static PersistentMap<String, Property> meetPropsHelper(
-      boolean specializeProps1,
-      NominalType resultNominalType,
+      boolean specializeProps1, NominalType resultNominalType,
       Map<String, Property> props1, Map<String, Property> props2) {
     PersistentMap<String, Property> newProps = PersistentMap.create();
     for (Map.Entry<String, Property> propsEntry : props1.entrySet()) {
@@ -280,14 +289,21 @@ public class ObjectType {
   }
 
   private static PersistentMap<String, Property> mayPutProp(
-      String pname, Property prop,
-      PersistentMap<String, Property> props,
+      String pname, Property prop, PersistentMap<String, Property> props,
       NominalType nom) {
-    Property nomProp = nom == null ? null : nom.getProp(pname);
+    if (nom == null) {
+      return props.with(pname, prop);
+    }
+    Property nomProp = nom.getProp(pname);
+    if (nomProp == null) {
+      return props.with(pname, prop);
+    }
     JSType propType = prop.getType();
-    if (nomProp == null ||
-        (!propType.isUnknown() && propType.isSubtypeOf(nomProp.getType()))) {
-      props = props.with(pname, prop);
+    JSType nomPropType = nomProp.getType();
+    if (!propType.isUnknown() &&
+        propType.isSubtypeOf(nomPropType) && !propType.equals(nomPropType)) {
+      // We use specialize so that if nomProp is @const, we don't forget it.
+      return props.with(pname, nomProp.specialize(prop));
     }
     return props;
   }
@@ -305,7 +321,8 @@ public class ObjectType {
       String pname = propsEntry.getKey();
       Property prop2 = propsEntry.getValue();
       if (props1.containsKey(pname)) {
-        newProps = newProps.with(pname, Property.join(props1.get(pname), prop2));
+        newProps = newProps.with(
+            pname, Property.join(props1.get(pname), prop2));
       } else {
         newProps = newProps.with(pname, prop2.withOptional());
       }
@@ -600,7 +617,7 @@ public class ObjectType {
   }
 
   boolean hasProp(QualifiedName qname) {
-    Preconditions.checkState(qname.isIdentifier());
+    Preconditions.checkArgument(qname.isIdentifier());
     Property p = getLeftmostProp(qname);
     if (p == null || p.isOptional()) {
       return false;
@@ -609,6 +626,12 @@ public class ObjectType {
     }
   }
 
+  boolean hasConstantProp(QualifiedName qname) {
+    Preconditions.checkArgument(qname.isIdentifier());
+    Property p = getLeftmostProp(qname);
+    return p != null && p.isConstant();
+  }
+
   JSType getDeclaredProp(QualifiedName qname) {
     Property p = getLeftmostProp(qname);
     if (p == null) {
diff --git a/src/com/google/javascript/jscomp/newtypes/Property.java b/src/com/google/javascript/jscomp/newtypes/Property.java
index 580081787..a77bc1cc7 100644
--- a/src/com/google/javascript/jscomp/newtypes/Property.java
+++ b/src/com/google/javascript/jscomp/newtypes/Property.java
@@ -31,17 +31,40 @@ import java.util.Map;
 class Property {
   private final JSType inferredType;
   private final JSType declaredType;
-  private boolean isOptional;
+  // Attributes are ordered: constant <= required <= optional
+  private enum Attribute {
+    CONSTANT, // For required props only
+    OPTIONAL,
+    REQUIRED;
+  }
+  private Attribute attribute;
 
-  Property(JSType inferredType, JSType declaredType, boolean isOptional) {
+  private Property(
+      JSType inferredType, JSType declaredType, Attribute attribute) {
     Preconditions.checkArgument(inferredType != null);
     this.inferredType = inferredType;
     this.declaredType = declaredType;
-    this.isOptional = isOptional;
+    this.attribute = attribute;
+  }
+
+  static Property make(JSType inferredType, JSType declaredType) {
+    return new Property(inferredType, declaredType, Attribute.REQUIRED);
+  }
+
+  static Property makeConstant(JSType inferredType, JSType declaredType) {
+    return new Property(inferredType, declaredType, Attribute.CONSTANT);
+  }
+
+  static Property makeOptional(JSType inferredType, JSType declaredType) {
+    return new Property(inferredType, declaredType, Attribute.OPTIONAL);
   }
 
   boolean isOptional() {
-    return isOptional;
+    return attribute == Attribute.OPTIONAL;
+  }
+
+  boolean isConstant() {
+    return attribute == Attribute.CONSTANT;
   }
 
   boolean isDeclared() {
@@ -61,29 +84,49 @@ class Property {
         inferredType.withLocation(JSType.GENERIC_LOCATION),
         declaredType == null ? null :
         declaredType.withLocation(JSType.GENERIC_LOCATION),
-        isOptional);
+        attribute);
   }
 
   Property withOptional() {
-    return new Property(inferredType, declaredType, true);
+    return new Property(inferredType, declaredType, Attribute.OPTIONAL);
   }
 
   Property withRequired() {
-    return new Property(inferredType, declaredType, false);
+    return new Property(inferredType, declaredType, Attribute.REQUIRED);
+  }
+
+  private static Attribute meetAttributes(Attribute a1, Attribute a2) {
+    if (a1 == Attribute.CONSTANT || a2 == Attribute.CONSTANT) {
+      return Attribute.CONSTANT;
+    }
+    if (a1 == Attribute.REQUIRED || a2 == Attribute.REQUIRED) {
+      return Attribute.REQUIRED;
+    }
+    return Attribute.OPTIONAL;
+  }
+
+  private static Attribute joinAttributes(Attribute a1, Attribute a2) {
+    if (a1 == Attribute.OPTIONAL || a2 == Attribute.OPTIONAL) {
+      return Attribute.OPTIONAL;
+    }
+    if (a1 == Attribute.REQUIRED || a2 == Attribute.REQUIRED) {
+      return Attribute.REQUIRED;
+    }
+    return Attribute.CONSTANT;
   }
 
   Property specialize(Property other) {
     return new Property(
         this.inferredType.specialize(other.inferredType),
         this.declaredType,
-        this.isOptional && other.isOptional);
+        meetAttributes(this.attribute, other.attribute));
   }
 
   static Property meet(Property p1, Property p2) {
     return new Property(
         JSType.meet(p1.inferredType, p2.inferredType),
         null,
-        p1.isOptional && p2.isOptional);
+        meetAttributes(p1.attribute, p2.attribute));
   }
 
   static Property join(Property p1, Property p2) {
@@ -98,7 +141,7 @@ class Property {
     return new Property(
         JSType.join(p1.inferredType, p2.inferredType),
         declType,
-        p1.isOptional || p2.isOptional);
+        joinAttributes(p1.attribute, p2.attribute));
   }
 
   /**
@@ -122,7 +165,7 @@ class Property {
     }
     return new Property(
         unifiedInferredType, unifiedDeclaredType,
-        p1.isOptional && p2.isOptional);
+        meetAttributes(p1.attribute, p2.attribute));
   }
 
   /** Returns whether unification succeeded */
@@ -146,23 +189,38 @@ class Property {
         inferredType.substituteGenerics(concreteTypes),
         declaredType == null ?
         null : declaredType.substituteGenerics(concreteTypes),
-        isOptional);
+        attribute);
   }
 
   @Override
   public String toString() {
-    return inferredType.toString() + (isOptional ? "=" : "");
+    String attr;
+    switch (attribute) {
+      case CONSTANT:
+        attr = "^";
+        break;
+      case REQUIRED:
+        attr = "";
+        break;
+      case OPTIONAL:
+        attr = "=";
+        break;
+      default:
+        throw new RuntimeException("Uknown Attribute value " + attribute);
+    }
+    return inferredType + attr;
   }
 
   @Override
   public boolean equals(Object o) {
     Preconditions.checkArgument(o instanceof Property);
     Property p2 = (Property) o;
-    return inferredType.equals(p2.inferredType) && isOptional == p2.isOptional;
+    return inferredType.equals(p2.inferredType) &&
+        attribute == p2.attribute;
   }
 
   @Override
   public int hashCode() {
-    return Objects.hashCode(inferredType, isOptional);
+    return Objects.hashCode(inferredType, attribute);
   }
 }
diff --git a/test/com/google/javascript/jscomp/NewTypeInferenceTest.java b/test/com/google/javascript/jscomp/NewTypeInferenceTest.java
index 160e549c6..22dc9aab0 100644
--- a/test/com/google/javascript/jscomp/NewTypeInferenceTest.java
+++ b/test/com/google/javascript/jscomp/NewTypeInferenceTest.java
@@ -279,7 +279,8 @@ public class NewTypeInferenceTest extends CompilerTypeTestCase {
 
     typeCheck("var /** null */ obj = 5;", NewTypeInference.MISTYPED_ASSIGN_RHS);
 
-    typeCheck("var /** ?number */ n = true;", NewTypeInference.MISTYPED_ASSIGN_RHS);
+    typeCheck("var /** ?number */ n = true;",
+        NewTypeInference.MISTYPED_ASSIGN_RHS);
   }
 
   public void testEmptyBlockPropagation() {
@@ -906,7 +907,7 @@ public class NewTypeInferenceTest extends CompilerTypeTestCase {
     typeCheck(
         "/** @constructor */ function Foo() {}\n" +
         "/** @constructor */ function Bar() {}\n" +
-        "function fun(cond, /** Foo */ f, /** Bar */ g) {\n" +
+        "function fun(cond, /** !Foo */ f, /** !Bar */ g) {\n" +
         "  (cond ? f : g)();\n" +
         "}",
         TypeCheck.NOT_CALLABLE);
@@ -2269,6 +2270,10 @@ public class NewTypeInferenceTest extends CompilerTypeTestCase {
     checkNoWarnings(
         "function f() {}\n" +
         "function g() { f.prototype.prop = 123; }");
+
+    checkNoWarnings(
+        "/** @param {!Function} f */" +
+        "function foo(f) { f.prototype.bar = function(x) {}; }");
   }
 
   public void testAssignmentsToPrototype() {
@@ -3224,6 +3229,25 @@ public class NewTypeInferenceTest extends CompilerTypeTestCase {
         NewTypeInference.INVALID_ARGUMENT_TYPE);
   }
 
+  public void testInterfaceMultipleInheritanceNoCrash() {
+    checkNoWarnings(
+        "/** @interface */\n" +
+        "function I1() {}\n" +
+        "I1.prototype.method = function(x) {};\n" +
+        "/** @interface */\n" +
+        "function I2() {}\n" +
+        "I2.prototype.method = function(x) {};\n" +
+        "/**\n" +
+        " * @interface\n" +
+        " * @extends {I1}\n" +
+        " * @extends {I2}\n" +
+        " */\n" +
+        "function I3() {}\n" +
+        "/** @constructor @implements {I3} */\n" +
+        "function Foo() {}\n" +
+        "Foo.prototype.method = function(x) {};");
+  }
+
   public void testInterfaceArgument() {
     typeCheck(
         "/** @interface */\n" +
@@ -5819,6 +5843,12 @@ public class NewTypeInferenceTest extends CompilerTypeTestCase {
         VarCheck.UNDEFINED_VAR_ERROR);
   }
 
+  public void testGlobalVariableInAssign() {
+    typeCheck(
+        "u.prop = 123;",
+        VarCheck.UNDEFINED_VAR_ERROR);
+  }
+
   public void testGetters() {
     typeCheck(
         "var x = { /** @return {string} */ get a() { return 1; } };",
@@ -5972,4 +6002,167 @@ public class NewTypeInferenceTest extends CompilerTypeTestCase {
         "/** @const */ var x;", "x = 2;",
         NewTypeInference.CONST_REASSIGNED);
   }
+
+  public void testMisplacedConstPropertyAnnotation() {
+    typeCheck(
+        "function f(obj) { /** @const */ obj.prop = 123; }",
+        GlobalTypeInfo.MISPLACED_CONST_ANNOTATION);
+
+    typeCheck(
+        "function f(obj) { /** @const */ obj.prop; }",
+        GlobalTypeInfo.MISPLACED_CONST_ANNOTATION);
+
+    typeCheck(
+        "var obj = { /** @const */ prop: 1 };",
+        GlobalTypeInfo.MISPLACED_CONST_ANNOTATION);
+
+    typeCheck(
+        "/** @constructor */ function Foo() {}\n" +
+        "Foo.prototype.method = function() {\n" +
+        "  /** @const */ this.prop = 1;\n" +
+        "}",
+        GlobalTypeInfo.MISPLACED_CONST_ANNOTATION);
+  }
+
+  public void testConstPropertiesDontAssign() {
+    typeCheck(
+        "/** @constructor */\n" +
+        "function Foo() {\n" +
+        "  /** @const */ this.prop = 1;\n" +
+        "}\n" +
+        "var obj = new Foo;\n" +
+        "obj.prop = 2;",
+        NewTypeInference.CONST_REASSIGNED);
+
+    typeCheck(
+        "/** @constructor */\n" +
+        "function Foo() {\n" +
+        "  /** @const {number} */\n" +
+        "  this.prop = 1;\n" +
+        "}\n" +
+        "var obj = new Foo;\n" +
+        "obj.prop = 2;",
+        NewTypeInference.CONST_REASSIGNED);
+
+    typeCheck(
+        "/** @constructor */\n" +
+        "function Foo() {\n" +
+        "  /** @const */ this.prop = 1;\n" +
+        "}\n" +
+        "var obj = new Foo;\n" +
+        "obj.prop += 2;",
+        NewTypeInference.CONST_REASSIGNED);
+
+    typeCheck(
+        "/** @constructor */\n" +
+        "function Foo() {\n" +
+        "  /** @const */ this.prop = 1;\n" +
+        "}\n" +
+        "var obj = new Foo;\n" +
+        "obj.prop++;",
+        NewTypeInference.CONST_REASSIGNED);
+
+    typeCheck(
+        "/** @const */\n" +
+        "var ns = {};\n" +
+        "/** @const */\n" +
+        "ns.prop = 1;\n" +
+        "ns.prop = 2;",
+        NewTypeInference.CONST_REASSIGNED);
+
+    typeCheck(
+        "/** @const */\n" +
+        "var ns = {};\n" +
+        "/** @const */\n" +
+        "ns.prop = 1;\n" +
+        "function f() { ns.prop = 2; }",
+        NewTypeInference.CONST_REASSIGNED);
+
+    typeCheck(
+        "/** @const */\n" +
+        "var ns = {};\n" +
+        "/** @const {number} */\n" +
+        "ns.prop = 1;\n" +
+        "ns.prop = 2;",
+        NewTypeInference.CONST_REASSIGNED);
+
+    typeCheck(
+        "/** @const */\n" +
+        "var ns = {};\n" +
+        "/** @const */\n" +
+        "ns.prop = 1;\n" +
+        "ns.prop++;",
+        NewTypeInference.CONST_REASSIGNED);
+
+    typeCheck(
+        "/** @constructor */ function Foo() {}\n" +
+        "/** @const */ Foo.prop = 1;\n" +
+        "Foo.prop = 2;",
+        NewTypeInference.CONST_REASSIGNED);
+
+    typeCheck(
+        "/** @constructor */ function Foo() {}\n" +
+        "/** @const {number} */ Foo.prop = 1;\n" +
+        "Foo.prop++;",
+        NewTypeInference.CONST_REASSIGNED);
+
+    typeCheck(
+        "/** @constructor */ function Foo() {}\n" +
+        "/** @const */ Foo.prototype.prop = 1;\n" +
+        "Foo.prototype.prop = 2;",
+        NewTypeInference.CONST_REASSIGNED);
+
+    typeCheck(
+        "/** @constructor */ function Foo() {}\n" +
+        "/** @const */ Foo.prototype.prop = 1;\n" +
+        "var protoAlias = Foo.prototype;\n" +
+        "protoAlias.prop = 2;",
+        NewTypeInference.CONST_REASSIGNED);
+
+    typeCheck(
+        "/** @constructor */\n" +
+        "function Foo() { /** @const */ this.X = 4; }\n" +
+        "/** @constructor */\n" +
+        "function Bar() { /** @const */ this.X = 5; }\n" +
+        "var fb = true ? new Foo : new Bar;\n" +
+        "fb.X++;",
+        NewTypeInference.CONST_REASSIGNED);
+  }
+
+  public void testDontOverrideFinalMethods() {
+    typeCheck(
+        "/** @constructor */\n" +
+        "function Foo() {}\n" +
+        "/** @final */\n" +
+        "Foo.prototype.method = function(x) {};\n" +
+        "/** @constructor @extends {Foo} */\n" +
+        "function Bar() {}\n" +
+        "Bar.prototype.method = function(x) {};",
+        GlobalTypeInfo.CANNOT_OVERRIDE_FINAL_METHOD);
+
+    checkNoWarnings(
+        "/** @constructor */\n" +
+        "function Foo() {}\n" +
+        "/** @final */\n" +
+        "Foo.prototype.num = 123;\n" +
+        "/** @constructor @extends {Foo} */\n" +
+        "function Bar() {}\n" +
+        "Bar.prototype.num = 2;");
+
+    // // TODO(dimvar): fix
+    // typeCheck(
+    //     "/** @constructor */\n" +
+    //     "function High() {}\n" +
+    //     "/**\n" +
+    //     " * @param {number} x\n" +
+    //     " * @final\n" +
+    //     " */\n" +
+    //     "High.prototype.method = function(x) {};\n" +
+    //     "/** @constructor @extends {High} */\n" +
+    //     "function Mid() {}\n" +
+    //     "/** @constructor @extends {Mid} */\n" +
+    //     "function Low() {}\n" +
+    //     "Low.prototype.method = function(x) {};",
+    //     GlobalTypeInfo.CANNOT_OVERRIDE_FINAL_METHOD);
+  }
 }
