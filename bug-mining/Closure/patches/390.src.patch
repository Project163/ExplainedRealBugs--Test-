diff --git a/src/com/google/javascript/jscomp/CheckUnusedPrivateProperties.java b/src/com/google/javascript/jscomp/CheckUnusedPrivateProperties.java
new file mode 100644
index 000000000..3af22ccdc
--- /dev/null
+++ b/src/com/google/javascript/jscomp/CheckUnusedPrivateProperties.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2015 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import com.google.common.base.Preconditions;
+import com.google.javascript.rhino.JSDocInfo;
+import com.google.javascript.rhino.JSDocInfo.Visibility;
+import com.google.javascript.rhino.Node;
+import com.google.javascript.rhino.Token;
+import com.google.javascript.rhino.TypeI;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * This pass looks for properties that are never read.
+ * These can be properties created using "this", or static properties of
+ * constructors or interfaces. Explicitly ignored is the possibility that
+ * these properties may be indirectly referenced using "for-in" or
+ * "Object.keys".
+ *
+ * @author johnlenz@google.com (John Lenz)
+ */
+class CheckUnusedPrivateProperties
+    implements HotSwapCompilerPass, NodeTraversal.Callback {
+
+  static final DiagnosticType UNUSED_PRIVATE_PROPERTY =
+      DiagnosticType.disabled(
+          "JSC_UNUSED_PRIVATE_PROPERTY", "Private property {0} is never read");
+
+  private final AbstractCompiler compiler;
+  private Set<String> used = new HashSet<>();
+  private List<Node> candidates = new ArrayList<>();
+
+  CheckUnusedPrivateProperties(AbstractCompiler compiler) {
+    this.compiler = compiler;
+  }
+
+  @Override
+  public void process(Node externs, Node root) {
+    NodeTraversal.traverseEs6(compiler, root, this);
+  }
+
+  @Override
+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {
+    NodeTraversal.traverseEs6(compiler, scriptRoot, this);
+  }
+
+  private void reportUnused(NodeTraversal t) {
+    for (Node n : candidates) {
+      String propName = getPropName(n);
+      if (!used.contains(propName)) {
+        t.report(n, UNUSED_PRIVATE_PROPERTY);
+      }
+    }
+  }
+
+  private String getPropName(Node n) {
+    switch (n.getType()) {
+      case Token.GETPROP:
+        return n.getLastChild().getString();
+      case Token.MEMBER_FUNCTION_DEF:
+        return n.getString();
+    }
+    throw new RuntimeException("Unexpected node type: " + n);
+  }
+
+  @Override
+  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
+    if (n.isScript()) {
+      used.clear();
+      candidates.clear();
+    }
+    return true;
+  }
+
+  @Override
+  public void visit(NodeTraversal t, Node n, Node parent) {
+     switch (n.getType()) {
+       case Token.SCRIPT: {
+         // exiting the script, report any privates not used in the file.
+         reportUnused(t);
+         break;
+       }
+
+       case Token.GETPROP: {
+         String propName = n.getLastChild().getString();
+         if (compiler.getCodingConvention().isExported(propName)
+             || isPinningPropertyUse(n)
+             || !isCandidatePropertyDefinition(n)) {
+           used.add(propName);
+         } else {
+           // Only consider "private" properties.
+           if (isPrivatePropDecl(n)) {
+             candidates.add(n);
+           }
+         }
+         break;
+       }
+
+       case Token.MEMBER_FUNCTION_DEF: {
+         // Only consider "private" methods.
+         if (isPrivatePropDecl(n)) {
+           candidates.add(n);
+         }
+         break;
+       }
+
+       case Token.OBJECTLIT: {
+         // Assume any object literal definition might be a reflection on the
+         // class property.
+         for (Node c : n.children()) {
+           used.add(c.getString());
+         }
+         break;
+       }
+
+       case Token.CALL:
+         // Look for properties referenced through "JSCompiler_propertyRename".
+         Node target = n.getFirstChild();
+         if (n.hasMoreThanOneChild()
+             && target.isName()
+             && target.getString().equals(NodeUtil.JSC_PROPERTY_NAME_FN)) {
+           Node propName = target.getNext();
+           if (propName.isString()) {
+             used.add(propName.getString());
+           }
+         }
+         break;
+     }
+  }
+
+  private boolean isPrivatePropDecl(Node n) {
+    // TODO(johnlenz): add support private by convention property definitions without JSDoc.
+    // TODO(johnlenz): add support for checking protected properties in final classes
+    // TODO(johnlenz): add support for checking "package" properties when checking an entire
+    // library.
+    JSDocInfo info = NodeUtil.getBestJSDocInfo(n);
+    return (info != null && info.getVisibility() == Visibility.PRIVATE);
+  }
+
+  private boolean isCandidatePropertyDefinition(Node n) {
+    Preconditions.checkState(n.isGetProp());
+    Node target = n.getFirstChild();
+    return target.isThis()
+        || (isConstructor(target))
+        || (target.isGetProp()
+            && target.getLastChild().getString().equals("prototype"));
+  }
+
+  private boolean isConstructor(Node n) {
+    // If type checking is enabled (not just a per-file lint check),
+    // we can check constructor properties too. But it isn't required.
+    TypeI type = n.getTypeI();
+    return type != null && (type.isConstructor() || type.isInterface());
+  }
+
+  /**
+   * @return Whether the property is used in a way that prevents its removal.
+   */
+  private static boolean isPinningPropertyUse(Node n) {
+    // Rather than looking for cases that are uses, we assume all references are
+    // pinning uses unless they are:
+    //  - a simple assignment (x.a = 1)
+    //  - a compound assignment or increment (x++, x += 1) whose result is
+    //    otherwise unused
+
+    Node parent = n.getParent();
+    if (n == parent.getFirstChild()) {
+      if (parent.isExprResult()) {
+        // A stub declaration "this.x;" isn't a pinning use.
+        return false;
+      } else if (parent.isAssign()) {
+        // A simple assignment doesn't pin the property.
+        return false;
+      } else if (NodeUtil.isAssignmentOp(parent)
+            || parent.isInc() || parent.isDec()) {
+        // In general, compound assignments are both reads and writes, but
+        // if the property is never otherwise read we can consider it simply
+        // a write.
+        // However if the assign expression is used as part of a larger
+        // expression, we much consider it a read. For example:
+        //    x = (y.a += 1);
+        return NodeUtil.isExpressionResultUsed(parent);
+      }
+    }
+    return true;
+  }
+}
diff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java
index 5da483859..439e50dab 100644
--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java
+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java
@@ -1574,6 +1574,7 @@ public final class DefaultPassConfig extends PassConfig {
           .add(new CheckNullableReturn(compiler))
           .add(new CheckForInOverArray(compiler))
           .add(new CheckPrototypeProperties(compiler))
+          .add(new CheckUnusedPrivateProperties(compiler))
           .add(new ImplicitNullabilityCheck(compiler));
       return combineChecks(compiler, callbacks.build());
     }
diff --git a/src/com/google/javascript/jscomp/DiagnosticGroups.java b/src/com/google/javascript/jscomp/DiagnosticGroups.java
index 30a62ec92..973d9cd00 100644
--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java
+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java
@@ -449,6 +449,7 @@ public class DiagnosticGroups {
           CheckRequiresAndProvidesSorted.PROVIDES_AFTER_REQUIRES,
           CheckRequiresAndProvidesSorted.MULTIPLE_MODULES_IN_FILE,
           CheckRequiresAndProvidesSorted.MODULE_AND_PROVIDES,
+          CheckUnusedPrivateProperties.UNUSED_PRIVATE_PROPERTY,
           ImplicitNullabilityCheck.IMPLICITLY_NULLABLE_JSDOC,
           RhinoErrorReporter.JSDOC_MISSING_BRACES_WARNING,
           RhinoErrorReporter.JSDOC_MISSING_TYPE_WARNING,
diff --git a/test/com/google/javascript/jscomp/CheckUnusedPrivatePropertiesTest.java b/test/com/google/javascript/jscomp/CheckUnusedPrivatePropertiesTest.java
new file mode 100644
index 000000000..10a94782c
--- /dev/null
+++ b/test/com/google/javascript/jscomp/CheckUnusedPrivatePropertiesTest.java
@@ -0,0 +1,239 @@
+/*
+ * Copyright 2015 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
+
+/**
+ * @author johnlenz@google.com (John Lenz)
+ */
+public final class CheckUnusedPrivatePropertiesTest extends CompilerTestCase {
+
+  private static final String EXTERNS = LINE_JOINER.join(
+      "var window;",
+      "function alert(a) {}",
+      "var EXT = {};",
+      "EXT.ext;");
+
+  public CheckUnusedPrivatePropertiesTest() {
+    super(EXTERNS);
+    enableGatherExternProperties();
+    setAcceptedLanguage(LanguageMode.ECMASCRIPT6);
+  }
+
+  @Override
+  protected CompilerPass getProcessor(Compiler compiler) {
+    return new CheckUnusedPrivateProperties(compiler);
+  }
+
+  @Override
+  public CompilerOptions getOptions() {
+    CompilerOptions options = super.getOptions();
+    options.setWarningLevel(DiagnosticGroups.LINT_CHECKS, CheckLevel.WARNING);
+    options.setWarningLevel(DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.OFF);
+    return options;
+  }
+
+  @Override
+  protected void setUp() {
+    this.enableTypeCheck(CheckLevel.OFF);
+  }
+
+  private void unused(String code) {
+    testSame(code, CheckUnusedPrivateProperties.UNUSED_PRIVATE_PROPERTY);
+  }
+
+  private void used(String code) {
+    testSame(code);
+  }
+
+  public void testSimpleUnused1() {
+    unused("/** @private */ this.a = 2");
+    used("/** @private */ this.a = 2; alert(this.a);");
+  }
+
+  public void testConstructorPropertyUsed1() {
+    unused("/** @constructor */ function C() {} /** @private */ C.prop = 1;");
+    used("/** @constructor */ function C() {} /** @private */ C.prop = 1; alert(C.prop);");
+    used("/** @constructor */ function C() {} /** @private */ C.prop = 1; function f(a) {a.prop}");
+  }
+
+  public void testClassPropUnused1() {
+    this.disableTypeCheck();
+
+    // A property defined on "this" can be removed
+    unused("class C { constructor() { /** @private */ this.a = 2 } }");
+  }
+
+  public void testClassPropUnused2() {
+    unused("/** @constructor */ function C() { /** @private */ this.prop = 1; }");
+    used("/** @constructor */ function C() {/** @private */ this.prop = 1;} alert(some.prop);");
+  }
+
+  public void testClassMethodUnused1() {
+    this.disableTypeCheck();
+
+    unused("class C { constructor() {}  /** @private */ method() {} }");
+    used("class C { constructor() {}  /** @private */ method() {} }\n new C().method();");
+  }
+
+  // The JSDoc seems to be missing here, reenable this test when it is fixed.
+  public void disable_testClassMethodUnused2() {
+    this.disableTypeCheck();
+
+    unused("class C { constructor() {}\n  /** @private */ ['method']() {} }");
+    used("class C { constructor() {}\n  /** @private */ ['method']() {} }\n new C()['method']();");
+  }
+
+  public void testSimple2() {
+    // A property defined on "this" can be removed, even when defined
+    // as part of an expression
+    unused("/** @private */ this.a = 1; this.a = 2, f()");
+    unused("/** @private */ this.a = 1; x = (this.a = 2, f())");
+    unused("/** @private */ this.a = 1; x = (f(), this.a = 2)");
+  }
+
+  public void testSimple3() {
+    // A property defined on an object other than "this" can not be removed.
+    used("y.a = 2");
+    // and is seen as a use.
+    used("y.a = 2; /** @private */ this.a = 2");
+    // Some use of the property "a" appears as a use.
+    used("y.a = 2; /** @private */ this.a = 1; alert(x.a)");
+  }
+
+  public void testObjLit() {
+    // A property defined on an object other than "this" is considered a use.
+    used("({a:2})");
+    // and is seen as a use on 'this'.
+    used("({a:0}); /** @private */ this.a = 1;");
+    // Some use of the property "a" anywhere is considered a use
+    used("x = ({a:0}); /** @private */ this.a = 1; alert(x.a)");
+  }
+
+  public void testExtern() {
+    // A property defined in the externs and isn't a warning.
+    testSame("this.ext = 2");
+  }
+
+  public void testExport() {
+    // An exported property can not be removed.
+    testSame("this.ext = 2; window['export'] = this.ext;");
+    testSame("function f() { this.ext = 2; } window['export'] = this.ext;");
+  }
+
+
+  public void testAssignOp1() {
+    // Properties defined using a compound assignment can be removed if the
+    // result of the assignment expression is not immediately used.
+    unused("/** @private */ this.x; this.x += 2");
+    used("/** @private */ this.x; x = (this.x += 2)");
+    used("/** @private */ this.x; this.x += 2; x = this.x;");
+    // But, of course, a later use prevents its removal.
+    used("/** @private */ this.x; this.x += 2; x.x;");
+  }
+
+  public void testAssignOp2() {
+    // Properties defined using a compound assignment can be removed if the
+    // result of the assignment expression is not immediately used.
+    unused("/** @private */ this.a; this.a += 2, f()");
+    unused("/** @private */ this.a; x = (this.a += 2, f())");
+    used("/** @private */ this.a; x = (f(), this.a += 2)");
+  }
+
+  public void testInc1() {
+    // Increments and Decrements are handled similarly to compound assignments
+    // but need a placeholder value when replaced.
+    unused("/** @private */ this.x; this.x++");
+    used("/** @private */ this.x; x = (this.x++)");
+    used("/** @private */ this.x; this.x++; x = this.x;");
+
+    unused("/** @private */ this.x; --this.x");
+    used("/** @private */ this.x; x = (--this.x)");
+    used("/** @private */ this.x; --this.x; x = this.x;");
+  }
+
+  public void testInc2() {
+    // Increments and Decrements are handled similarly to compound assignments
+    unused("/** @private */ this.a; this.a++, f()");
+    unused("/** @private */ this.a;x = (this.a++, f())");
+    used("/** @private */ this.a;x = (f(), this.a++)");
+
+    unused("/** @private */ this.a; --this.a, f()");
+    unused("/** @private */ this.a; x = (--this.a, f())");
+    used("/** @private */ this.a; x = (f(), --this.a)");
+  }
+
+  public void testJSCompiler_renameProperty() {
+    // JSCompiler_renameProperty introduces a use of the property
+    used("/** @private */ this.a = 2; x[JSCompiler_renameProperty('a')]");
+    used("/** @private */ this.a = 2; JSCompiler_renameProperty('a')");
+  }
+
+  public void testForIn() {
+    // This is the basic assumption that this pass makes:
+    // that it can warn even if it is used indirectly in a for-in loop
+    unused(LINE_JOINER.join(
+        "/** @constructor */ var X = function() {",
+        "  /** @private */ this.y = 1;",
+        "}",
+        "for (var a in new X()) { alert(x[a]) }"));
+  }
+
+  public void testObjectReflection1() {
+    // Verify reflection prevents warning.
+    used(LINE_JOINER.join(
+        "/** @constructor */ function A() {/** @private */ this.foo = 1;}",
+        "use(goog.reflect.object(A, {foo: 'foo'}));"));
+  }
+
+  public void testObjectReflection2() {
+    // Any object literal definition prevents warning.
+    used(LINE_JOINER.join(
+        "/** @constructor */ function A() {/** @private */  this.foo = 1;}",
+        "use({foo: 'foo'});"));
+  }
+
+  public void testPrototypeProps1() {
+    unused(LINE_JOINER.join(
+        "/** @constructor */ function A() {this.foo = 1;}",
+        "/** @private */ A.prototype.foo = 0;",
+        "A.prototype.method = function() {this.foo++};",
+        "new A().method()"));
+  }
+
+  public void testPrototypeProps2() {
+    // don't warn about properties that are exported by convention
+    used(LINE_JOINER.join(
+        "/** @constructor */ function A() {this._foo = 1;}",
+        "/** @private */ A.prototype._foo = 0;",
+        "A.prototype.method = function() {this._foo++};",
+        "new A().method()"));
+  }
+
+  public void testConstructorProperty1() {
+    unused("/** @constructor */ function C() {} /** @private */ C.prop = 1;");
+  }
+
+  public void testConstructorProperty2() {
+    used(
+        "/** @constructor */ function C() {} "
+        + "/** @private */ C.prop = 1; "
+        + "function use(a) { alert(a.prop) }; "
+        + "use(C)");
+  }
+}
