diff --git a/src/com/google/javascript/jscomp/AstValidator.java b/src/com/google/javascript/jscomp/AstValidator.java
index 4f163196b..d046981cd 100644
--- a/src/com/google/javascript/jscomp/AstValidator.java
+++ b/src/com/google/javascript/jscomp/AstValidator.java
@@ -52,7 +52,7 @@ public class AstValidator implements CompilerPass {
       @Override
       public void handleViolation(String message, Node n) {
         throw new IllegalStateException(
-            message + " Reference node " + n.toString());
+            message + ". Reference node:\n" + n.toStringTree());
       }
     });
   }
diff --git a/src/com/google/javascript/jscomp/Es6ToEs3Converter.java b/src/com/google/javascript/jscomp/Es6ToEs3Converter.java
index 90186c9eb..26e5af7eb 100644
--- a/src/com/google/javascript/jscomp/Es6ToEs3Converter.java
+++ b/src/com/google/javascript/jscomp/Es6ToEs3Converter.java
@@ -25,12 +25,16 @@ import com.google.javascript.rhino.Token;
  *
  * @author tbreisacher@google.com (Tyler Breisacher)
  */
-public class Es6ToEs3Converter implements CompilerPass, NodeTraversal.Callback {
+public class Es6ToEs3Converter extends NodeTraversal.AbstractPreOrderCallback
+    implements CompilerPass {
   private final AbstractCompiler compiler;
 
   private final LanguageMode languageIn;
   private final LanguageMode languageOut;
 
+  // The name of the var that captures 'this' for converting arrow functions.
+  private static final String THIS_VAR = "$jscomp$this";
+
   public Es6ToEs3Converter(AbstractCompiler compiler, CompilerOptions options) {
     this.compiler = compiler;
     this.languageIn = options.getLanguageIn();
@@ -51,16 +55,22 @@ public class Es6ToEs3Converter implements CompilerPass, NodeTraversal.Callback {
   }
 
   @Override
-  public void visit(NodeTraversal t, Node n, Node parent) {
+  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
     switch (n.getType()) {
       case Token.STRING_KEY:
         visitStringKey(n);
         break;
+      case Token.FUNCTION:
+        if (n.isArrowFunction()) {
+          visitArrowFunction(t, n);
+        }
+        break;
     }
+    return true;
   }
 
   /**
-   * Convert extended object literal {a} to {a:a}.
+   * Converts extended object literal {a} to {a:a}.
    */
   private void visitStringKey(Node n) {
     if (!n.hasChildren()) {
@@ -71,9 +81,66 @@ public class Es6ToEs3Converter implements CompilerPass, NodeTraversal.Callback {
     }
   }
 
-  @Override
-  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
-    return true;
+  /**
+   * Converts arrow functions to standard anonymous functions.
+   */
+  private void visitArrowFunction(NodeTraversal t, Node n) {
+    n.setIsArrowFunction(false);
+    Node body = n.getLastChild();
+    if (!body.isBlock()) {
+      body.detachFromParent();
+      Node newBody = IR.block(IR.returnNode(body).srcref(body)).srcref(body);
+      n.addChildToBack(newBody);
+    }
+
+    UpdateThisNodes thisUpdater = new UpdateThisNodes();
+    NodeTraversal.traverse(compiler, body, thisUpdater);
+    if (thisUpdater.changed) {
+      addThisVar(t);
+    }
+
+    compiler.reportCodeChange();
   }
-}
 
+  private void addThisVar(NodeTraversal t) {
+    Scope scope = t.getScope();
+    if (scope.isDeclared(THIS_VAR, false)) {
+      return;
+    }
+
+    Node parent = t.getScopeRoot();
+    if (parent.isFunction()) {
+      // Add the new node at the beginning of the function body.
+      parent = parent.getLastChild();
+    }
+    if (parent.isSyntheticBlock()) {
+      // Add the new node inside the SCRIPT node instead of the
+      // synthetic block that contains it.
+      parent = parent.getFirstChild();
+    }
+
+    Node name = IR.name(THIS_VAR).srcref(parent);
+    Node thisVar = IR.var(name, IR.thisNode().srcref(parent));
+    thisVar.srcref(parent);
+    parent.addChildToFront(thisVar);
+    scope.declare(THIS_VAR, name, null, compiler.getInput(parent.getInputId()));
+  }
+
+  private static class UpdateThisNodes implements NodeTraversal.Callback {
+    private boolean changed = false;
+
+    @Override
+    public void visit(NodeTraversal t, Node n, Node parent) {
+      if (n.isThis()) {
+        Node name = IR.name(THIS_VAR).srcref(n);
+        parent.replaceChild(n, name);
+        changed = true;
+      }
+    }
+
+    @Override
+    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
+      return !n.isFunction() || n.isArrowFunction();
+    }
+  }
+}
diff --git a/src/com/google/javascript/rhino/Node.java b/src/com/google/javascript/rhino/Node.java
index 390f94335..f9df6f510 100644
--- a/src/com/google/javascript/rhino/Node.java
+++ b/src/com/google/javascript/rhino/Node.java
@@ -1565,6 +1565,10 @@ public class Node implements Cloneable, Serializable {
       if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {
         return false;
       }
+    } else if (type == Token.FUNCTION) {
+      if (this.isArrowFunction() != node.isArrowFunction()) {
+        return false;
+      }
     }
 
     if (recurse) {
diff --git a/test/com/google/javascript/jscomp/Es6ToEs3ConverterTest.java b/test/com/google/javascript/jscomp/Es6ToEs3ConverterTest.java
index 245127e04..020d761d0 100644
--- a/test/com/google/javascript/jscomp/Es6ToEs3ConverterTest.java
+++ b/test/com/google/javascript/jscomp/Es6ToEs3ConverterTest.java
@@ -15,6 +15,7 @@
  */
 package com.google.javascript.jscomp;
 
+import com.google.common.base.Joiner;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 
 /**
@@ -44,4 +45,159 @@ public class Es6ToEs3ConverterTest extends CompilerTestCase {
   public void testExtendedObjLit() {
     test("var x = {a, b};", "var x = {a: a, b: b};");
   }
+
+  public void testArrowFunction() {
+    test("var f = x => { return x+1; };",
+        "var f = function(x) { return x+1; };");
+
+    test("var odds = [1,2,3,4].filter((n) => n%2 == 1);",
+        "var odds = [1,2,3,4].filter(function(n) { return n%2 == 1; });");
+
+    test("var f = x => x+1;",
+        "var f = function(x) { return x+1; };");
+
+    test("var f = x => { this.needsBinding(); return 0; };",
+        Joiner.on('\n').join(
+            "var $jscomp$this = this;",
+            "var f = function(x) {",
+            "  $jscomp$this.needsBinding();",
+            "  return 0;",
+            "};"));
+
+    test(Joiner.on('\n').join(
+        "var f = x => {",
+        "  this.init();",
+        "  this.doThings();",
+        "  this.done();",
+        "};"
+    ), Joiner.on('\n').join(
+        "var $jscomp$this = this;",
+        "var f = function(x) {",
+        "  $jscomp$this.init();",
+        "  $jscomp$this.doThings();",
+        "  $jscomp$this.done();",
+        "};"));
+  }
+
+  public void testMultipleArrowsInSameScope() {
+    test(Joiner.on('\n').join(
+        "var a1 = x => x+1;",
+        "var a2 = x => x-1;"
+    ), Joiner.on('\n').join(
+        "var a1 = function(x) { return x+1; };",
+        "var a2 = function(x) { return x-1; };"
+    ));
+
+    test(Joiner.on('\n').join(
+        "function f() {",
+        "  var a1 = x => x+1;",
+        "  var a2 = x => x-1;",
+        "}"
+    ), Joiner.on('\n').join(
+        "function f() {",
+        "  var a1 = function(x) { return x+1; };",
+        "  var a2 = function(x) { return x-1; };",
+        "}"
+    ));
+
+    test(Joiner.on('\n').join(
+        "function f() {",
+        "  var a1 = () => this.x;",
+        "  var a2 = () => this.y;",
+        "}"
+    ), Joiner.on('\n').join(
+        "function f() {",
+        "  var $jscomp$this = this;",
+        "  var a1 = function() { return $jscomp$this.x; };",
+        "  var a2 = function() { return $jscomp$this.y; };",
+        "}"
+    ));
+
+    test(Joiner.on('\n').join(
+        "var a = [1,2,3,4];",
+        "var b = a.map(x => x+1).map(x => x*x);"
+    ), Joiner.on('\n').join(
+        "var a = [1,2,3,4];",
+        "var b = a.map(function(x) { return x+1; }).map(function(x) { return x*x; });"
+    ));
+
+    test(Joiner.on('\n').join(
+        "function f() {",
+        "  var a = [1,2,3,4];",
+        "  var b = a.map(x => x+1).map(x => x*x);",
+        "}"
+    ), Joiner.on('\n').join(
+        "function f() {",
+        "  var a = [1,2,3,4];",
+        "  var b = a.map(function(x) { return x+1; }).map(function(x) { return x*x; });",
+        "}"
+    ));
+  }
+
+  public void testArrowNestedScope() {
+    test(Joiner.on('\n').join(
+        "var outer = {",
+        "  f: function() {",
+        "     var a1 = () => this.x;",
+        "     var inner = {",
+        "       f: function() {",
+        "         var a2 = () => this.y;",
+        "       }",
+        "     };",
+        "  }",
+        "}"
+    ), Joiner.on('\n').join(
+        "var outer = {",
+        "  f: function() {",
+        "     var $jscomp$this = this;",
+        "     var a1 = function() { return $jscomp$this.x; }",
+        "     var inner = {",
+        "       f: function() {",
+        "         var $jscomp$this = this;",
+        "         var a2 = function() { return $jscomp$this.y; }",
+        "       }",
+        "     };",
+        "  }",
+        "}"
+    ));
+
+    test(Joiner.on('\n').join(
+        "function f() {",
+        "  var setup = () => {",
+        "    function Foo() { this.x = 5; }",
+        "    this.f = new Foo;",
+        "  }",
+        "}"
+    ), Joiner.on('\n').join(
+        "function f() {",
+        "  var $jscomp$this = this;",
+        "  var setup = function() {",
+        "    function Foo() { this.x = 5; }",
+        "    $jscomp$this.f = new Foo;",
+        "  }",
+        "}"
+    ));
+  }
+
+  public void testArrowception() {
+    test("var f = x => y => x+y;",
+        "var f = function(x) {return function(y) { return x+y; }; };");
+  }
+
+  public void testArrowceptionWithThis() {
+    test(Joiner.on('\n').join(
+        "var f = x => {",
+        "  var g = y => {",
+        "    this.foo();",
+        "  }",
+        "}"
+    ), Joiner.on('\n').join(
+        "var $jscomp$this = this;",
+        "var f = function(x) {",
+        "  var g = function(y) {",
+        "    $jscomp$this.foo();",
+        "  }",
+        "}"
+    ));
+  }
 }
diff --git a/test/com/google/javascript/jscomp/SanityCheckTest.java b/test/com/google/javascript/jscomp/SanityCheckTest.java
index e38399388..504ee8966 100644
--- a/test/com/google/javascript/jscomp/SanityCheckTest.java
+++ b/test/com/google/javascript/jscomp/SanityCheckTest.java
@@ -61,8 +61,7 @@ public class SanityCheckTest extends CompilerTestCase {
     try {
       test("var x = 3;", "var x=3;0;0");
     } catch (IllegalStateException e) {
-      assertEquals("Expected BLOCK but was EMPTY Reference node EMPTY",
-          e.getMessage());
+      assertTrue(e.getMessage().contains("Expected BLOCK but was EMPTY"));
       exceptionCaught = true;
     }
     assertTrue(exceptionCaught);
