diff --git a/src/com/google/javascript/jscomp/CheckJSDoc.java b/src/com/google/javascript/jscomp/CheckJSDoc.java
index 7bd8aa089..f6aacd547 100644
--- a/src/com/google/javascript/jscomp/CheckJSDoc.java
+++ b/src/com/google/javascript/jscomp/CheckJSDoc.java
@@ -273,6 +273,8 @@ final class CheckJSDoc extends AbstractPostOrderCallback implements CompilerPass
         // initializers are valid.
         case Token.NAME:
         case Token.DEFAULT_VALUE:
+        case Token.ARRAY_PATTERN:
+        case Token.OBJECT_PATTERN:
           Node parent = n.getParent();
           switch (parent.getType()) {
             case Token.GETTER_DEF:
diff --git a/src/com/google/javascript/jscomp/DiagnosticGroups.java b/src/com/google/javascript/jscomp/DiagnosticGroups.java
index ce2bd2f9a..d2209fd1b 100644
--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java
+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java
@@ -435,10 +435,12 @@ public class DiagnosticGroups {
           // checkTypes DiagnosticGroup
           CheckInterfaces.INTERFACE_FUNCTION_NOT_EMPTY,
           CheckInterfaces.INTERFACE_SHOULD_NOT_TAKE_ARGS,
-          CheckJSDocStyle.MISSING_PARAM_JSDOC,
+          CheckJSDocStyle.INCORRECT_PARAM_NAME,
+          CheckJSDocStyle.MIXED_PARAM_JSDOC_STYLES,
           CheckJSDocStyle.MUST_BE_PRIVATE,
           CheckJSDocStyle.OPTIONAL_PARAM_NOT_MARKED_OPTIONAL,
           CheckJSDocStyle.OPTIONAL_TYPE_NOT_USING_OPTIONAL_NAME,
+          CheckJSDocStyle.WRONG_NUMBER_OF_PARAMS,
           CheckNullableReturn.NULLABLE_RETURN,
           CheckNullableReturn.NULLABLE_RETURN_WITH_NAME,
           CheckForInOverArray.FOR_IN_OVER_ARRAY,
diff --git a/src/com/google/javascript/jscomp/Es6RewriteDestructuring.java b/src/com/google/javascript/jscomp/Es6RewriteDestructuring.java
index 649dfa434..35a97c293 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteDestructuring.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteDestructuring.java
@@ -124,7 +124,14 @@ public final class Es6RewriteDestructuring implements NodeTraversal.Callback, Ho
 
         compiler.reportCodeChange();
       } else if (param.isDestructuringPattern()) {
-        String tempVarName = DESTRUCTURING_TEMP_VAR + (destructuringVarCounter++);
+        String tempVarName;
+        JSDocInfo fnJSDoc = function.getJSDocInfo();
+        if (fnJSDoc != null && fnJSDoc.getParameterNameAt(i) != null) {
+          tempVarName = fnJSDoc.getParameterNameAt(i);
+        } else {
+          tempVarName = DESTRUCTURING_TEMP_VAR + (destructuringVarCounter++);
+        }
+
         Node newParam = IR.name(tempVarName);
         newParam.setJSDocInfo(param.getJSDocInfo());
         paramList.replaceChild(param, newParam);
diff --git a/src/com/google/javascript/jscomp/lint/CheckJSDocStyle.java b/src/com/google/javascript/jscomp/lint/CheckJSDocStyle.java
index 760ae515d..45e4c3cde 100644
--- a/src/com/google/javascript/jscomp/lint/CheckJSDocStyle.java
+++ b/src/com/google/javascript/jscomp/lint/CheckJSDocStyle.java
@@ -16,6 +16,7 @@
 package com.google.javascript.jscomp.lint;
 
 import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
 import com.google.javascript.jscomp.AbstractCompiler;
 import com.google.javascript.jscomp.CompilerPass;
 import com.google.javascript.jscomp.DiagnosticType;
@@ -27,13 +28,16 @@ import com.google.javascript.rhino.JSDocInfo.Visibility;
 import com.google.javascript.rhino.JSTypeExpression;
 import com.google.javascript.rhino.Node;
 
+import java.util.List;
+
 /**
  * Checks for various JSDoc-related style issues, such as function definitions without JsDoc, params
  * with no corresponding {@code @param} annotation, coding conventions not being respected, etc.
  */
 public final class CheckJSDocStyle extends AbstractPostOrderCallback implements CompilerPass {
-  public static final DiagnosticType MISSING_PARAM_JSDOC =
-      DiagnosticType.warning("JSC_MISSING_PARAM_JSDOC", "Missing JSDoc for param {0}");
+  public static final DiagnosticType MIXED_PARAM_JSDOC_STYLES =
+      DiagnosticType.warning("JSC_MIXED_PARAM_JSDOC_STYLES",
+      "Functions may not use both @param annotations and inline JSDoc");
 
   public static final DiagnosticType MUST_BE_PRIVATE =
       DiagnosticType.warning("JSC_MUST_BE_PRIVATE", "Function {0} must be marked @private");
@@ -46,6 +50,14 @@ public final class CheckJSDocStyle extends AbstractPostOrderCallback implements
       DiagnosticType.warning("JSC_OPTIONAL_TYPE_NOT_USING_OPTIONAL_NAME",
           "Optional parameter name {0} must be prefixed with opt_");
 
+  public static final DiagnosticType WRONG_NUMBER_OF_PARAMS =
+      DiagnosticType.warning("JSC_WRONG_NUMBER_OF_PARAMS",
+          "Wrong number of @param annotations");
+
+  public static final DiagnosticType INCORRECT_PARAM_NAME =
+      DiagnosticType.warning("JSC_INCORRECT_PARAM_NAME",
+          "Incorrect param name. Are your @param annotations in the wrong order?");
+
   private final AbstractCompiler compiler;
 
   public CheckJSDocStyle(AbstractCompiler compiler) {
@@ -69,38 +81,8 @@ public final class CheckJSDocStyle extends AbstractPostOrderCallback implements
     if (jsDoc == null) {
       return;
     }
-    if (!jsDoc.isOverride()) {
-      Node paramList = function.getFirstChild().getNext();
-      for (Node param : paramList.children()) {
-        boolean nameOptional;
-        if (param.isDefaultValue()) {
-          param = param.getFirstChild();
-          nameOptional = true;
-        } else if (param.isName()) {
-          nameOptional = param.getString().startsWith("opt_");
-        } else {
-          Preconditions.checkState(param.isDestructuringPattern() || param.isRest(), param);
-          continue;
-        }
-
-        JSTypeExpression paramType = jsDoc.getParameterType(param.getString());
-        if (paramType == null) {
-          if (param.getJSDocInfo() != null) {
-            paramType = Preconditions.checkNotNull(param.getJSDocInfo().getType());
-          } else {
-            t.report(param, MISSING_PARAM_JSDOC, param.getString());
-            return;
-          }
-        }
-
-        boolean jsDocOptional = paramType.isOptionalArg();
-        if (nameOptional && !jsDocOptional) {
-          t.report(param, OPTIONAL_PARAM_NOT_MARKED_OPTIONAL, param.getString());
-        } else if (!nameOptional && jsDocOptional) {
-          t.report(param, OPTIONAL_TYPE_NOT_USING_OPTIONAL_NAME, param.getString());
-        }
-      }
-    }
+
+    checkParams(t, function, jsDoc);
 
     String name = NodeUtil.getFunctionName(function);
     if (name != null && compiler.getCodingConvention().isPrivate(name)
@@ -108,5 +90,60 @@ public final class CheckJSDocStyle extends AbstractPostOrderCallback implements
       t.report(function, MUST_BE_PRIVATE, name);
     }
   }
-}
 
+  private void checkParams(NodeTraversal t, Node function, JSDocInfo jsDoc) {
+    if (jsDoc.isOverride()) {
+      return;
+    }
+
+    List<String> paramsFromJsDoc = ImmutableList.copyOf(jsDoc.getParameterNames());
+    if (paramsFromJsDoc.isEmpty()) {
+      // The user hasn't provided any @param annotations at all. Either this is a simple
+      // enough function they decided not to bother, or they're using inline annotations instead.
+      // TODO(tbreisacher): If they are using inline annotations, check that there is an
+      // annotation on every param.
+      return;
+    }
+
+    Node paramList = function.getFirstChild().getNext();
+    if (paramsFromJsDoc.size() != paramList.getChildCount()) {
+      t.report(paramList, WRONG_NUMBER_OF_PARAMS);
+      return;
+    }
+
+    Node param = paramList.getFirstChild();
+    for (int i = 0; i < paramsFromJsDoc.size(); i++) {
+      if (param.getJSDocInfo() != null) {
+        t.report(param, MIXED_PARAM_JSDOC_STYLES);
+      }
+
+      boolean nameOptional;
+      if (param.isDefaultValue()) {
+        param = param.getFirstChild();
+        nameOptional = true;
+      } else if (param.isName()) {
+        nameOptional = param.getString().startsWith("opt_");
+      } else {
+        Preconditions.checkState(param.isDestructuringPattern() || param.isRest(), param);
+        nameOptional = false;
+      }
+
+      if (param.isName() && !param.getString().equals(paramsFromJsDoc.get(i))) {
+        t.report(param, INCORRECT_PARAM_NAME);
+        return;
+      }
+      // If `param` is not a NAME node (i.e. it's a destructuring pattern) then the JSDoc
+      // can have any param name.
+
+      JSTypeExpression paramType = jsDoc.getParameterType(paramsFromJsDoc.get(i));
+      boolean jsDocOptional = paramType.isOptionalArg();
+      if (nameOptional && !jsDocOptional) {
+        t.report(param, OPTIONAL_PARAM_NOT_MARKED_OPTIONAL, param.getString());
+      } else if (!nameOptional && jsDocOptional) {
+        t.report(param, OPTIONAL_TYPE_NOT_USING_OPTIONAL_NAME, param.getString());
+      }
+
+      param = param.getNext();
+    }
+  }
+}
diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java
index 9f4e9fc3d..5d8303e58 100644
--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java
+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java
@@ -948,7 +948,7 @@ class IRFactory {
 
       Node node = newNode(Token.ARRAY_PATTERN);
       for (ParseTree child : tree.elements) {
-        node.addChildToBack(transform(child));
+        node.addChildToBack(transformNodeWithInlineJsDoc(child));
       }
       return node;
     }
@@ -958,7 +958,7 @@ class IRFactory {
 
       Node node = newNode(Token.OBJECT_PATTERN);
       for (ParseTree child : tree.fields) {
-        node.addChildToBack(transform(child));
+        node.addChildToBack(transformNodeWithInlineJsDoc(child));
       }
       return node;
     }
@@ -1532,6 +1532,9 @@ class IRFactory {
     }
 
     Node processPropertyNameAssignment(PropertyNameAssignmentTree tree) {
+      // TODO(tbreisacher): Allow inline JSDoc here (but then forbid it in CheckJSDoc)
+      // so that it's clear we don't support annotations like
+      //   function f({x: /** string */ y}) {}
       Node key = processObjectLitKeyAsString(tree.name);
       key.setType(Token.STRING_KEY);
       if (tree.value != null) {
diff --git a/src/com/google/javascript/rhino/JSDocInfo.java b/src/com/google/javascript/rhino/JSDocInfo.java
index f79eeb959..0ac5f3f5f 100644
--- a/src/com/google/javascript/rhino/JSDocInfo.java
+++ b/src/com/google/javascript/rhino/JSDocInfo.java
@@ -207,7 +207,7 @@ public class JSDocInfo implements Serializable {
     String sourceComment = null;
     List<Marker> markers = null;
 
-    Map<String, String> parameters = null;
+    LinkedHashMap<String, String> parameters = null;
     Map<JSTypeExpression, String> throwsDescriptions = null;
     String blockDescription = null;
     String fileOverview = null;
@@ -1215,7 +1215,7 @@ public class JSDocInfo implements Serializable {
   }
 
   /**
-   * Gets the parameter type.
+   * Gets the type of a given named parameter.
    * @param parameter the parameter's name
    * @return the parameter's type or {@code null} if this parameter is not
    *     defined or has a {@code null} type
@@ -1227,6 +1227,15 @@ public class JSDocInfo implements Serializable {
     return info.parameters.get(parameter);
   }
 
+  /**
+   * Gets the type of the nth {@code @param} annotation. The iteration order
+   * is the order in which parameters are defined in the JSDoc, rather
+   * than the order in which the function declares them.
+   */
+  public JSTypeExpression getParameterType(int index) {
+    return info.parameters.get(getParameterNameAt(index));
+  }
+
   /**
    * Returns whether the parameter is defined.
    */
@@ -1262,6 +1271,18 @@ public class JSDocInfo implements Serializable {
     return ImmutableSet.copyOf(info.parameters.keySet());
   }
 
+  /**
+   * Returns the nth name in the defined parameters. The iteration order
+   * is the order in which parameters are defined in the JSDoc, rather
+   * than the order in which the function declares them.
+   */
+  public String getParameterNameAt(int index) {
+    if (info == null || info.parameters == null) {
+      return null;
+    }
+    return ImmutableList.copyOf(info.parameters.keySet()).get(index);
+  }
+
   /**
    * Gets the number of parameters defined.
    */
diff --git a/test/com/google/javascript/jscomp/CheckJsDocTest.java b/test/com/google/javascript/jscomp/CheckJsDocTest.java
index 02927f0c6..72ca9f63a 100644
--- a/test/com/google/javascript/jscomp/CheckJsDocTest.java
+++ b/test/com/google/javascript/jscomp/CheckJsDocTest.java
@@ -44,6 +44,23 @@ public final class CheckJsDocTest extends Es6CompilerTestCase {
     return options;
   }
 
+  public void testInlineJsDoc_ES6() {
+    testSame("function f(/** string */ x) {}");
+    testSameEs6("function f(/** number= */ x=3) {}");
+    testSameEs6("function f(/** !Object */ {x}) {}");
+    testSameEs6("function f(/** !Array */ [x]) {}");
+
+    testWarningEs6("function f([/** number */ x]) {}", MISPLACED_ANNOTATION);
+  }
+
+  // TODO(tbreisacher): These should be a MISPLACED_ANNOTATION warning instead of silently failing.
+  public void testInlineJsDocInsideObjectParams() {
+    testSameEs6("function f({ prop: {/** string */ x} }) {}");
+    testSameEs6("function f({ prop: {x: /** string */ y} }) {}");
+    testSameEs6("function f({ /** number */ x }) {}");
+    testSameEs6("function f({ prop: /** number */ x }) {}");
+  }
+
   public void testInvalidClassJsdoc() {
     testSameEs6("class Foo { /** @param {number} x */ constructor(x) {}}");
 
diff --git a/test/com/google/javascript/jscomp/CompilerTestCase.java b/test/com/google/javascript/jscomp/CompilerTestCase.java
index caffb8400..f1d30f220 100644
--- a/test/com/google/javascript/jscomp/CompilerTestCase.java
+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java
@@ -429,7 +429,7 @@ public abstract class CompilerTestCase extends TestCase {
    * @param error Expected error
    */
   public void testError(String js, DiagnosticType error) {
-    assertNotNull("Must assert an error", error);
+    assertNotNull(error);
     test(js, null, error, null);
   }
 
@@ -440,7 +440,7 @@ public abstract class CompilerTestCase extends TestCase {
    * @param warning Expected warning
    */
   public void testWarning(String js, DiagnosticType warning) {
-    assertNotNull("Must assert an warning", warning);
+    assertNotNull(warning);
     test(js, null, null, warning);
   }
 
diff --git a/test/com/google/javascript/jscomp/Es6RewriteDestructuringTest.java b/test/com/google/javascript/jscomp/Es6RewriteDestructuringTest.java
index 7bf243787..058c0c8c6 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteDestructuringTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteDestructuringTest.java
@@ -15,6 +15,8 @@
  */
 package com.google.javascript.jscomp;
 
+import static com.google.javascript.jscomp.TypeValidator.TYPE_MISMATCH_WARNING;
+
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 
 public class Es6RewriteDestructuringTest extends CompilerTestCase {
@@ -435,4 +437,43 @@ public class Es6RewriteDestructuringTest extends CompilerTestCase {
         "function f(zero, one=void g()) {}",
         "function f(zero, one) {   one = (one === undefined) ? void g() : one; }");
   }
+
+  public void testTypeCheck() {
+    enableTypeCheck();
+
+    test(
+        "/** @param {{x: number}} obj */ function f({x}) {}",
+        LINE_JOINER.join(
+            "/** @param {{x: number}} obj */",
+            "function f(obj) {",
+            "  var $jscomp$destructuring$var0 = obj;",
+            "  var x = $jscomp$destructuring$var0.x;",
+            "}"));
+
+    testWarning(
+        LINE_JOINER.join(
+            "/** @param {{x: number}} obj */",
+            "function f({x}) {}",
+          "f({ x: 'str'});"),
+        TYPE_MISMATCH_WARNING);
+  }
+
+  public void testTypeCheck_inlineAnnotations() {
+    enableTypeCheck();
+
+    test(
+        "function f(/** {x: number} */ {x}) {}",
+        LINE_JOINER.join(
+            "function f(/** {x: number} */ $jscomp$destructuring$var0) {",
+            "  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0;",
+            "  var x = $jscomp$destructuring$var1.x;",
+            "}"));
+
+    testWarning(
+        LINE_JOINER.join(
+            "function f(/** {x: number} */ {x}) {}",
+            "f({ x: 'str'});"),
+        TYPE_MISMATCH_WARNING);
+  }
+
 }
diff --git a/test/com/google/javascript/jscomp/lint/CheckJSDocStyleTest.java b/test/com/google/javascript/jscomp/lint/CheckJSDocStyleTest.java
index 2e1975af5..2ddba3693 100644
--- a/test/com/google/javascript/jscomp/lint/CheckJSDocStyleTest.java
+++ b/test/com/google/javascript/jscomp/lint/CheckJSDocStyleTest.java
@@ -15,10 +15,12 @@
  */
 package com.google.javascript.jscomp.lint;
 
-import static com.google.javascript.jscomp.lint.CheckJSDocStyle.MISSING_PARAM_JSDOC;
+import static com.google.javascript.jscomp.lint.CheckJSDocStyle.INCORRECT_PARAM_NAME;
+import static com.google.javascript.jscomp.lint.CheckJSDocStyle.MIXED_PARAM_JSDOC_STYLES;
 import static com.google.javascript.jscomp.lint.CheckJSDocStyle.MUST_BE_PRIVATE;
 import static com.google.javascript.jscomp.lint.CheckJSDocStyle.OPTIONAL_PARAM_NOT_MARKED_OPTIONAL;
 import static com.google.javascript.jscomp.lint.CheckJSDocStyle.OPTIONAL_TYPE_NOT_USING_OPTIONAL_NAME;
+import static com.google.javascript.jscomp.lint.CheckJSDocStyle.WRONG_NUMBER_OF_PARAMS;
 
 import com.google.javascript.jscomp.Compiler;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
@@ -83,7 +85,7 @@ public final class CheckJSDocStyleTest extends CompilerTestCase {
             // No @param for y.
             " */",
             "function f(x, y) {}"),
-        MISSING_PARAM_JSDOC);
+        WRONG_NUMBER_OF_PARAMS);
 
     testWarning(
         LINE_JOINER.join(
@@ -100,71 +102,80 @@ public final class CheckJSDocStyleTest extends CompilerTestCase {
             // No @param for y.
             " */",
             "function f(x, y = 1) {}"),
-        MISSING_PARAM_JSDOC);
+        WRONG_NUMBER_OF_PARAMS);
   }
 
   public void testMissingParamWithDestructuringPattern() {
     testWarning(
         LINE_JOINER.join(
             "/**",
+            " * @param {string} namedParam",
             " * @return {void}",
             " */",
             "function f(namedParam, {destructuring:pattern}) {",
             "}"),
-        MISSING_PARAM_JSDOC);
+        WRONG_NUMBER_OF_PARAMS);
 
     testWarning(
         LINE_JOINER.join(
             "/**",
+            " * @param {string} namedParam",
             " * @return {void}",
             " */",
             "function f({destructuring:pattern}, namedParam) {",
             "}"),
-        MISSING_PARAM_JSDOC);
+        WRONG_NUMBER_OF_PARAMS);
 
     testWarning(
         LINE_JOINER.join(
             "/**",
+            " * @param {string} namedParam",
             " * @return {void}",
             " */",
             "function f(namedParam, [pattern]) {",
             "}"),
-        MISSING_PARAM_JSDOC);
+        WRONG_NUMBER_OF_PARAMS);
 
     testWarning(
         LINE_JOINER.join(
             "/**",
+            " * @param {string} namedParam",
             " * @return {void}",
             " */",
             "function f([pattern], namedParam) {",
             "}"),
-        MISSING_PARAM_JSDOC);
+        WRONG_NUMBER_OF_PARAMS);
   }
 
   public void testMissingParamWithDestructuringPatternWithDefault() {
     testWarning(
         LINE_JOINER.join(
             "/**",
+            " * @param {string} namedParam",
             " * @return {void}",
             " */",
             "function f(namedParam, {destructuring:pattern} = defaultValue) {",
             "}"),
-        MISSING_PARAM_JSDOC);
+        WRONG_NUMBER_OF_PARAMS);
 
     testWarning(
         LINE_JOINER.join(
             "/**",
+            " * @param {string} namedParam",
             " * @return {void}",
             " */",
             "function f(namedParam, [pattern] = defaultValue) {",
             "}"),
-        MISSING_PARAM_JSDOC);
+        WRONG_NUMBER_OF_PARAMS);
   }
 
   public void testMissingPrivate() {
     testSame(
         LINE_JOINER.join(
-            "/**", " * @return {number}", " */", "X.prototype.foo_ = function() { return 0; }"),
+            "/**",
+            " * @return {number}",
+            " */",
+            "X.prototype.foo_ = function() { return 0; }"),
         MUST_BE_PRIVATE);
 
     testSame(
@@ -178,13 +189,58 @@ public final class CheckJSDocStyleTest extends CompilerTestCase {
 
   public void testOptionalArgs() {
     testSame(
-        LINE_JOINER.join("/**", " * @param {number=} n", " */", "function f(n) {}"),
+        LINE_JOINER.join(
+            "/**",
+            " * @param {number=} n",
+            " */",
+            "function f(n) {}"),
         OPTIONAL_TYPE_NOT_USING_OPTIONAL_NAME);
 
     testSame(
-        LINE_JOINER.join("/**", " * @param {number} opt_n", " */", "function f(opt_n) {}"),
+        LINE_JOINER.join(
+            "/**",
+            " * @param {number} opt_n",
+            " */",
+            "function f(opt_n) {}"),
         OPTIONAL_PARAM_NOT_MARKED_OPTIONAL);
 
-    testSame(LINE_JOINER.join("/**", " * @param {number=} opt_n", " */", "function f(opt_n) {}"));
+    testSame(LINE_JOINER.join(
+        "/**",
+        " * @param {number=} opt_n",
+        " */",
+        "function f(opt_n) {}"));
+  }
+
+  public void testParamsOutOfOrder() {
+    testWarning(
+        LINE_JOINER.join(
+            "/**",
+            " * @param {?} second",
+            " * @param {?} first",
+            " */",
+            "function f(first, second) {}"),
+        INCORRECT_PARAM_NAME);
+  }
+
+  public void testMixedStyles() {
+    testWarning(
+        LINE_JOINER.join(
+            "/**",
+            " * @param {?} first",
+            " * @param {string} second",
+            " */",
+            "function f(first, /** string */ second) {}"),
+        MIXED_PARAM_JSDOC_STYLES);
+  }
+
+  public void testDestructuring() {
+    testSame(
+        LINE_JOINER.join(
+            "/**",
+            " * @param {{x: number, y: number}} point",
+            " */",
+            "function getDistanceFromZero({x, y}) {}"));
+
+    testSame("function getDistanceFromZero(/** {x: number, y: number} */ {x, y}) {}");
   }
 }
