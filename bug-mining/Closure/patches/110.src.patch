diff --git a/src/com/google/javascript/jscomp/CheckGlobalNames.java b/src/com/google/javascript/jscomp/CheckGlobalNames.java
index f861b30fb..12c9981ce 100644
--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java
+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java
@@ -40,6 +40,11 @@ class CheckGlobalNames implements CompilerPass {
       "JSC_UNDEFINED_NAME",
       "{0} is never defined");
 
+  static final DiagnosticType NAME_DEFINED_LATE_WARNING =
+      DiagnosticType.warning(
+          "JSC_NAME_DEFINED_LATE",
+          "{0} is not defined yet, so properties cannot be defined on it");
+
   static final DiagnosticType STRICT_MODULE_DEP_QNAME =
       DiagnosticType.disabled(
           "JSC_STRICT_MODULE_DEP_QNAME",
@@ -106,18 +111,20 @@ class CheckGlobalNames implements CompilerPass {
     // If the name is not defined, emit warnings for each reference. While
     // we're looking through each reference, check all the module dependencies.
     Ref declaration = name.declaration;
-    if (!isDefined) {
-      if (declaration != null) {
-        reportRefToUndefinedName(name, declaration);
-      }
+    Name parent = name.parent;
+    if (isDefined &&
+        declaration != null &&
+        parent != null &&
+        parent.declaration != null &&
+        parent.localSets == 0 &&
+        parent.declaration.preOrderIndex > declaration.preOrderIndex) {
+      compiler.report(
+          JSError.make(declaration.source.getName(), declaration.node,
+              NAME_DEFINED_LATE_WARNING, parent.fullName()));
     }
 
     JSModuleGraph moduleGraph = compiler.getModuleGraph();
     for (Ref ref : name.getRefs()) {
-      if (ref == name.declaration) {
-        continue;
-      }
-
       if (!isDefined) {
         reportRefToUndefinedName(name, ref);
       } else {
diff --git a/src/com/google/javascript/jscomp/CompilerOptions.java b/src/com/google/javascript/jscomp/CompilerOptions.java
index ef590b986..4de45bece 100644
--- a/src/com/google/javascript/jscomp/CompilerOptions.java
+++ b/src/com/google/javascript/jscomp/CompilerOptions.java
@@ -1344,6 +1344,7 @@ public class CompilerOptions implements Serializable, Cloneable {
 
   private static class NullAliasTransformationHandler
       implements AliasTransformationHandler, Serializable {
+    private static final long serialVersionUID = 0L;
 
     private static final AliasTransformation NULL_ALIAS_TRANSFORMATION =
         new NullAliasTransformation();
@@ -1357,6 +1358,8 @@ public class CompilerOptions implements Serializable, Cloneable {
 
     private static class NullAliasTransformation
         implements AliasTransformation, Serializable {
+      private static final long serialVersionUID = 0L;
+
       @Override
       public void addAlias(String alias, String definition) {
       }
diff --git a/src/com/google/javascript/jscomp/GlobalNamespace.java b/src/com/google/javascript/jscomp/GlobalNamespace.java
index f7e680a1b..3b3e25292 100644
--- a/src/com/google/javascript/jscomp/GlobalNamespace.java
+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java
@@ -20,7 +20,6 @@ import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
-import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.rhino.JSDocInfo;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -46,6 +45,13 @@ class GlobalNamespace {
   private Scope externsScope;
   private boolean generated = false;
 
+  /**
+   * Each reference has an index in post-order.
+   * Notice that some nodes are represented by 2 Ref objects, so
+   * this index is not necessarily unique.
+   */
+  private int currentPreOrderIndex = 0;
+
   /** Global namespace tree */
   private List<Name> globalNames = new ArrayList<Name>();
 
@@ -211,7 +217,7 @@ class GlobalNamespace {
   /**
    * Builds a tree representation of the global namespace. Omits prototypes.
    */
-  private class BuildGlobalNamespace extends AbstractPostOrderCallback {
+  private class BuildGlobalNamespace implements NodeTraversal.Callback {
 
     private final Predicate<Node> nodeFilter;
 
@@ -228,7 +234,16 @@ class GlobalNamespace {
     }
 
     @Override
-    public void visit(NodeTraversal t, Node n, Node parent) {
+    public void visit(NodeTraversal t, Node n, Node parent) {}
+
+    /** Collect the references in pre-order. */
+    @Override
+    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
+      collect(t, n, parent);
+      return true;
+    }
+
+    public void collect(NodeTraversal t, Node n, Node parent) {
       if (nodeFilter != null && !nodeFilter.apply(n)) {
         return;
       }
@@ -456,12 +471,14 @@ class GlobalNamespace {
       Name nameObj = getOrCreateName(name);
       nameObj.type = type;
 
-      Ref set = new Ref(t, n, Ref.Type.SET_FROM_GLOBAL);
+      Ref set = new Ref(t, n, Ref.Type.SET_FROM_GLOBAL,
+          currentPreOrderIndex++);
       nameObj.addRef(set);
 
       if (isNestedAssign(parent)) {
         // This assignment is both a set and a get that creates an alias.
-        Ref get = new Ref(t, n, Ref.Type.ALIASING_GET);
+        Ref get = new Ref(t, n, Ref.Type.ALIASING_GET,
+            currentPreOrderIndex++);
         nameObj.addRef(get);
         Ref.markTwins(set, get);
       } else if (isConstructorOrEnumDeclaration(n, parent)) {
@@ -524,12 +541,12 @@ class GlobalNamespace {
       if (maybeHandlePrototypePrefix(t, n, parent, name)) return;
 
       Name node = getOrCreateName(name);
-      Ref set = new Ref(t, n, Ref.Type.SET_FROM_LOCAL);
+      Ref set = new Ref(t, n, Ref.Type.SET_FROM_LOCAL, currentPreOrderIndex++);
       node.addRef(set);
 
       if (isNestedAssign(parent)) {
         // This assignment is both a set and a get that creates an alias.
-        Ref get = new Ref(t, n, Ref.Type.ALIASING_GET);
+        Ref get = new Ref(t, n, Ref.Type.ALIASING_GET, currentPreOrderIndex++);
         node.addRef(get);
         Ref.markTwins(set, get);
       }
@@ -663,7 +680,7 @@ class GlobalNamespace {
       Name node = getOrCreateName(name);
 
       // No need to look up additional ancestors, since they won't be used.
-      node.addRef(new Ref(t, n, type));
+      node.addRef(new Ref(t, n, type, currentPreOrderIndex++));
     }
 
     /**
@@ -1038,6 +1055,7 @@ class GlobalNamespace {
     final Type type;
     final CompilerInput source;
     final Scope scope;
+    final int preOrderIndex;
 
     /**
      * Certain types of references are actually double-refs. For example,
@@ -1051,24 +1069,27 @@ class GlobalNamespace {
     /**
      * Creates a reference at the current node.
      */
-    Ref(NodeTraversal t, Node name, Type type) {
+    Ref(NodeTraversal t, Node name, Type type, int index) {
       this.node = name;
       this.source = t.getInput();
       this.type = type;
       this.scope = t.getScope();
+      this.preOrderIndex = index;
     }
 
-    private Ref(Ref original, Type type) {
+    private Ref(Ref original, Type type, int index) {
       this.node = original.node;
       this.source = original.source;
       this.type = type;
       this.scope = original.scope;
+      this.preOrderIndex = index;
     }
 
-    private Ref(Type type) {
+    private Ref(Type type, int index) {
       this.type = type;
       this.source = null;
       this.scope = null;
+      this.preOrderIndex = index;
     }
 
     JSModule getModule() {
@@ -1101,11 +1122,11 @@ class GlobalNamespace {
      * a different class.
      */
     Ref cloneAndReclassify(Type type) {
-      return new Ref(this, type);
+      return new Ref(this, type, this.preOrderIndex);
     }
 
     static Ref createRefForTesting(Type type) {
-      return new Ref(type);
+      return new Ref(type, -1);
     }
   }
 }
diff --git a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java
index abc6f5858..aba2ece98 100644
--- a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java
+++ b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java
@@ -16,6 +16,7 @@
 
 package com.google.javascript.jscomp;
 
+import static com.google.javascript.jscomp.CheckGlobalNames.NAME_DEFINED_LATE_WARNING;
 import static com.google.javascript.jscomp.CheckGlobalNames.UNDEFINED_NAME_WARNING;
 import static com.google.javascript.jscomp.CheckGlobalNames.STRICT_MODULE_DEP_QNAME;
 
@@ -201,4 +202,39 @@ public class CheckGlobalNamesTest extends CompilerTestCase {
         NAMES
     ), UNDEFINED_NAME_WARNING);
   }
+
+  public void testLateDefinedName1() {
+    testSame("x.y = {}; var x = {};", NAME_DEFINED_LATE_WARNING);
+  }
+
+  public void testLateDefinedName2() {
+    testSame("var x = {}; x.y.z = {}; x.y = {};", NAME_DEFINED_LATE_WARNING);
+  }
+
+  public void testLateDefinedName3() {
+    testSame("var x = {}; x.y.z = {}; x.y = {z: {}};",
+        NAME_DEFINED_LATE_WARNING);
+  }
+
+  public void testLateDefinedName4() {
+    testSame("var x = {}; x.y.z.bar = {}; x.y = {z: {}};",
+        NAME_DEFINED_LATE_WARNING);
+  }
+
+  public void testOkLateDefinedName1() {
+    testSame("function f() { x.y = {}; } var x = {};");
+  }
+
+  public void testOkLateDefinedName2() {
+    testSame("var x = {}; function f() { x.y.z = {}; } x.y = {};");
+  }
+
+  public void testPathologicalCaseThatsOkAnyway() {
+    testSame(
+        "var x = {};" +
+        "switch (x) { " +
+        "  default: x.y.z = {}; " +
+        "  case (x.y = {}): break;" +
+        "}", NAME_DEFINED_LATE_WARNING);
+  }
 }
