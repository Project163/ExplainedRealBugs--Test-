diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
index 2c2e86b7f..ca7a70830 100644
--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
@@ -297,7 +297,6 @@ class PeepholeSubstituteAlternateSyntax
     ImmutableSet.of(
       "Object",
       "Array",
-      "RegExp",
       "Error"
       );
 
@@ -307,26 +306,42 @@ class PeepholeSubstituteAlternateSyntax
   private Node tryFoldStandardConstructors(Node n) {
     Preconditions.checkState(n.isNew());
 
+    if (canFoldStandardConstructors(n)) {
+      n.setType(Token.CALL);
+      n.putBooleanProp(Node.FREE_CALL, true);
+      reportCodeChange();
+    }
+
+    return n;
+  }
+
+  /**
+   * @return Whether "new Object()" can be folded to "Object()" on {@code n}.
+   */
+  private boolean canFoldStandardConstructors(Node n) {
     // If name normalization has been run then we know that
     // new Object() does in fact refer to what we think it is
     // and not some custom-defined Object().
-    if (isASTNormalized()) {
-      if (n.getFirstChild().isName()) {
-        String className = n.getFirstChild().getString();
-        if (STANDARD_OBJECT_CONSTRUCTORS.contains(className)) {
-          n.setType(Token.CALL);
-          n.putBooleanProp(Node.FREE_CALL, true);
-          reportCodeChange();
+    if (isASTNormalized() && n.getFirstChild().isName()) {
+      String className = n.getFirstChild().getString();
+      if (STANDARD_OBJECT_CONSTRUCTORS.contains(className)) {
+        return true;
+      }
+      if ("RegExp".equals(className)) {
+        // Fold "new RegExp()" to "RegExp()", but only if the argument is a string.
+        // See issue 1260.
+        if (n.getChildAtIndex(1) == null || n.getChildAtIndex(1).isString()) {
+          return true;
         }
       }
     }
 
-    return n;
+    return false;
   }
 
   /**
-   * Replaces a new Array or Object node with an object literal, unless the
-   * call to Array or Object is to a local function with the same name.
+   * Replaces a new Array, Object, or RegExp node with a literal, unless the
+   * call is to a local constructor function with the same name.
    */
   private Node tryFoldLiteralConstructor(Node n) {
     Preconditions.checkArgument(n.isCall()
diff --git a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java
index ab521decf..d7fa6d285 100644
--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java
+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java
@@ -101,6 +101,8 @@ public class PeepholeSubstituteAlternateSyntaxTest extends CompilerTestCase {
     // Bogus flags should not fold
     testSame("x = RegExp(\"foobar\", \"bogus\")",
          PeepholeSubstituteAlternateSyntax.INVALID_REGULAR_EXPRESSION_FLAGS);
+    // Don't fold if the argument is not a string. See issue 1260.
+    foldSame("x = new RegExp(y)");
     // Can Fold
     fold("x = new RegExp(\"foobar\")",        "x = /foobar/");
     fold("x = RegExp(\"foobar\")",            "x = /foobar/");
