diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java
index 471ba3795..263f5dad9 100644
--- a/src/com/google/javascript/jscomp/NodeUtil.java
+++ b/src/com/google/javascript/jscomp/NodeUtil.java
@@ -24,6 +24,7 @@ import com.google.common.collect.Maps;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.JSDocInfo;
+import com.google.javascript.rhino.JSDocInfoBuilder;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.TokenStream;
@@ -3440,4 +3441,10 @@ public final class NodeUtil {
         },
         Predicates.<Node>alwaysTrue());
   }
+
+  static JSDocInfo createConstantJsDoc() {
+    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);
+    builder.recordConstancy();
+    return builder.build(null);
+  }
 }
diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java
index cbc2c30cb..93eaf831b 100644
--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java
+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java
@@ -1305,7 +1305,7 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback
         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);
       }
       if (candidateDefinition == null) {
-        name.setJSDocInfo(createConstantJsDoc());
+        name.setJSDocInfo(NodeUtil.createConstantJsDoc());
       }
 
       Preconditions.checkState(isNamespacePlaceholder(decl));
@@ -1339,19 +1339,13 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback
               createNamespaceLiteral()));
       decl.putBooleanProp(Node.IS_NAMESPACE, true);
       if (candidateDefinition == null) {
-        decl.getFirstChild().setJSDocInfo(createConstantJsDoc());
+        decl.getFirstChild().setJSDocInfo(NodeUtil.createConstantJsDoc());
       }
       Preconditions.checkState(isNamespacePlaceholder(decl));
       setSourceInfo(decl);
       return decl;
     }
 
-    private JSDocInfo createConstantJsDoc() {
-      JSDocInfoBuilder builder = new JSDocInfoBuilder(false);
-      builder.recordConstancy();
-      return builder.build(null);
-    }
-
     /**
      * Copy source info to the new node.
      */
diff --git a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java
index 67779577e..c582b824e 100644
--- a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java
+++ b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java
@@ -16,13 +16,17 @@
 package com.google.javascript.jscomp;
 
 import com.google.common.base.Preconditions;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
+import com.google.javascript.jscomp.Scope.Var;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
 
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.util.List;
 import java.util.Set;
 import java.util.regex.Pattern;
 
@@ -45,6 +49,8 @@ public class ProcessCommonJSModules implements CompilerPass {
   private static final String MODULE_NAME_SEPARATOR = "\\$";
   private static final String MODULE_NAME_PREFIX = "module$";
 
+  private static final String EXPORTS = "exports";
+
   private final AbstractCompiler compiler;
   private final String filenamePrefix;
   private final boolean reportDependencies;
@@ -132,7 +138,8 @@ public class ProcessCommonJSModules implements CompilerPass {
       AbstractPostOrderCallback {
 
     private int scriptNodeCount = 0;
-    private Set<String> modulesWithExports = Sets.newHashSet();
+    private List<Node> moduleExportRefs = Lists.newArrayList();
+    private List<Node> exportRefs = Lists.newArrayList();
 
     @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
@@ -149,7 +156,14 @@ public class ProcessCommonJSModules implements CompilerPass {
 
       if (n.isGetProp() &&
           "module.exports".equals(n.getQualifiedName())) {
-        visitModuleExports(n);
+        moduleExportRefs.add(n);
+      }
+
+      if (n.isName() && EXPORTS.equals(n.getString())) {
+        Var v = t.getScope().getVar(n.getString());
+        if (v == null || v.isGlobal()) {
+          exportRefs.add(n);
+        }
       }
     }
 
@@ -181,9 +195,19 @@ public class ProcessCommonJSModules implements CompilerPass {
       Preconditions.checkArgument(scriptNodeCount == 1,
           "ProcessCommonJSModules supports only one invocation per " +
           "CompilerInput / script node");
+
       String moduleName = guessCJSModuleName(script.getSourceFileName());
-      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())
-          .copyInformationFromForTree(script));
+
+      // Rename vars to not conflict in global scope.
+      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(
+          moduleName));
+
+      // Replace all refs to module.exports and exports
+      processExports(script, moduleName);
+      moduleExportRefs.clear();
+      exportRefs.clear();
+
+      // Add goog.provide calls.
       if (reportDependencies) {
         CompilerInput ci = t.getInput();
         ci.addProvide(moduleName);
@@ -195,47 +219,128 @@ public class ProcessCommonJSModules implements CompilerPass {
           IR.call(IR.getprop(IR.name("goog"), IR.string("provide")),
               IR.string(moduleName))).copyInformationFromForTree(script));
 
-      emitOptionalModuleExportsOverride(script, moduleName);
-
-      // Rename vars to not conflict in global scope.
-      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(
-          moduleName));
-
       compiler.reportCodeChange();
     }
 
+
     /**
-     * Emit <code>if (moduleName.module$exports) {
-     *    moduleName = moduleName.module$export;
-     * }</code> at end of file.
+     * Process all references to module.exports and exports.
+     *
+     * In CommonJS systems, module.exports and exports point to
+     * the same object, unless one of them is re-assigned.
+     *
+     * We handle 2 special forms:
+     * 1) Exactly 1 top-level assign to module.exports.
+     *    module.exports = ...;
+     * 2) Direct reads of exports and module.exports.
+     *    This includes assignments to properties of exports,
+     *    because these only read the slot itself.
+     *    module.exports.prop = ...; // 1 or more times.
+     *
+     * We do this so that these forms type-check better.
+     *
+     * All other forms are handled by a more general algorithm.
      */
-    private void emitOptionalModuleExportsOverride(Node script,
-        String moduleName) {
-      if (!modulesWithExports.contains(moduleName)) {
+    private void processExports(Node script, String moduleName) {
+      if (hasOneTopLevelModuleExportAssign()) {
+        // One top-level assign: transform to
+        // /** @const */ var moduleName = rhs
+        Node ref = moduleExportRefs.get(0);
+        Node newName = IR.name(moduleName);
+        newName.putProp(Node.ORIGINALNAME_PROP, ref.getQualifiedName());
+
+        Node newVar = IR.var(newName)
+            .copyInformationFromForTree(ref.getParent());
+        newVar.getFirstChild().addChildToFront(
+            ref.getNext().detachFromParent());
+        newVar.setJSDocInfo(NodeUtil.createConstantJsDoc());
+
+        Node assign = ref.getParent();
+        Node exprResult = assign.getParent();
+        script.replaceChild(exprResult, newVar);
         return;
       }
 
-      Node moduleExportsProp = IR.getprop(IR.name(moduleName),
-          IR.string("module$exports"));
-      script.addChildToBack(IR.ifNode(
-          moduleExportsProp,
-          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),
-              moduleExportsProp.cloneTree())))).copyInformationFromForTree(
-          script));
+      if (!hasExportLValues()) {
+        // Transform to:
+        //
+        // /** @const */ var moduleName = {};
+        // moduleName.prop0 = 0; // etc.
+        //
+        // We consider the 0-ref case a special case of this.
+        Node newVar = injectExportsObject(script, moduleName);
+        newVar.setJSDocInfo(NodeUtil.createConstantJsDoc());
+
+        for (Node ref : Iterables.concat(moduleExportRefs, exportRefs)) {
+          Node newRef = IR.name(moduleName).copyInformationFrom(ref);
+          newRef.putProp(Node.ORIGINALNAME_PROP, ref.getQualifiedName());
+          ref.getParent().replaceChild(ref, newRef);
+        }
+        return;
+      }
+
+      // The general case:
+      // At the beginning, add the stanza:
+      // var moduleName = {}; var moduleName$$exports = moduleName;
+      // Transform module.exports to moduleName
+      // Transform exports to moduleName$$exports
+      Node exportsNode = injectExportsObject(script, moduleName);
+
+      for (Node ref : moduleExportRefs) {
+        Node newRef = IR.name(moduleName).copyInformationFrom(ref);
+        ref.getParent().replaceChild(ref, newRef);
+      }
+
+      if (!exportRefs.isEmpty()) {
+        String aliasName = "exports$$" + moduleName;
+        Node aliasNode = IR.var(IR.name(aliasName), IR.name(moduleName))
+            .copyInformationFromForTree(script);
+        script.addChildAfter(aliasNode, exportsNode);
+
+        for (Node ref : exportRefs) {
+          ref.putProp(Node.ORIGINALNAME_PROP, ref.getString());
+          ref.setString(aliasName);
+        }
+      }
+    }
+
+    /**
+     * Creates an exports object for this module.
+     * var moduleName = {};
+     */
+    private Node injectExportsObject(Node script, String moduleName) {
+      Node varNode = IR.var(IR.name(moduleName), IR.objectlit())
+          .copyInformationFromForTree(script);
+      script.addChildToFront(varNode);
+      return varNode;
+    }
+
+    /**
+     * Recognize export pattern [1] (see above).
+     */
+    private boolean hasOneTopLevelModuleExportAssign() {
+      return moduleExportRefs.size() == 1 &&
+          exportRefs.isEmpty() &&
+          isTopLevelAssignLhs(moduleExportRefs.get(0));
+    }
+
+    private boolean isTopLevelAssignLhs(Node n) {
+      Node parent = n.getParent();
+      return parent.isAssign() && n == parent.getFirstChild() &&
+          parent.getParent().isExprResult() &&
+          parent.getParent().getParent().isScript();
     }
 
     /**
-     * Rewrite module.exports to moduleName.module$exports.
+     * Recognize the opposite of export pattern [2] (see above).
      */
-    private void visitModuleExports(Node prop) {
-      String moduleName = guessCJSModuleName(prop.getSourceFileName());
-      Node module = prop.getChildAtIndex(0);
-      module.putProp(Node.ORIGINALNAME_PROP, "module");
-      module.setString(moduleName);
-      Node exports = prop.getChildAtIndex(1);
-      exports.putProp(Node.ORIGINALNAME_PROP, "exports");
-      exports.setString("module$exports");
-      modulesWithExports.add(moduleName);
+    private boolean hasExportLValues() {
+      for (Node ref : Iterables.concat(moduleExportRefs, exportRefs)) {
+        if (NodeUtil.isLValue(ref)) {
+          return true;
+        }
+      }
+      return false;
     }
 
     /**
@@ -255,9 +360,6 @@ public class ProcessCommonJSModules implements CompilerPass {
    * Traverses a node tree and appends a suffix to all global variable names.
    */
   private class SuffixVarsCallback extends AbstractPostOrderCallback {
-
-    private static final String EXPORTS = "exports";
-
     private final String suffix;
 
     SuffixVarsCallback(String suffix) {
@@ -271,15 +373,16 @@ public class ProcessCommonJSModules implements CompilerPass {
         if (suffix.equals(name)) {
           return;
         }
+
+        // refs to 'exports' are handled separately.
         if (EXPORTS.equals(name)) {
-          n.setString(suffix);
-          n.putProp(Node.ORIGINALNAME_PROP, EXPORTS);
-        } else {
-          Scope.Var var = t.getScope().getVar(name);
-          if (var != null && var.isGlobal()) {
-            n.setString(name + "$$" + suffix);
-            n.putProp(Node.ORIGINALNAME_PROP, name);
-          }
+          return;
+        }
+
+        Scope.Var var = t.getScope().getVar(name);
+        if (var != null && var.isGlobal()) {
+          n.setString(name + "$$" + suffix);
+          n.putProp(Node.ORIGINALNAME_PROP, name);
         }
       }
     }
diff --git a/src/com/google/javascript/jscomp/TransformAMDToCJSModule.java b/src/com/google/javascript/jscomp/TransformAMDToCJSModule.java
index 7a27bf765..4784d9b0b 100644
--- a/src/com/google/javascript/jscomp/TransformAMDToCJSModule.java
+++ b/src/com/google/javascript/jscomp/TransformAMDToCJSModule.java
@@ -134,15 +134,20 @@ class TransformAMDToCJSModule implements CompilerPass {
     }
 
     /**
-     * When define is called with an object literal, assign it to exports and
+     * When define is called with an object literal, assign it to module.exports and
      * we're done.
      */
     private void handleDefineObjectLiteral(Node parent, Node onlyExport,
         Node script) {
       onlyExport.getParent().removeChild(onlyExport);
       script.replaceChild(parent,
-          IR.exprResult(IR.assign(IR.name("exports"), onlyExport))
-              .copyInformationFromForTree(onlyExport));
+          IR.exprResult(
+              IR.assign(
+                  NodeUtil.newQualifiedNameNode(
+                      compiler.getCodingConvention(),
+                      "module.exports"),
+                  onlyExport))
+          .copyInformationFromForTree(onlyExport));
       compiler.reportCodeChange();
     }
 
diff --git a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
index 5eb352338..e1e8173b0 100644
--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
@@ -1160,7 +1160,7 @@ public class CommandLineRunnerTest extends TestCase {
 
   public void testTransformAMD() {
     args.add("--transform_amd_modules");
-    test("define({test: 1})", "exports = {test: 1}");
+    test("define({test: 1})", "module.exports = {test: 1}");
   }
 
   public void testProcessCJS() {
@@ -1201,7 +1201,7 @@ public class CommandLineRunnerTest extends TestCase {
     args.add("--common_js_entry_module=foo/bar");
     setFilename(0, "foo/bar.js");
     test("define({foo: 1})",
-        "var module$foo$bar={},module$foo$bar={foo:1};");
+        "var module$foo$bar={foo:1};");
   }
 
   public void testModuleJSON() {
@@ -1212,7 +1212,7 @@ public class CommandLineRunnerTest extends TestCase {
     args.add("--output_module_dependencies=test.json");
     setFilename(0, "foo/bar.js");
     test("define({foo: 1})",
-        "var module$foo$bar={},module$foo$bar={foo:1};");
+        "var module$foo$bar={foo:1};");
   }
 
   public void testOutputSameAsInput() {
diff --git a/test/com/google/javascript/jscomp/CommonJSIntegrationTest.java b/test/com/google/javascript/jscomp/CommonJSIntegrationTest.java
new file mode 100644
index 000000000..28db55018
--- /dev/null
+++ b/test/com/google/javascript/jscomp/CommonJSIntegrationTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2013 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+/**
+ * Tests for type-checking across commonjs modules.
+ *
+ * @author nicholas.j.santos@gmail.com (Nick Santos)
+ */
+public class CommonJSIntegrationTest extends IntegrationTestCase {
+  public void testCrossModuleCtorCall() {
+    test(createCompilerOptions(),
+         new String[] {
+           "/** @constructor */ function Hello() {} " +
+           "module.exports = Hello;",
+
+           "var Hello = require('./i0');" +
+           "var hello = new Hello();"
+         },
+         new String[] {
+           "function Hello$$module$i0(){}" +
+           "var module$i0 = Hello$$module$i0;",
+
+           "var module$i1 = {};" +
+           "var Hello$$module$i1 = module$i0;" +
+           "var hello$$module$i1 = new Hello$$module$i1();"
+         });
+  }
+
+  public void testCrossModuleCtorCall2() {
+    test(createCompilerOptions(),
+         new String[] {
+           "/** @constructor */ function Hello() {} " +
+           "module.exports = Hello;",
+
+           "var Hello = require('./i0');" +
+           "var hello = new Hello(1);"
+         },
+         TypeCheck.WRONG_ARGUMENT_COUNT);
+  }
+
+  @Override
+  protected CompilerOptions createCompilerOptions() {
+    CompilerOptions options = new CompilerOptions();
+    options.setCodingConvention(new GoogleCodingConvention());
+    WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
+    options.processCommonJSModules = true;
+    options.closurePass = true;
+    return options;
+  }
+}
diff --git a/test/com/google/javascript/jscomp/IntegrationTestCase.java b/test/com/google/javascript/jscomp/IntegrationTestCase.java
index 955eaadb3..543daafef 100644
--- a/test/com/google/javascript/jscomp/IntegrationTestCase.java
+++ b/test/com/google/javascript/jscomp/IntegrationTestCase.java
@@ -92,7 +92,7 @@ abstract class IntegrationTestCase extends TestCase {
         0, compiler.getErrors().length + compiler.getWarnings().length);
 
     Node root = compiler.getRoot().getLastChild();
-    Node expectedRoot = parse(compiled, options, normalizeResults);
+    Node expectedRoot = parseExpectedCode(compiled, options, normalizeResults);
     String explanation = expectedRoot.checkTreeEquals(root);
     assertNull("\nExpected: " + compiler.toSource(expectedRoot) +
         "\nResult: " + compiler.toSource(root) +
@@ -137,7 +137,7 @@ abstract class IntegrationTestCase extends TestCase {
 
     if (compiled != null) {
       Node root = compiler.getRoot().getLastChild();
-      Node expectedRoot = parse(compiled, options, normalizeResults);
+      Node expectedRoot = parseExpectedCode(compiled, options, normalizeResults);
       String explanation = expectedRoot.checkTreeEquals(root);
       assertNull("\nExpected: " + compiler.toSource(expectedRoot) +
           "\nResult: " + compiler.toSource(root) +
@@ -156,7 +156,7 @@ abstract class IntegrationTestCase extends TestCase {
 
     if (compiled != null) {
       Node root = compiler.getRoot().getLastChild();
-      Node expectedRoot = parse(compiled, options, normalizeResults);
+      Node expectedRoot = parseExpectedCode(compiled, options, normalizeResults);
       String explanation = expectedRoot.checkTreeEquals(root);
       assertNull("\nExpected: " + compiler.toSource(expectedRoot) +
           "\nResult: " + compiler.toSource(root) +
@@ -196,6 +196,21 @@ abstract class IntegrationTestCase extends TestCase {
     return compiler;
   }
 
+  /**
+   * Parse the expected code to compare against.
+   * We want to run this with similar parsing options, but don't
+   * want to run the commonjs preprocessing passes (so that we can use this
+   * to test the commonjs code).
+   */
+  protected Node parseExpectedCode(
+      String[] original, CompilerOptions options, boolean normalize) {
+    boolean oldProcessCommonJsModules = options.processCommonJSModules;
+    options.processCommonJSModules = false;
+    Node expectedRoot = parse(original, options, normalize);
+    options.processCommonJSModules = oldProcessCommonJsModules;
+    return expectedRoot;
+  }
+
   protected Node parse(
       String[] original, CompilerOptions options, boolean normalize) {
     Compiler compiler = new Compiler();
diff --git a/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java b/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java
index fc1dc556d..bf515a8f1 100644
--- a/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java
+++ b/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java
@@ -66,7 +66,7 @@ public class ProcessCommonJSModulesTest extends CompilerTestCase {
         "var name = require('name');" +
         "exports.foo = 1;",
         "goog.provide('module$test');" +
-        "var module$test = {};" +
+        "/** @const */ var module$test = {};" +
         "goog.require('module$name');" +
         "var name$$module$test = module$name;" +
         "module$test.foo = 1;");
@@ -74,12 +74,34 @@ public class ProcessCommonJSModulesTest extends CompilerTestCase {
         "var name = require('name');" +
         "module.exports = function() {};",
         "goog.provide('module$test');" +
-        "var module$test = {};" +
         "goog.require('module$name');" +
         "var name$$module$test = module$name;" +
-        "module$test.module$exports = function() {};" +
-        "if(module$test.module$exports)" +
-        "module$test=module$test.module$exports");
+        "/** @const */ var module$test = function () {};");
+  }
+
+  public void testPropertyExports() {
+    setFilename("test");
+    test(
+        "exports.one = 1;" +
+        "module.exports.obj = {};" +
+        "module.exports.obj.two = 2;",
+        "goog.provide('module$test');" +
+        "/** @const */ var module$test = {};" +
+        "module$test.one = 1;" +
+        "module$test.obj = {};" +
+        "module$test.obj.two = 2;");
+  }
+
+  public void testModuleExportsWrittenWithExportsRefs() {
+    setFilename("test");
+    test(
+        "exports.one = 1;" +
+        "module.exports = {};",
+        "goog.provide('module$test');" +
+        "var module$test = {};" +
+        "var exports$$module$test = module$test;" +
+        "exports$$module$test.one = 1;" +
+        "module$test = {};");
   }
 
   public void testVarRenaming() {
diff --git a/test/com/google/javascript/jscomp/TransformAMDToCJSModuleTest.java b/test/com/google/javascript/jscomp/TransformAMDToCJSModuleTest.java
index b6bc065d4..e428a0237 100644
--- a/test/com/google/javascript/jscomp/TransformAMDToCJSModuleTest.java
+++ b/test/com/google/javascript/jscomp/TransformAMDToCJSModuleTest.java
@@ -77,7 +77,7 @@ public class TransformAMDToCJSModuleTest extends CompilerTestCase {
   }
 
   public void testObjectLit() {
-    test("define({foo: 'bar'})", "exports={foo: 'bar'}");
+    test("define({foo: 'bar'})", "module.exports={foo: 'bar'}");
   }
 
   public void testPlugins() {
