diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java
index 7c498e6be..168179a16 100644
--- a/src/com/google/javascript/jscomp/CodeGenerator.java
+++ b/src/com/google/javascript/jscomp/CodeGenerator.java
@@ -341,7 +341,7 @@ class CodeGenerator {
           if (!Double.isNaN(d)) {
             cc.addNumber(d);
           } else {
-            addJsString(n.getString());
+            addJsString(n);
           }
         }
 
@@ -633,7 +633,7 @@ class CodeGenerator {
           throw new IllegalStateException(
               "Unexpected String children: " + n.getParent().toStringTree());
         }
-        addJsString(n.getString());
+        addJsString(n);
         break;
 
       case Token.DELPROP:
@@ -937,16 +937,22 @@ class CodeGenerator {
   }
 
   /** Outputs a js string, using the optimal (single/double) quote character */
-  void addJsString(String s) {
-    String cached = ESCAPED_JS_STRINGS.get(s);
-    if (cached == null) {
-      cached = jsString(s);
-      ESCAPED_JS_STRINGS.put(s, cached);
+  private void addJsString(Node n) {
+    String s = n.getString();
+    boolean useSlashV = n.getBooleanProp(Node.SLASH_V);
+    if (useSlashV) {
+      add(jsString(n.getString(), useSlashV));
+    } else {
+      String cached = ESCAPED_JS_STRINGS.get(s);
+      if (cached == null) {
+        cached = jsString(n.getString(), useSlashV);
+        ESCAPED_JS_STRINGS.put(s, cached);
+      }
+      add(cached);
     }
-    add(cached);
   }
 
-  String jsString(String s) {
+  private String jsString(String s, boolean useSlashV) {
     int singleq = 0, doubleq = 0;
 
     // could count the quotes and pick the optimal quote character
@@ -972,19 +978,19 @@ class CodeGenerator {
     }
 
     return strEscape(s, quote, doublequote, singlequote, "\\\\",
-        outputCharsetEncoder);
+        outputCharsetEncoder, useSlashV);
   }
 
   /** Escapes regular expression */
   static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {
-    return strEscape(s, '/', "\"", "'", "\\", outputCharsetEncoder);
+    return strEscape(s, '/', "\"", "'", "\\", outputCharsetEncoder, false);
   }
 
   /**
    * Escapes the given string to a double quoted (") JavaScript/JSON string
    */
   static String escapeToDoubleQuotedJsString(String s) {
-    return strEscape(s, '"',  "\\\"", "\'", "\\\\", null);
+    return strEscape(s, '"',  "\\\"", "\'", "\\\\", null, false);
   }
 
   /* If the user doesn't want to specify an output charset encoder, assume
@@ -995,17 +1001,26 @@ class CodeGenerator {
   }
 
   /** Helper to escape javascript string as well as regular expression */
-  static String strEscape(String s, char quote,
-                          String doublequoteEscape,
-                          String singlequoteEscape,
-                          String backslashEscape,
-                          CharsetEncoder outputCharsetEncoder) {
+  private static String strEscape(
+      String s, char quote,
+      String doublequoteEscape,
+      String singlequoteEscape,
+      String backslashEscape,
+      CharsetEncoder outputCharsetEncoder,
+      boolean useSlashV) {
     StringBuilder sb = new StringBuilder(s.length() + 2);
     sb.append(quote);
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\0': sb.append("\\x00"); break;
+        case '\u000B':
+          if (useSlashV) {
+            sb.append("\\v");
+          } else {
+            sb.append("\\x0B");
+          }
+          break;
         case '\n': sb.append("\\n"); break;
         case '\r': sb.append("\\r"); break;
         case '\t': sb.append("\\t"); break;
diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java
index 11cc12db4..e7195b79f 100644
--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java
+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java
@@ -1038,20 +1038,25 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {
         if (Token.STRING != right.getType()) {
           return n;  // Only eval if they are the same type
         }
+
+        TernaryValue ternary = TernaryValue.UNKNOWN;
         switch (op) {
           case Token.SHEQ:
           case Token.EQ:
-            result = left.getString().equals(right.getString());
+            ternary = areStringsEqual(left.getString(), right.getString());
             break;
 
           case Token.SHNE:
           case Token.NE:
-            result = !left.getString().equals(right.getString());
+            ternary =
+                areStringsEqual(left.getString(), right.getString()).not();
             break;
+        }
 
-          default:
-            return n;  // we only handle == and != here
+        if (ternary == TernaryValue.UNKNOWN) {
+          return n;
         }
+        result = ternary.toBoolean(true);
         break;
 
       case Token.NUMBER:
@@ -1156,6 +1161,18 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {
     return newNode;
   }
 
+  /** Returns whether two JS strings are equal. */
+  private TernaryValue areStringsEqual(String a, String b) {
+    // In JS, browsers parse \v differently. So do not consider strings
+    // equal if one containts \v.
+    if (a.indexOf('\u000B') != -1 ||
+        b.indexOf('\u000B') != -1) {
+      return TernaryValue.UNKNOWN;
+    } else {
+      return a.equals(b) ? TernaryValue.TRUE : TernaryValue.FALSE;
+    }
+  }
+
   /**
    * @return Translate NOT expressions into TRUE or FALSE when possible.
    */
diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java
index c0bf8f4bf..53d8ba543 100644
--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java
+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java
@@ -854,7 +854,30 @@ class IRFactory {
 
     @Override
     Node processStringLiteral(StringLiteral literalNode) {
-      Node n = newStringNode(literalNode.getValue());
+      String value = literalNode.getValue();
+      Node n = newStringNode(value);
+      if (value.indexOf('\u000B') != -1) {
+        // NOTE(nicksantos): In JavaScript, there are 3 ways to
+        // represent a vertical tab: \v, \x0B, \u000B.
+        // The \v notation was added later, and is not understood
+        // on IE. So we need to preserve it as-is. This is really
+        // obnoxious, because we do not have a good way to represent
+        // how the original string was encoded without making the
+        // representation of strings much more complicated.
+        //
+        // To handle this, we look at the original source test, and
+        // mark the string as \v-encoded or not. If a string is
+        // \v encoded, then all the vertical tabs in that string
+        // will be encoded with a \v.
+        int start = literalNode.getAbsolutePosition();
+        int end = start + literalNode.getLength();
+        if (start < sourceString.length() &&
+            (sourceString.substring(
+                 start, Math.min(sourceString.length(), end))
+             .indexOf("\\v") != -1)) {
+          n.putBooleanProp(Node.SLASH_V, true);
+        }
+      }
       return n;
     }
 
diff --git a/src/com/google/javascript/rhino/Node.java b/src/com/google/javascript/rhino/Node.java
index 1ed9845c2..05c2eeeb3 100644
--- a/src/com/google/javascript/rhino/Node.java
+++ b/src/com/google/javascript/rhino/Node.java
@@ -104,7 +104,10 @@ public class Node implements Cloneable, Serializable {
                                   // this node.
       INPUT_ID           = 53,    // The id of the input associated with this
                                   // node.
-      LAST_PROP          = 53;
+      SLASH_V            = 54,    // Whether a STRING node contains a \v
+                                  // vertical tab escape. This is a total hack.
+                                  // See comments in IRFactory about this.
+      LAST_PROP          = 54;
 
   public static final int   // flags for INCRDECR_PROP
       DECR_FLAG = 0x1,
@@ -1499,6 +1502,12 @@ public class Node implements Cloneable, Serializable {
       if (quoted1 != quoted2) {
         return false;
       }
+
+      int slashV1 = this.getIntProp(SLASH_V);
+      int slashV2 = node.getIntProp(SLASH_V);
+      if (slashV1 != slashV2) {
+        return false;
+      }
     } else if (type == Token.CALL) {
       if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {
         return false;
diff --git a/test/com/google/javascript/jscomp/CodePrinterTest.java b/test/com/google/javascript/jscomp/CodePrinterTest.java
index 181935405..f64be7a5f 100644
--- a/test/com/google/javascript/jscomp/CodePrinterTest.java
+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java
@@ -1272,4 +1272,10 @@ public class CodePrinterTest extends TestCase {
   public void testIssue582() {
     assertPrint("var x = -0.0;", "var x=-0.0");
   }
+
+  public void testIssue601() {
+    assertPrint("'\\v' == 'v'", "\"\\v\"==\"v\"");
+    assertPrint("'\\u000B' == '\\v'", "\"\\x0B\"==\"\\v\"");
+    assertPrint("'\\x0B' == '\\v'", "\"\\x0B\"==\"\\v\"");
+  }
 }
diff --git a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
index c7696495e..eaa473758 100644
--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
@@ -386,6 +386,24 @@ public class CommandLineRunnerTest extends TestCase {
          "alert('hi');", CheckSideEffects.USELESS_CODE_ERROR);
   }
 
+  public void testIssue601() {
+    args.add("--compilation_level=WHITESPACE_ONLY");
+    test("function f() { return '\\v' == 'v'; } window['f'] = f;",
+         "function f(){return'\\v'=='v'}window['f']=f");
+  }
+
+  public void testIssue601b() {
+    args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
+    test("function f() { return '\\v' == 'v'; } window['f'] = f;",
+         "window.f=function(){return'\\v'=='v'}");
+  }
+
+  public void testIssue601c() {
+    args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
+    test("function f() { return '\\u000B' == 'v'; } window['f'] = f;",
+         "window.f=function(){return'\\u000B'=='v'}");
+  }
+
   public void testDebugFlag1() {
     args.add("--compilation_level=SIMPLE_OPTIMIZATIONS");
     args.add("--debug=false");
diff --git a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
index 5bf4ef3f4..62adce266 100644
--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
@@ -1056,6 +1056,12 @@ public class PeepholeFoldConstantsTest extends CompilerTestCase {
     testSame("(![foo()])");
   }
 
+  public void testIssue601() {
+    testSame("'\\v' == 'v'");
+    testSame("'v' == '\\v'");
+    testSame("'\\u000B' == '\\v'");
+  }
+
   public void testFoldObjectLiteralRef1() {
     // Leave extra side-effects in place
     testSame("var x = ({a:foo(),b:bar()}).a");
diff --git a/test/com/google/javascript/rhino/NodeTest.java b/test/com/google/javascript/rhino/NodeTest.java
index 4d77fe497..368b2596d 100644
--- a/test/com/google/javascript/rhino/NodeTest.java
+++ b/test/com/google/javascript/rhino/NodeTest.java
@@ -116,6 +116,13 @@ public class NodeTest extends TestCase {
     assertEquals(false, node1.isEquivalentTo(node2));
   }
 
+  public void testCheckTreeEqualsSlashVDifferent() {
+    Node node1 = Node.newString("\u000B");
+    node1.putBooleanProp(Node.SLASH_V, true);
+    Node node2 = Node.newString("\u000B");
+    assertEquals(false, node1.isEquivalentTo(node2));
+  }
+
   public void testCheckTreeEqualsImplDifferentIncProp() {
     Node node1 = new Node(Token.INC);
     node1.putIntProp(Node.INCRDECR_PROP, 1);
