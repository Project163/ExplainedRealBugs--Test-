diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java
index d3d4baed9..72dfe91b7 100644
--- a/src/com/google/javascript/jscomp/TypeCheck.java
+++ b/src/com/google/javascript/jscomp/TypeCheck.java
@@ -29,6 +29,8 @@ import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
+import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;
+import com.google.javascript.jscomp.CodingConvention.SubclassType;
 import com.google.javascript.jscomp.Scope.Var;
 import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
 import com.google.javascript.rhino.JSDocInfo;
@@ -1767,6 +1769,28 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {
     }
   }
 
+  /**
+   * Validate class-defining calls.
+   * Because JS has no 'native' syntax for defining classes, we need
+   * to do this manually.
+   */
+  private void checkCallConventions(NodeTraversal t, Node n) {
+    SubclassRelationship relationship =
+        compiler.getCodingConvention().getClassesDefinedByCall(n);
+    Scope scope = t.getScope();
+    if (relationship != null) {
+      ObjectType superClass = TypeValidator.getInstanceOfCtor(
+          scope.getVar(relationship.superclassName));
+      ObjectType subClass = TypeValidator.getInstanceOfCtor(
+          scope.getVar(relationship.subclassName));
+      if (relationship.type == SubclassType.INHERITS &&
+          superClass != null && !superClass.isEmptyType() &&
+          subClass != null && !subClass.isEmptyType()) {
+        validator.expectSuperType(t, n, superClass, subClass);
+      }
+    }
+  }
+
   /**
    * Visits a CALL node.
    *
@@ -1775,6 +1799,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {
    * @param n The node being visited.
    */
   private void visitCall(NodeTraversal t, Node n) {
+    checkCallConventions(t, n);
+
     Node child = n.getFirstChild();
     JSType childType = getJSType(child).restrictByNotNullOrUndefined();
 
diff --git a/src/com/google/javascript/jscomp/TypeValidator.java b/src/com/google/javascript/jscomp/TypeValidator.java
index 92a5de50d..2f65c5861 100644
--- a/src/com/google/javascript/jscomp/TypeValidator.java
+++ b/src/com/google/javascript/jscomp/TypeValidator.java
@@ -47,6 +47,8 @@ import java.text.MessageFormat;
 import java.util.Iterator;
 import java.util.List;
 
+import javax.annotation.Nullable;
+
 /**
  * A central reporter for all type violations: places where the programmer
  * has annotated a variable (or property) with one type, but has assigned
@@ -153,6 +155,27 @@ class TypeValidator {
         DiagnosticGroups.UNNECESSARY_CASTS);
   }
 
+  /**
+   * Utility function for getting a function type from a var.
+   */
+  static FunctionType getFunctionType(@Nullable Var v) {
+    JSType t = v == null ? null : v.getType();
+    ObjectType o = t == null ? null : t.dereference();
+    return JSType.toMaybeFunctionType(o);
+  }
+
+  /**
+   * Utility function for getting an instance type from a var pointing
+   * to the constructor.
+   */
+  static ObjectType getInstanceOfCtor(@Nullable Var v) {
+    FunctionType ctor = getFunctionType(v);
+    if (ctor != null && ctor.isConstructor()) {
+      return ctor.getInstanceType();
+    }
+    return null;
+  }
+
   /**
    * Gets a list of type violations.
    *
diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java
index ab9ee0112..6757d7327 100644
--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java
+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java
@@ -55,7 +55,6 @@ import com.google.common.collect.Multiset;
 import com.google.javascript.jscomp.CodingConvention.DelegateRelationship;
 import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;
 import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;
-import com.google.javascript.jscomp.CodingConvention.SubclassType;
 import com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents;
 import com.google.javascript.jscomp.NodeTraversal.AbstractScopedCallback;
 import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;
@@ -860,10 +859,7 @@ final class TypedScopeCreator implements ScopeCreator {
         @Nullable String name,
         @Nullable JSDocInfo info,
         @Nullable Node lvalueNode) {
-
       FunctionType functionType = null;
-
-      // Global ctor aliases should be registered with the type registry.
       if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {
         Var var = scope.getVar(rValue.getQualifiedName());
         if (var != null && var.getType() != null &&
@@ -873,6 +869,8 @@ final class TypedScopeCreator implements ScopeCreator {
               !aliasedType.isNativeObjectType()) {
             functionType = aliasedType;
 
+            // TODO(nick): Remove this. This should already be handled by
+            // normal type resolution.
             if (name != null && scope.isGlobal()) {
               typeRegistry.declareType(name, functionType.getInstanceType());
             }
@@ -1407,12 +1405,6 @@ final class TypedScopeCreator implements ScopeCreator {
       return null;
     }
 
-    private FunctionType getFunctionType(@Nullable Var v) {
-      JSType t = v == null ? null : v.getType();
-      ObjectType o = t == null ? null : t.dereference();
-      return JSType.toMaybeFunctionType(o);
-    }
-
     /**
      * Look for calls that set a delegate method's calling convention.
      */
@@ -1431,26 +1423,16 @@ final class TypedScopeCreator implements ScopeCreator {
       SubclassRelationship relationship =
           codingConvention.getClassesDefinedByCall(n);
       if (relationship != null) {
-        FunctionType superCtor = getFunctionType(
+        ObjectType superClass = TypeValidator.getInstanceOfCtor(
             scope.getVar(relationship.superclassName));
-        FunctionType subCtor = getFunctionType(
+        ObjectType subClass = TypeValidator.getInstanceOfCtor(
             scope.getVar(relationship.subclassName));
-        if (superCtor != null && superCtor.isConstructor() &&
-            subCtor != null && subCtor.isConstructor()) {
-          ObjectType superClass = superCtor.getInstanceType();
-          ObjectType subClass = subCtor.getInstanceType();
-
+        if (superClass != null && subClass != null) {
           // superCtor and subCtor might be structural constructors
           // (like {function(new:Object)}) so we need to resolve them back
           // to the original ctor objects.
-          superCtor = superClass.getConstructor();
-          subCtor = subClass.getConstructor();
-
-          if (relationship.type == SubclassType.INHERITS &&
-              !superClass.isEmptyType() && !subClass.isEmptyType()) {
-            validator.expectSuperType(t, n, superClass, subClass);
-          }
-
+          FunctionType superCtor = superClass.getConstructor();
+          FunctionType subCtor = subClass.getConstructor();
           if (superCtor != null && subCtor != null) {
             codingConvention.applySubclassRelationship(
                 superCtor, subCtor, relationship.type);
diff --git a/test/com/google/javascript/jscomp/CommonJSIntegrationTest.java b/test/com/google/javascript/jscomp/CommonJSIntegrationTest.java
index 3a766252a..948c8d5fb 100644
--- a/test/com/google/javascript/jscomp/CommonJSIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/CommonJSIntegrationTest.java
@@ -95,6 +95,56 @@ public class CommonJSIntegrationTest extends IntegrationTestCase {
          TypeValidator.TYPE_MISMATCH_WARNING);
   }
 
+  public void testCrossModuleSubclass1() {
+    test(createCompilerOptions(),
+         new String[] {
+           "/** @constructor */ function Hello() {} " +
+           "module.exports = Hello;",
+           "/** @const */ var Hello = require('./i0');" +
+           "var util = {inherits: function (x, y){}};" +
+           "/**\n" +
+           " * @constructor\n" +
+           " * @extends {Hello}\n" +
+           " */\n" +
+           "var SubHello = function () {};" +
+           "util.inherits(SubHello, Hello);"
+         },
+         new String[] {
+           "function Hello$$module$i0(){}" +
+           "var module$i0=Hello$$module$i0;",
+           "var module$i1={};" +
+           "var Hello$$module$i1=module$i0;" +
+           "var util$$module$i1={inherits:function(x,y){}};" +
+           "var SubHello$$module$i1=function(){};" +
+           "util$$module$i1.inherits(SubHello$$module$i1,Hello$$module$i1);"
+         });
+  }
+
+  public void testCrossModuleSubclass2() {
+    test(createCompilerOptions(),
+         new String[] {
+           "/** @constructor */ function Hello() {} " +
+           "module.exports = Hello;",
+           "/** @const */ var Hello = require('./i0');" +
+           "var util = {inherits: function (x, y){}};" +
+           "/**\n" +
+           " * @constructor\n" +
+           " * @extends {Hello}\n" +
+           " */\n" +
+           "function SubHello() {}" +
+           "util.inherits(SubHello, Hello);"
+         },
+         new String[] {
+           "function Hello$$module$i0(){}" +
+           "var module$i0=Hello$$module$i0;",
+           "var module$i1={};" +
+           "var Hello$$module$i1=module$i0;" +
+           "var util$$module$i1={inherits:function(x,y){}};" +
+           "function SubHello$$module$i1(){}" +
+           "util$$module$i1.inherits(SubHello$$module$i1,Hello$$module$i1);"
+         });
+  }
+
   @Override
   protected CompilerOptions createCompilerOptions() {
     CompilerOptions options = new CompilerOptions();
