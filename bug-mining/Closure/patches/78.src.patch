diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java
index e0261398e..8cdbf44b7 100644
--- a/src/com/google/javascript/jscomp/NodeUtil.java
+++ b/src/com/google/javascript/jscomp/NodeUtil.java
@@ -152,7 +152,7 @@ public final class NodeUtil {
    * <code>String()</code> JavaScript cast function.
    */
   static String getStringValue(Node n) {
-    // TODO(user): Convert constant array, object, and regex literals as well.
+    // TODO(user): regex literals as well.
     switch (n.getType()) {
       case Token.STRING:
         return n.getString();
@@ -191,10 +191,58 @@ public final class NodeUtil {
           return child.toBoolean(true) ? "false" : "true"; // reversed.
         }
         break;
+
+      case Token.ARRAYLIT:
+        return arrayToString(n);
+
+      case Token.OBJECTLIT:
+        return "[object Object]";
     }
     return null;
   }
 
+  /**
+   * When converting arrays to string using Array.prototype.toString or
+   * Array.prototype.join, the rules for conversion to String are different
+   * than converting each element individually.  Specifically, "null" and
+   * "undefined" are converted to an empty string.
+   * @param n A node that is a member of an Array.
+   * @return The string representation.
+   */
+  static String getArrayElementStringValue(Node n) {
+    return NodeUtil.isNullOrUndefined(n) ? "" : getStringValue(n);
+  }
+
+  static String arrayToString(Node literal) {
+    Node first = literal.getFirstChild();
+    int[] skipIndexes = (int[]) literal.getProp(Node.SKIP_INDEXES_PROP);
+    StringBuilder result = new StringBuilder();
+    int nextSlot = 0;
+    int nextSkipSlot = 0;
+    for (Node n = first; n != null; n = n.getNext()) {
+      while (skipIndexes != null && nextSkipSlot < skipIndexes.length) {
+        if (nextSlot == skipIndexes[nextSkipSlot]) {
+          result.append(',');
+          nextSlot++;
+          nextSkipSlot++;
+        } else {
+          break;
+        }
+      }
+      String childValue = getArrayElementStringValue(n);
+      if (childValue == null) {
+        return null;
+      }
+      if (n != first) {
+        result.append(',');
+      }
+      result.append(childValue);
+
+      nextSlot++;
+    }
+    return result.toString();
+  }
+
   /**
    * Gets the value of a node as a Number, or null if it cannot be converted.
    * When it returns a non-null Double, this method effectively emulates the
@@ -248,47 +296,56 @@ public final class NodeUtil {
         break;
 
       case Token.STRING:
-        String s = trimJsWhiteSpace(n.getString());
-        // return ScriptRuntime.toNumber(s);
-        if (s.length() == 0) {
-          return 0.0;
-        }
+        return getStringNumberValue(n.getString());
 
-        if (s.length() > 2
-            && s.charAt(0) == '0'
-            && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
-          // Attempt to convert hex numbers.
-          try {
-            return Double.valueOf(Integer.parseInt(s.substring(2), 16));
-          } catch (NumberFormatException e) {
-            return Double.NaN;
-          }
-        }
+      case Token.ARRAYLIT:
+      case Token.OBJECTLIT:
+        String value = getStringValue(n);
+        return value != null ? getStringNumberValue(value) : null;
+    }
 
-        if (s.length() > 3
-            && (s.charAt(0) == '-' || s.charAt(0) == '+')
-            && s.charAt(1) == '0'
-            && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
-          // hex numbers with explicit signs vary between browsers.
-          return null;
-        }
+    return null;
+  }
 
-        // FireFox and IE treat the "Infinity" differently. FireFox is case
-        // insensitive, but IE treats "infinity" as NaN.  So leave it alone.
-        if (s.equals("infinity")
-            || s.equals("-infinity")
-            || s.equals("+infinity")) {
-          return null;
-        }
+  static Double getStringNumberValue(String rawJsString) {
+    String s = trimJsWhiteSpace(rawJsString);
+    // return ScriptRuntime.toNumber(s);
+    if (s.length() == 0) {
+      return 0.0;
+    }
 
-        try {
-          return Double.parseDouble(s);
-        } catch (NumberFormatException e) {
-          return Double.NaN;
-        }
+    if (s.length() > 2
+        && s.charAt(0) == '0'
+        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
+      // Attempt to convert hex numbers.
+      try {
+        return Double.valueOf(Integer.parseInt(s.substring(2), 16));
+      } catch (NumberFormatException e) {
+        return Double.NaN;
+      }
     }
 
-    return null;
+    if (s.length() > 3
+        && (s.charAt(0) == '-' || s.charAt(0) == '+')
+        && s.charAt(1) == '0'
+        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
+      // hex numbers with explicit signs vary between browsers.
+      return null;
+    }
+
+    // FireFox and IE treat the "Infinity" differently. FireFox is case
+    // insensitive, but IE treats "infinity" as NaN.  So leave it alone.
+    if (s.equals("infinity")
+        || s.equals("-infinity")
+        || s.equals("+infinity")) {
+      return null;
+    }
+
+    try {
+      return Double.parseDouble(s);
+    } catch (NumberFormatException e) {
+      return Double.NaN;
+    }
   }
 
   static String trimJsWhiteSpace(String s) {
@@ -1223,6 +1280,10 @@ public final class NodeUtil {
     return n.getType() == Token.NULL;
   }
 
+  static boolean isNullOrUndefined(Node n) {
+    return isNull(n) || isUndefined(n);
+  }
+
   static class MayBeStringResultPredicate implements Predicate<Node> {
     public boolean apply(Node n) {
       return mayBeStringHelper(n);
@@ -2432,7 +2493,6 @@ public final class NodeUtil {
    *   "void 0"
    */
   static Node newUndefinedNode(Node srcReferenceNode) {
-    // TODO(johnlenz): Why this instead of the more common "undefined"?
     Node node = new Node(Token.VOID, Node.newNumber(0));
     if (srcReferenceNode != null) {
         node.copyInformationFromForTree(srcReferenceNode);
diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java
index 453b7d22c..e32425c01 100644
--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java
+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java
@@ -1290,17 +1290,12 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {
   private Node tryFoldArrayJoin(Node n) {
     Node callTarget = n.getFirstChild();
 
-    if (callTarget == null) {
+    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
       return n;
     }
 
     Node right = callTarget.getNext();
-
-    if (right == null) {
-      return n;
-    }
-
-    if (!NodeUtil.isGetProp(callTarget) || !NodeUtil.isImmutableValue(right)) {
+    if (right != null && !NodeUtil.isImmutableValue(right)) {
       return n;
     }
 
@@ -1312,7 +1307,9 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {
       return n;
     }
 
-    String joinString = NodeUtil.getStringValue(right);
+    // TODO(johnlenz): handle sparse arrays
+
+    String joinString = (right == null) ? "," : NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
     StringBuilder sb = null;
     int foldedSize = 0;
@@ -1326,7 +1323,7 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {
         } else {
           sb.append(joinString);
         }
-        sb.append(NodeUtil.getStringValue(elem));
+        sb.append(NodeUtil.getArrayElementStringValue(elem));
       } else {
         if (sb != null) {
           Preconditions.checkNotNull(prev);
@@ -1513,6 +1510,7 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {
     Preconditions.checkArgument(n.getType() == Token.GETELEM);
 
     if (left.getType() == Token.ARRAYLIT) {
+      // TODO(johnlenz): handle sparse arrays
 
       if (right.getType() != Token.NUMBER) {
         // Sometimes people like to use complex expressions to index into
@@ -1562,6 +1560,7 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {
       int knownLength = -1;
       switch (left.getType()) {
         case Token.ARRAYLIT:
+          // TODO(johnlenz): handle sparse arrays
           if (mayHaveSideEffects(left)) {
             // Nope, can't fold this, without handling the side-effects.
             return n;
diff --git a/test/com/google/javascript/jscomp/NodeUtilTest.java b/test/com/google/javascript/jscomp/NodeUtilTest.java
index b5b71232a..a13aa48e8 100644
--- a/test/com/google/javascript/jscomp/NodeUtilTest.java
+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java
@@ -198,8 +198,8 @@ public class NodeUtilTest extends TestCase {
     assertEquals("1", NodeUtil.getStringValue(getNode("1.0")));
     assertEquals("0", NodeUtil.getStringValue(getNode("'0'")));
     assertEquals(null, NodeUtil.getStringValue(getNode("/a/")));
-    assertEquals(null, NodeUtil.getStringValue(getNode("{}")));
-    assertEquals(null, NodeUtil.getStringValue(getNode("[]")));
+    assertEquals("[object Object]", NodeUtil.getStringValue(getNode("{}")));
+    assertEquals("", NodeUtil.getStringValue(getNode("[]")));
     assertEquals("false", NodeUtil.getStringValue(getNode("false")));
     assertEquals("null", NodeUtil.getStringValue(getNode("null")));
     assertEquals("0", NodeUtil.getStringValue(getNode("0")));
@@ -213,6 +213,20 @@ public class NodeUtilTest extends TestCase {
     assertEquals(null, NodeUtil.getStringValue(getNode("x")));
   }
 
+  public void testGetArrayStringValue() {
+    assertEquals("", NodeUtil.getStringValue(getNode("[]")));
+    assertEquals("", NodeUtil.getStringValue(getNode("['']")));
+    assertEquals("", NodeUtil.getStringValue(getNode("[null]")));
+    assertEquals("", NodeUtil.getStringValue(getNode("[undefined]")));
+    assertEquals("", NodeUtil.getStringValue(getNode("[void 0]")));
+    assertEquals("NaN", NodeUtil.getStringValue(getNode("[NaN]")));
+    assertEquals(",", NodeUtil.getStringValue(getNode("[,'']")));
+    assertEquals(",,", NodeUtil.getStringValue(getNode("[[''],[''],['']]")));
+    assertEquals("1,2", NodeUtil.getStringValue(getNode("[[1.0],[2.0]]")));
+    assertEquals(null, NodeUtil.getStringValue(getNode("[a]")));
+    assertEquals(null, NodeUtil.getStringValue(getNode("[1,a]")));
+  }
+
   public void testIsObjectLiteralKey1() throws Exception {
     testIsObjectLiteralKey(
       parseExpr("({})"), false);
diff --git a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
index 18a2988f4..3c6057dd6 100644
--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
@@ -422,7 +422,7 @@ public class PeepholeFoldConstantsTest extends CompilerTestCase {
     fold("x = foo() + 'a' + 2", "x = foo()+\"a2\"");
     fold("x = '' + null", "x = \"null\"");
     fold("x = true + '' + false", "x = \"truefalse\"");
-    fold("x = '' + []", "x = \"\"+[]");      // cannot fold (but nice if we can)
+    fold("x = '' + []", "x = ''");      // cannot fold (but nice if we can)
   }
 
   public void testFoldConstructor() {
@@ -505,6 +505,12 @@ public class PeepholeFoldConstantsTest extends CompilerTestCase {
 
     fold("x = [1,2,3].join('abcdef')",
          "x = '1abcdef2abcdef3'");
+
+    fold("x = [1,2].join()", "x = '1,2'");
+    fold("x = [null,undefined,''].join(',')", "x = ',,'");
+    fold("x = [null,undefined,0].join(',')", "x = ',,0'");
+    // This can be folded but we don't currently.
+    foldSame("x = [[1,2],[3,4]].join()"); // would like: "x = '1,2,3,4'"
   }
 
   public void testStringJoinAdd_b1992789() {
@@ -918,6 +924,11 @@ public class PeepholeFoldConstantsTest extends CompilerTestCase {
     fold("'a ' + !0", "'a true'");
   }
 
+  public void testFoldMixed() {
+    fold("''+[1]", "'1'");
+    foldSame("false+[]"); // would like: "\"false\""
+  }
+
   private static final List<String> LITERAL_OPERANDS =
       ImmutableList.of(
           "null",
