diff --git a/src/com/google/javascript/jscomp/CheckAccessControls.java b/src/com/google/javascript/jscomp/CheckAccessControls.java
index a265cd0c8..8f04caf94 100644
--- a/src/com/google/javascript/jscomp/CheckAccessControls.java
+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java
@@ -486,7 +486,7 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {
           // private access is always allowed in the same file.
           return;
         } else if (visibility == Visibility.PRIVATE &&
-            (currentClass == null || ownerType.differsFrom(currentClass))) {
+            (currentClass == null || !ownerType.isEquivalentTo(currentClass))) {
           if (docInfo.isConstructor() &&
               isValidPrivateConstructorAccess(parent)) {
             return;
diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java
index 8127163b1..295fe682b 100644
--- a/src/com/google/javascript/jscomp/TypeInference.java
+++ b/src/com/google/javascript/jscomp/TypeInference.java
@@ -897,9 +897,7 @@ class TypeInference
       }
     }
 
-    if (getJSType(callNode).differsFrom(narrowed)) {
-      callNode.setJSType(narrowed);
-    }
+    callNode.setJSType(narrowed);
     return scope;
   }
 
@@ -1216,6 +1214,7 @@ class TypeInference
     Node objNode = n.getFirstChild();
     Node property = n.getLastChild();
     scope = traverseChildren(n, scope);
+
     n.setJSType(
         getPropertyType(
             objNode.getJSType(), property.getString(), n, scope));
diff --git a/src/com/google/javascript/rhino/jstype/ArrowType.java b/src/com/google/javascript/rhino/jstype/ArrowType.java
index 7438b4112..c4109b08f 100644
--- a/src/com/google/javascript/rhino/jstype/ArrowType.java
+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java
@@ -174,7 +174,7 @@ final class ArrowType extends JSType {
    * @return True if our parameter spec is equal to {@code that}'s parameter
    *     spec.
    */
-  boolean hasEqualParameters(ArrowType that) {
+  boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {
     Node thisParam = parameters.getFirstChild();
     Node otherParam = that.parameters.getFirstChild();
     while (thisParam != null && otherParam != null) {
@@ -183,7 +183,8 @@ final class ArrowType extends JSType {
       if (thisParamType != null) {
         // Both parameter lists give a type for this param, it should be equal
         if (otherParamType != null &&
-            !thisParamType.isEquivalentTo(otherParamType)) {
+            !thisParamType.checkEquivalenceHelper(
+                otherParamType, tolerateUnknowns)) {
           return false;
         }
       } else {
@@ -199,17 +200,13 @@ final class ArrowType extends JSType {
     return thisParam == otherParam;
   }
 
-  @Override
-  public boolean isEquivalentTo(JSType object) {
+  boolean checkArrowEquivalenceHelper(
+      ArrowType that, boolean tolerateUnknowns) {
     // Please keep this method in sync with the hashCode() method below.
-    if (!(object instanceof ArrowType)) {
-      return false;
-    }
-    ArrowType that = (ArrowType) object;
-    if (!returnType.isEquivalentTo(that.returnType)) {
+    if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {
       return false;
     }
-    return hasEqualParameters(that);
+    return hasEqualParameters(that, tolerateUnknowns);
   }
 
   @Override
@@ -286,7 +283,7 @@ final class ArrowType extends JSType {
 
   @Override
   String toStringHelper(boolean forAnnotations) {
-    return super.toString();
+    return "[ArrowType]";
   }
 
   @Override
diff --git a/src/com/google/javascript/rhino/jstype/EnumElementType.java b/src/com/google/javascript/rhino/jstype/EnumElementType.java
index a41c70816..11930a637 100644
--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java
+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java
@@ -133,19 +133,6 @@ public class EnumElementType extends ObjectType {
     return hasReferenceName();
   }
 
-  @Override
-  public boolean isEquivalentTo(JSType that) {
-    if (this == that) {
-      return true;
-    } else if (this.isNominalType()) {
-      ObjectType thatObj = ObjectType.cast(that);
-      if (thatObj != null && thatObj.isNominalType()) {
-        return getReferenceName().equals(thatObj.getReferenceName());
-      }
-    }
-    return false;
-  }
-
   /**
    * If this is equal to a NamedType object, its hashCode must be equal
    * to the hashCode of the NamedType object.
diff --git a/src/com/google/javascript/rhino/jstype/FunctionType.java b/src/com/google/javascript/rhino/jstype/FunctionType.java
index d5ab5f9a2..e354e564d 100644
--- a/src/com/google/javascript/rhino/jstype/FunctionType.java
+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java
@@ -789,7 +789,7 @@ public class FunctionType extends PrototypeObjectType {
   private FunctionType tryMergeFunctionPiecewise(
       FunctionType other, boolean leastSuper) {
     Node newParamsNode = null;
-    if (call.hasEqualParameters(other.call)) {
+    if (call.hasEqualParameters(other.call, false)) {
       newParamsNode = call.parameters;
     } else {
       // If the parameters are not equal, don't try to merge them.
@@ -886,30 +886,27 @@ public class FunctionType extends PrototypeObjectType {
    * Two function types are equal if their signatures match. Since they don't
    * have signatures, two interfaces are equal if their names match.
    */
-  @Override
-  public boolean isEquivalentTo(JSType otherType) {
-    FunctionType that =
-        JSType.toMaybeFunctionType(otherType);
-    if (that == null) {
-      return false;
-    }
-    if (this.isConstructor()) {
+  boolean checkFunctionEquivalenceHelper(
+      FunctionType that, boolean tolerateUnknowns) {
+    if (isConstructor()) {
       if (that.isConstructor()) {
         return this == that;
       }
       return false;
     }
-    if (this.isInterface()) {
+    if (isInterface()) {
       if (that.isInterface()) {
-        return this.getReferenceName().equals(that.getReferenceName());
+        return getReferenceName().equals(that.getReferenceName());
       }
       return false;
     }
     if (that.isInterface()) {
       return false;
     }
-    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&
-        this.call.isEquivalentTo(that.call);
+
+    return typeOfThis.checkEquivalenceHelper(
+        that.typeOfThis, tolerateUnknowns) &&
+        call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);
   }
 
   @Override
@@ -918,7 +915,7 @@ public class FunctionType extends PrototypeObjectType {
   }
 
   public boolean hasEqualCallType(FunctionType otherType) {
-    return this.call.isEquivalentTo(otherType.call);
+    return this.call.checkArrowEquivalenceHelper(otherType.call, false);
   }
 
   /**
diff --git a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java
index 53095e6c3..7c0ea6ca3 100644
--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java
+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java
@@ -153,19 +153,6 @@ class InstanceObjectType extends PrototypeObjectType {
     return hasReferenceName();
   }
 
-  @Override
-  public boolean isEquivalentTo(JSType that) {
-    if (this == that) {
-      return true;
-    } else if (this.isNominalType()) {
-      ObjectType thatObj = ObjectType.cast(that);
-      if (thatObj != null && thatObj.isNominalType()) {
-        return getReferenceName().equals(thatObj.getReferenceName());
-      }
-    }
-    return false;
-  }
-
   /**
    * If this is equal to a NamedType object, its hashCode must be equal
    * to the hashCode of the NamedType object.
diff --git a/src/com/google/javascript/rhino/jstype/JSType.java b/src/com/google/javascript/rhino/jstype/JSType.java
index 7f7b9b87c..98284862e 100644
--- a/src/com/google/javascript/rhino/jstype/JSType.java
+++ b/src/com/google/javascript/rhino/jstype/JSType.java
@@ -483,15 +483,106 @@ public abstract class JSType implements Serializable {
   /**
    * Checks if two types are equivalent.
    */
-  public boolean isEquivalentTo(JSType jsType) {
-    if (jsType instanceof ProxyObjectType) {
-      return jsType.isEquivalentTo(this);
+  public final boolean isEquivalentTo(JSType jsType) {
+    return checkEquivalenceHelper(jsType, false);
+  }
+
+  /**
+   * Whether this type is meaningfully different from {@code that} type.
+   * This is a trickier check than pure equality, because it has to properly
+   * handle unknown types.
+   *
+   * @see <a href="http://www.youtube.com/watch?v=_RpSv3HjpEw">Unknown
+   *     unknowns</a>
+   */
+  public final boolean differsFrom(JSType that) {
+    return !checkEquivalenceHelper(that, true);
+  }
+
+  /**
+   * An equivalence visitor.
+   */
+  boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {
+    if (this == that) {
+      return true;
+    }
+
+    boolean thisUnknown = isUnknownType();
+    boolean thatUnknown = that.isUnknownType();
+    if (isUnknownType() || that.isUnknownType()) {
+      if (tolerateUnknowns) {
+        // If we tolerate unknowns, then two types are the same if they're
+        // both unknown.
+        return thisUnknown && thatUnknown;
+      } else if (thisUnknown && thatUnknown &&
+          (isNominalType() ^ that.isNominalType())) {
+        // If they're both unknown, but one is a nominal type and the other
+        // is not, then we should fail out immediately. This ensures that
+        // we won't unbox the unknowns further down.
+        return false;
+      }
+    }
+
+    if (isUnionType() && that.isUnionType()) {
+      return this.toMaybeUnionType().checkUnionEquivalenceHelper(
+          that.toMaybeUnionType(), tolerateUnknowns);
+    }
+
+    if (isFunctionType() && that.isFunctionType()) {
+      return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(
+          that.toMaybeFunctionType(), tolerateUnknowns);
+    }
+
+    if (isRecordType() && that.isRecordType()) {
+      return this.toMaybeRecordType().checkRecordEquivalenceHelper(
+          that.toMaybeRecordType(), tolerateUnknowns);
+    }
+
+    ParameterizedType thisParamType = toMaybeParameterizedType();
+    ParameterizedType thatParamType = that.toMaybeParameterizedType();
+    if (thisParamType != null || thatParamType != null) {
+      // Check if one type is parameterized, but the other is not.
+      boolean paramsMatch = false;
+      if (thisParamType != null && thatParamType != null) {
+        paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(
+            thatParamType.getParameterType(), tolerateUnknowns);
+      } else if (tolerateUnknowns) {
+        paramsMatch = true;
+      } else {
+        paramsMatch = false;
+      }
+
+      JSType thisRootType = thisParamType == null ?
+          this : thisParamType.getReferencedTypeInternal();
+      JSType thatRootType = thatParamType == null ?
+          that : thatParamType.getReferencedTypeInternal();
+      return paramsMatch &&
+          thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);
+    }
+
+    if (isNominalType() && that.isNominalType()) {
+      return toObjectType().getReferenceName().equals(
+          that.toObjectType().getReferenceName());
+    }
+
+    // Unbox other proxies.
+    if (this instanceof ProxyObjectType) {
+      return ((ProxyObjectType) this)
+          .getReferencedTypeInternal().checkEquivalenceHelper(
+              that, tolerateUnknowns);
+    }
+
+    if (that instanceof ProxyObjectType) {
+      return checkEquivalenceHelper(
+          ((ProxyObjectType) that).getReferencedTypeInternal(),
+          tolerateUnknowns);
     }
+
     // Relies on the fact that for the base {@link JSType}, only one
     // instance of each sub-type will ever be created in a given registry, so
     // there is no need to verify members. If the object pointers are not
     // identical, then the type member must be different.
-    return this == jsType;
+    return this == that;
   }
 
   public static boolean isEquivalent(JSType typeA, JSType typeB) {
@@ -1082,23 +1173,6 @@ public abstract class JSType implements Serializable {
     return isSubtypeHelper(this, that);
   }
 
-  /**
-   * Whether this type is meaningfully different from {@code that} type.
-   * This is a trickier check than pure equality, because it has to properly
-   * handle unknown types.
-   *
-   * @see <a href="http://www.youtube.com/watch?v=_RpSv3HjpEw">Unknown
-   *     unknowns</a>
-   */
-  public boolean differsFrom(JSType that) {
-    // if there are no unknowns, just use normal equality.
-    if (!this.isUnknownType() && !that.isUnknownType()) {
-      return !this.isEquivalentTo(that);
-    }
-    // otherwise, they're different iff one is unknown and the other is not.
-    return this.isUnknownType() ^ that.isUnknownType();
-  }
-
   /**
    * A generic implementation meant to be used as a helper for common subtyping
    * cases.
diff --git a/src/com/google/javascript/rhino/jstype/NamedType.java b/src/com/google/javascript/rhino/jstype/NamedType.java
index 44645f750..70142c455 100644
--- a/src/com/google/javascript/rhino/jstype/NamedType.java
+++ b/src/com/google/javascript/rhino/jstype/NamedType.java
@@ -172,30 +172,6 @@ class NamedType extends ProxyObjectType {
     return true;
   }
 
-  /**
-   * Two named types are equivalent if they are the same {@code
-   * ObjectType} object.  This is complicated by the fact that isEquivalent
-   * is sometimes called before we have a chance to resolve the type
-   * names.
-   *
-   * @return {@code true} iff {@code that} == {@code this} or {@code that}
-   *         is a {@link NamedType} whose reference is the same as ours,
-   *         or {@code that} is the type we reference.
-   */
-  @Override
-  public boolean isEquivalentTo(JSType that) {
-    if (this == that) {
-      return true;
-    }
-
-    ObjectType objType = ObjectType.cast(that);
-    if (objType != null) {
-      return objType.isNominalType() &&
-          reference.equals(objType.getReferenceName());
-    }
-    return false;
-  }
-
   @Override
   public int hashCode() {
     return reference.hashCode();
diff --git a/src/com/google/javascript/rhino/jstype/NoObjectType.java b/src/com/google/javascript/rhino/jstype/NoObjectType.java
index 72b0714a8..81889a6fb 100644
--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java
+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java
@@ -115,11 +115,6 @@ public class NoObjectType extends FunctionType {
     return true;
   }
 
-  @Override
-  public boolean isEquivalentTo(JSType that) {
-    return this == that;
-  }
-
   @Override
   public int hashCode() {
     return System.identityHashCode(this);
diff --git a/src/com/google/javascript/rhino/jstype/ParameterizedType.java b/src/com/google/javascript/rhino/jstype/ParameterizedType.java
index 058aa377c..79036bbe0 100644
--- a/src/com/google/javascript/rhino/jstype/ParameterizedType.java
+++ b/src/com/google/javascript/rhino/jstype/ParameterizedType.java
@@ -63,13 +63,6 @@ public final class ParameterizedType extends ProxyObjectType {
     return parameterType;
   }
 
-  @Override
-  public boolean isEquivalentTo(JSType that) {
-    return (super.isEquivalentTo(that)
-        && JSType.isEquivalent(
-            parameterType, that.toObjectType().getParameterType()));
-  }
-
   @Override
   String toStringHelper(boolean forAnnotations) {
     String result = super.toStringHelper(forAnnotations);
diff --git a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java
index aad8bbf60..9301a83c7 100644
--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java
+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java
@@ -486,7 +486,7 @@ class PrototypeObjectType extends ObjectType {
       // to avoid guessing.
       return true;
     }
-    return this.isImplicitPrototype(thatObj);
+    return thatObj != null && this.isImplicitPrototype(thatObj);
   }
 
   private boolean implicitPrototypeChainIsUnknown() {
diff --git a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java
index d4a3efa81..a3aff3e8b 100644
--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java
+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java
@@ -250,14 +250,6 @@ class ProxyObjectType extends ObjectType {
     return referencedType.canAssignTo(that);
   }
 
-  @Override
-  public boolean isEquivalentTo(JSType that) {
-    if (this == that) {
-      return true;
-    }
-    return referencedType.isEquivalentTo(that);
-  }
-
   @Override
   public int hashCode() {
     return referencedType.hashCode();
diff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java
index 8ff279cbd..7d9009a96 100755
--- a/src/com/google/javascript/rhino/jstype/RecordType.java
+++ b/src/com/google/javascript/rhino/jstype/RecordType.java
@@ -114,25 +114,16 @@ class RecordType extends PrototypeObjectType {
     return !declared;
   }
 
-  @Override
-  public boolean isEquivalentTo(JSType other) {
-    if (!other.isRecordType()) {
-      return false;
-    }
-
-    // Compare properties.
-    RecordType otherRecord = other.toMaybeRecordType();
-    if (otherRecord == this) {
-      return true;
-    }
-
+  boolean checkRecordEquivalenceHelper(
+      RecordType otherRecord, boolean tolerateUnknowns) {
     Set<String> keySet = properties.keySet();
     Map<String, JSType> otherProps = otherRecord.properties;
     if (!otherProps.keySet().equals(keySet)) {
       return false;
     }
     for (String key : keySet) {
-      if (!otherProps.get(key).isEquivalentTo(properties.get(key))) {
+      if (!otherProps.get(key).checkEquivalenceHelper(
+              properties.get(key), tolerateUnknowns)) {
         return false;
       }
     }
diff --git a/src/com/google/javascript/rhino/jstype/UnionType.java b/src/com/google/javascript/rhino/jstype/UnionType.java
index edf5ec904..82c9e6be4 100644
--- a/src/com/google/javascript/rhino/jstype/UnionType.java
+++ b/src/com/google/javascript/rhino/jstype/UnionType.java
@@ -330,30 +330,22 @@ public class UnionType extends JSType {
    * Two union types are equal if they have the same number of alternates
    * and all alternates are equal.
    */
-  @Override
-  public boolean isEquivalentTo(JSType object) {
-    if (object == null) {
+  boolean checkUnionEquivalenceHelper(
+      UnionType that, boolean tolerateUnknowns) {
+    if (!tolerateUnknowns && alternates.size() != that.alternates.size()) {
       return false;
     }
-    if (object.isUnionType()) {
-      UnionType that = object.toMaybeUnionType();
-      if (alternates.size() != that.alternates.size()) {
+    for (JSType alternate : that.alternates) {
+      if (!hasAlternate(alternate, tolerateUnknowns)) {
         return false;
       }
-      for (JSType alternate : that.alternates) {
-        if (!hasAlternate(alternate)) {
-          return false;
-        }
-      }
-      return true;
-    } else {
-      return false;
     }
+    return true;
   }
 
-  private boolean hasAlternate(JSType type) {
+  private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {
     for (JSType alternate : alternates) {
-      if (alternate.isEquivalentTo(type)) {
+      if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {
         return true;
       }
     }
diff --git a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java
index 54a374bf2..b7a180f11 100644
--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java
+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java
@@ -47,6 +47,7 @@ import com.google.javascript.rhino.jstype.JSType;
 import com.google.javascript.rhino.jstype.JSTypeNative;
 import com.google.javascript.rhino.jstype.JSTypeRegistry;
 import com.google.javascript.rhino.jstype.ObjectType;
+import com.google.javascript.rhino.jstype.ParameterizedType;
 import com.google.javascript.rhino.jstype.RecordTypeBuilder;
 
 import junit.framework.TestCase;
@@ -587,4 +588,8 @@ public abstract class BaseJSTypeTestCase extends TestCase {
   protected final void assertTypeNotEquals(String msg, JSType a, JSType b) {
     Asserts.assertTypeNotEquals(msg, a, b);
   }
+
+  protected final ParameterizedType parameterize(ObjectType objType, JSType t) {
+    return registry.createParameterizedType(objType, t);
+  }
 }
diff --git a/test/com/google/javascript/jscomp/TypeCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckTest.java
index 551bb406e..50ee6c7ae 100644
--- a/test/com/google/javascript/jscomp/TypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java
@@ -6307,6 +6307,19 @@ public class TypeCheckTest extends CompilerTypeTestCase {
         "Property unknownProp never defined on Type");
   }
 
+  public void testIssue791() throws Exception {
+    // TODO(nicksantos): This warning is wrong, and should be fixed.
+    testTypes(
+        "/** @param {{func: function()}} obj */" +
+        "function test1(obj) {}" +
+        "var fnStruc1 = {};" +
+        "fnStruc1.func = function() {};" +
+        "test1(fnStruc1);",
+        "actual parameter 1 of test1 does not match formal parameter\n" +
+        "found   : {func: function (): undefined}\n" +
+        "required: {func: function (): ?}");
+  }
+
   public void testIssue810() throws Exception {
     testTypes(
         "/** @constructor */" +
diff --git a/test/com/google/javascript/jscomp/TypeInferenceTest.java b/test/com/google/javascript/jscomp/TypeInferenceTest.java
index 14b59cabe..70603fb6d 100644
--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java
+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java
@@ -574,6 +574,26 @@ public class TypeInferenceTest extends TestCase {
     verifySubtypeOf("y", OBJECT_TYPE);
   }
 
+  public void testFor5() {
+    assuming("y", parameterize(
+        getNativeObjectType(ARRAY_TYPE), getNativeType(NUMBER_TYPE)));
+    inFunction(
+        "var x = null; for (var i = 0; i < y.length; i++) { x = y[i]; }");
+    verify("x", createNullableType(NUMBER_TYPE));
+    verify("i", NUMBER_TYPE);
+  }
+
+  public void testFor6() {
+    assuming("y", getNativeObjectType(ARRAY_TYPE));
+    inFunction(
+        "var x = null;" +
+        "for (var i = 0; i < y.length; i++) { " +
+        " if (y[i] == 'z') { x = y[i]; } " +
+        "}");
+    verify("x", getNativeType(UNKNOWN_TYPE));
+    verify("i", NUMBER_TYPE);
+  }
+
   public void testSwitch1() {
     assuming("x", NUMBER_TYPE);
     inFunction("var y = null; switch(x) {\n" +
@@ -1029,4 +1049,16 @@ public class TypeInferenceTest extends TestCase {
         "out = x.prop;");
     verify("out", CHECKED_UNKNOWN_TYPE);
   }
+
+  private ObjectType getNativeObjectType(JSTypeNative t) {
+    return registry.getNativeObjectType(t);
+  }
+
+  private JSType getNativeType(JSTypeNative t) {
+    return registry.getNativeType(t);
+  }
+
+  private JSType parameterize(ObjectType objType, JSType t) {
+    return registry.createParameterizedType(objType, t);
+  }
 }
diff --git a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
index 07bc0d5f8..cb7ce7ae3 100644
--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
@@ -245,63 +245,92 @@ public class JsDocInfoParserTest extends BaseJSTypeTestCase {
 
   public void testParseParametrizedType1() throws Exception {
     JSDocInfo info = parse("@type !Array.<number> */");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(parameterize(ARRAY_TYPE, NUMBER_TYPE), info.getType());
   }
 
   public void testParseParametrizedType2() throws Exception {
     JSDocInfo info = parse("@type {!Array.<number>}*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(parameterize(ARRAY_TYPE, NUMBER_TYPE), info.getType());
   }
 
   public void testParseParametrizedType3() throws Exception {
     JSDocInfo info = parse("@type !Array.<(number,null)>*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),
+        info.getType());
   }
 
   public void testParseParametrizedType4() throws Exception {
     JSDocInfo info = parse("@type {!Array.<(number|null)>}*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),
+        info.getType());
   }
 
   public void testParseParametrizedType5() throws Exception {
     JSDocInfo info = parse("@type {!Array.<Array.<(number|null)>>}*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(ARRAY_TYPE,
+            createUnionType(NULL_TYPE,
+                parameterize(ARRAY_TYPE,
+                    createUnionType(NUMBER_TYPE, NULL_TYPE)))),
+        info.getType());
   }
 
   public void testParseParametrizedType6() throws Exception {
     JSDocInfo info = parse("@type {!Array.<!Array.<(number|null)>>}*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(ARRAY_TYPE,
+            parameterize(ARRAY_TYPE,
+                createUnionType(NUMBER_TYPE, NULL_TYPE))),
+        info.getType());
   }
 
   public void testParseParametrizedType7() throws Exception {
     JSDocInfo info = parse("@type {!Array.<function():Date>}*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(ARRAY_TYPE,
+            registry.createFunctionType(
+                createUnionType(DATE_TYPE, NULL_TYPE))),
+        info.getType());
   }
 
   public void testParseParametrizedType8() throws Exception {
     JSDocInfo info = parse("@type {!Array.<function():!Date>}*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(ARRAY_TYPE,
+            registry.createFunctionType(DATE_TYPE)),
+        info.getType());
   }
 
   public void testParseParametrizedType9() throws Exception {
     JSDocInfo info = parse("@type {!Array.<Date|number>}*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(ARRAY_TYPE,
+            createUnionType(DATE_TYPE, NUMBER_TYPE, NULL_TYPE)),
+        info.getType());
   }
 
   public void testParseParametrizedType10() throws Exception {
     JSDocInfo info = parse("@type {!Array.<Date|number|boolean>}*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(ARRAY_TYPE,
+            createUnionType(DATE_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE)),
+        info.getType());
   }
 
-  public void testParseParamterizedType11() throws Exception {
+  public void testParseParameterizedType11() throws Exception {
     JSDocInfo info = parse("@type {!Object.<number>}*/");
-    assertTypeEquals(OBJECT_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(OBJECT_TYPE, NUMBER_TYPE),
+        info.getType());
     assertParameterTypeEquals(NUMBER_TYPE, info.getType());
   }
 
-  public void testParseParamterizedType12() throws Exception {
+  public void testParseParameterizedType12() throws Exception {
     JSDocInfo info = parse("@type {!Object.<string,number>}*/");
-    assertTypeEquals(OBJECT_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(OBJECT_TYPE, NUMBER_TYPE), info.getType());
     assertParameterTypeEquals(NUMBER_TYPE, info.getType());
     assertIndexTypeEquals(STRING_TYPE, info.getType());
   }
@@ -323,32 +352,38 @@ public class JsDocInfoParserTest extends BaseJSTypeTestCase {
 
   public void testParseUnionType4() throws Exception {
     JSDocInfo info = parse("@type {(Array.<boolean>,null)}*/");
-    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());
+    assertTypeEquals(createUnionType(
+        parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());
   }
 
   public void testParseUnionType5() throws Exception {
     JSDocInfo info = parse("@type {(null, Array.<boolean>)}*/");
-    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());
+    assertTypeEquals(createUnionType(
+        parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());
   }
 
   public void testParseUnionType6() throws Exception {
     JSDocInfo info = parse("@type {Array.<boolean>|null}*/");
-    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());
+    assertTypeEquals(createUnionType(
+        parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());
   }
 
   public void testParseUnionType7() throws Exception {
     JSDocInfo info = parse("@type {null|Array.<boolean>}*/");
-    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());
+    assertTypeEquals(createUnionType(
+        parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());
   }
 
   public void testParseUnionType8() throws Exception {
     JSDocInfo info = parse("@type {null||Array.<boolean>}*/");
-    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());
+    assertTypeEquals(createUnionType(
+        parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());
   }
 
   public void testParseUnionType9() throws Exception {
     JSDocInfo info = parse("@type {Array.<boolean>||null}*/");
-    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());
+    assertTypeEquals(createUnionType(
+        parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());
   }
 
   public void testParseUnionType10() throws Exception {
@@ -646,12 +681,16 @@ public class JsDocInfoParserTest extends BaseJSTypeTestCase {
 
   public void testParseNullableModifiers2() throws Exception {
     JSDocInfo info = parse("@type {!Array.<string?>}*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(ARRAY_TYPE, createUnionType(STRING_TYPE, NULL_TYPE)),
+        info.getType());
   }
 
   public void testParseNullableModifiers3() throws Exception {
     JSDocInfo info = parse("@type {Array.<boolean>?}*/");
-    assertTypeEquals(createNullableType(ARRAY_TYPE), info.getType());
+    assertTypeEquals(
+        createNullableType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE)),
+        info.getType());
   }
 
   public void testParseNullableModifiers4() throws Exception {
@@ -713,29 +752,38 @@ public class JsDocInfoParserTest extends BaseJSTypeTestCase {
 
   public void testParseNewline2() throws Exception {
     JSDocInfo info = parse("@type !Array.<\n* number\n* > */");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(parameterize(ARRAY_TYPE, NUMBER_TYPE), info.getType());
   }
 
   public void testParseNewline3() throws Exception {
     JSDocInfo info = parse("@type !Array.<(number,\n* null)>*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),
+        info.getType());
   }
 
   public void testParseNewline4() throws Exception {
     JSDocInfo info = parse("@type !Array.<(number|\n* null)>*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),
+        info.getType());
   }
 
   public void testParseNewline5() throws Exception {
     JSDocInfo info = parse("@type !Array.<function(\n* )\n* :\n* Date>*/");
-    assertTypeEquals(ARRAY_TYPE, info.getType());
+    assertTypeEquals(
+        parameterize(ARRAY_TYPE,
+            registry.createFunctionType(
+                createUnionType(DATE_TYPE, NULL_TYPE))),
+        info.getType());
   }
 
   public void testParseReturnType1() throws Exception {
     JSDocInfo info =
         parse("@return {null|string|Array.<boolean>}*/");
     assertTypeEquals(
-        createUnionType(ARRAY_TYPE, NULL_TYPE, STRING_TYPE),
+        createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE),
+            NULL_TYPE, STRING_TYPE),
         info.getReturnType());
   }
 
@@ -743,7 +791,8 @@ public class JsDocInfoParserTest extends BaseJSTypeTestCase {
     JSDocInfo info =
         parse("@returns {null|(string,Array.<boolean>)}*/");
     assertTypeEquals(
-        createUnionType(ARRAY_TYPE, NULL_TYPE, STRING_TYPE),
+        createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE),
+            NULL_TYPE, STRING_TYPE),
         info.getReturnType());
   }
 
@@ -751,7 +800,8 @@ public class JsDocInfoParserTest extends BaseJSTypeTestCase {
     JSDocInfo info =
         parse("@return {((null||Array.<boolean>,string),boolean)}*/");
     assertTypeEquals(
-        createUnionType(ARRAY_TYPE, NULL_TYPE, STRING_TYPE, BOOLEAN_TYPE),
+        createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE),
+            NULL_TYPE, STRING_TYPE, BOOLEAN_TYPE),
         info.getReturnType());
   }
 
diff --git a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java
index 644847571..6bde7e056 100644
--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java
+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java
@@ -239,7 +239,7 @@ public class FunctionTypeTest extends BaseJSTypeTestCase {
 
   public void testIsEquivalentTo() {
     FunctionType type = new FunctionBuilder(registry).build();
-    assertFalse(type.isEquivalentTo(null));
+    assertFalse(type.equals(null));
     assertTrue(type.isEquivalentTo(type));
   }
 
diff --git a/test/com/google/javascript/rhino/jstype/JSTypeTest.java b/test/com/google/javascript/rhino/jstype/JSTypeTest.java
index 1ce3d107a..188c1477d 100644
--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java
+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java
@@ -1779,6 +1779,8 @@ public class JSTypeTest extends BaseJSTypeTestCase {
         NULL_TYPE.getGreatestSubtype(
             createUnionType(forwardDeclaredNamedType, NULL_TYPE)));
     assertFalse(NULL_TYPE.isNominalConstructor());
+
+    assertTrue(NULL_TYPE.differsFrom(UNKNOWN_TYPE));
   }
 
   /**
diff --git a/test/com/google/javascript/rhino/jstype/UnionTypeTest.java b/test/com/google/javascript/rhino/jstype/UnionTypeTest.java
index f7d094cee..d081c7830 100644
--- a/test/com/google/javascript/rhino/jstype/UnionTypeTest.java
+++ b/test/com/google/javascript/rhino/jstype/UnionTypeTest.java
@@ -285,7 +285,7 @@ public class UnionTypeTest extends BaseJSTypeTestCase {
 
   public void testIsEquivalentTo() {
     UnionType type = (UnionType) createUnionType(NUMBER_TYPE, STRING_TYPE);
-    assertFalse(type.isEquivalentTo(null));
+    assertFalse(type.equals(null));
     assertTrue(type.isEquivalentTo(type));
   }
 
