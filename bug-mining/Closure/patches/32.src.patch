diff --git a/javadoc/com/google/javascript/rhino/JSDocInfo.html b/javadoc/com/google/javascript/rhino/JSDocInfo.html
index fb209e53f..195cc4802 100644
--- a/javadoc/com/google/javascript/rhino/JSDocInfo.html
+++ b/javadoc/com/google/javascript/rhino/JSDocInfo.html
@@ -389,6 +389,14 @@ Class JSDocInfo</H2>
 </TR>
 <TR BGCOLOR="white" CLASS="TableRowColor">
 <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
+<CODE>&nbsp;<A HREF="http://java.sun.com/javase/6/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../com/google/javascript/rhino/Node.html" title="class in com.google.javascript.rhino">Node</A>&gt;</CODE></FONT></TD>
+<TD><CODE><B><A HREF="../../../../com/google/javascript/rhino/JSDocInfo.html#getTypeNodes()">getTypeNodes</A></B>()</CODE>
+
+<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a collection of all type nodes that are a part of this JSDocInfo.</TD>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 <CODE>&nbsp;<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
 <TD><CODE><B><A HREF="../../../../com/google/javascript/rhino/JSDocInfo.html#getVersion()">getVersion</A></B>()</CODE>
 
@@ -1652,6 +1660,26 @@ public <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-e
 </DL>
 </DD>
 </DL>
+<HR>
+
+<A NAME="getTypeNodes()"><!-- --></A><H3>
+getTypeNodes</H3>
+<PRE>
+public <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../com/google/javascript/rhino/Node.html" title="class in com.google.javascript.rhino">Node</A>&gt; <B>getTypeNodes</B>()</PRE>
+<DL>
+<DD>Returns a collection of all type nodes that are a part of this JSDocInfo.
+ This includes @type, @this, @extends, @implements, @param, @throws,
+ and @return.  Any future type specific JSDoc should make sure to add the
+ appropriate nodes here.
+<P>
+<DD><DL>
+</DL>
+</DD>
+<DD><DL>
+
+<DT><B>Returns:</B><DD>collection of all type nodes</DL>
+</DD>
+</DL>
 <!-- ========= END OF CLASS DATA ========= -->
 <HR>
 
diff --git a/javadoc/index-all.html b/javadoc/index-all.html
index 1c40d619e..2d66223a4 100644
--- a/javadoc/index-all.html
+++ b/javadoc/index-all.html
@@ -3680,6 +3680,9 @@ Method in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/js
 <DT><A HREF="./com/google/javascript/jscomp/ErrorManager.html#getTypedPercent()"><B>getTypedPercent()</B></A> - 
 Method in interface com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/ErrorManager.html" title="interface in com.google.javascript.jscomp">ErrorManager</A>
 <DD>Gets the percentage of typed expressions.
+<DT><A HREF="./com/google/javascript/rhino/JSDocInfo.html#getTypeNodes()"><B>getTypeNodes()</B></A> - 
+Method in class com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/JSDocInfo.html" title="class in com.google.javascript.rhino">JSDocInfo</A>
+<DD>Returns a collection of all type nodes that are a part of this JSDocInfo.
 <DT><A HREF="./com/google/javascript/jscomp/Scope.html#getTypeOfThis()"><B>getTypeOfThis()</B></A> - 
 Method in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/Scope.html" title="class in com.google.javascript.jscomp">Scope</A>
 <DD>Gets the type of <code>this</code> in the current scope.
diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java
index 618218d53..bae5a772c 100644
--- a/src/com/google/javascript/jscomp/Compiler.java
+++ b/src/com/google/javascript/jscomp/Compiler.java
@@ -1045,6 +1045,12 @@ public class Compiler extends AbstractCompiler {
       if (options.manageClosureDependencies) {
         for (CompilerInput input : inputs) {
           input.setCompiler(this);
+
+          // Forward-declare all the provided types, so that they
+          // are not flagged even if they are dropped from the process.
+          for (String provide : input.getProvides()) {
+            getTypeRegistry().forwardDeclareType(provide);
+          }
         }
 
         inputs =
diff --git a/src/com/google/javascript/jscomp/ScopedAliases.java b/src/com/google/javascript/jscomp/ScopedAliases.java
index 07e4174b2..9bd9aee5c 100644
--- a/src/com/google/javascript/jscomp/ScopedAliases.java
+++ b/src/com/google/javascript/jscomp/ScopedAliases.java
@@ -18,6 +18,7 @@ package com.google.javascript.jscomp;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import com.google.javascript.rhino.JSDocInfo;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
@@ -80,10 +81,8 @@ class ScopedAliases implements CompilerPass {
 
     if (!traversal.hasErrors()) {
       // Apply the aliases.
-      for (AliasedNode entry : traversal.getAliasUsages()) {
-        entry.getAliasReference().getParent().replaceChild(
-            entry.getAliasReference(),
-            entry.getAliasDefinition().cloneTree());
+      for (AliasUsage aliasUsage : traversal.getAliasUsages()) {
+        aliasUsage.applyAlias();
       }
 
       // Remove the alias definitions.
@@ -115,7 +114,11 @@ class ScopedAliases implements CompilerPass {
     }
   }
 
-  private class AliasedNode {
+  private interface AliasUsage {
+    public void applyAlias();
+  }
+
+  private class AliasedNode implements AliasUsage {
     private final Node aliasReference;
 
     private final Node aliasDefinition;
@@ -125,22 +128,35 @@ class ScopedAliases implements CompilerPass {
       this.aliasDefinition = aliasDefinition;
     }
 
-    public Node getAliasReference() {
-      return aliasReference;
+    public void applyAlias() {
+      aliasReference.getParent().replaceChild(
+          aliasReference, aliasDefinition.cloneTree());
     }
+  }
+
+  private class AliasedTypeNode implements AliasUsage {
+    private final Node aliasReference;
+
+    private final String correctedType;
 
-    public Node getAliasDefinition() {
-      return aliasDefinition;
+    AliasedTypeNode(Node aliasReference, String correctedType) {
+      this.aliasReference = aliasReference;
+      this.correctedType = correctedType;
+    }
+
+    public void applyAlias() {
+      aliasReference.setString(correctedType);
     }
   }
 
+
   private class Traversal implements NodeTraversal.ScopedCallback {
     // The job of this class is to collect these three data sets.
     private List<Node> aliasDefinitions = Lists.newArrayList();
 
     private List<Node> scopeCalls = Lists.newArrayList();
 
-    private List<AliasedNode> aliasUsages = Lists.newArrayList();
+    private List<AliasUsage> aliasUsages = Lists.newArrayList();
 
     // This map is temporary and cleared for each scope.
     private Map<String, Node> aliases = Maps.newHashMap();
@@ -151,7 +167,7 @@ class ScopedAliases implements CompilerPass {
       return aliasDefinitions;
     }
 
-    private List<AliasedNode> getAliasUsages() {
+    private List<AliasUsage> getAliasUsages() {
       return aliasUsages;
     }
 
@@ -222,6 +238,7 @@ class ScopedAliases implements CompilerPass {
         if (n.getType() == Token.NAME && parent.getType() == Token.VAR) {
           if (n.hasChildren() && n.isQualifiedName()) {
             // TODO(robbyw): What other checks go here?
+            // TODO(robbyw): Emit errors about non-alias local variables.
 
             aliases.put(n.getString(), n.getFirstChild());
             aliasDefinitions.add(n);
@@ -262,6 +279,36 @@ class ScopedAliases implements CompilerPass {
         if (n.getType() == Token.THIS) {
           report(t, n, GOOG_SCOPE_REFERENCES_THIS);
         }
+
+        JSDocInfo info = n.getJSDocInfo();
+        if (info != null) {
+          for (Node node : info.getTypeNodes()) {
+            fixTypeNode(node);
+          }
+        }
+
+        // TODO(robbyw): Error for goog.scope not at root.
+      }
+    }
+
+    private void fixTypeNode(Node typeNode) {
+      if (typeNode.getType() == Token.STRING) {
+        String name = typeNode.getString();
+        int endIndex = name.indexOf('.');
+        if (endIndex == -1) {
+          endIndex = name.length();
+        }
+        String baseName = name.substring(0, endIndex);
+        Node aliasedNode = aliases.get(baseName);
+        if (aliasedNode != null) {
+          aliasUsages.add(new AliasedTypeNode(typeNode,
+              aliasedNode.getQualifiedName() + name.substring(endIndex)));
+        }
+      }
+
+      for (Node child = typeNode.getFirstChild(); child != null;
+           child = child.getNext()) {
+        fixTypeNode(child);
       }
     }
   }
diff --git a/src/com/google/javascript/rhino/JSDocInfo.java b/src/com/google/javascript/rhino/JSDocInfo.java
index a65a37917..394bb4491 100644
--- a/src/com/google/javascript/rhino/JSDocInfo.java
+++ b/src/com/google/javascript/rhino/JSDocInfo.java
@@ -1123,4 +1123,49 @@ public final class JSDocInfo implements Serializable {
     }
     return info.templateTypeName;
   }
+
+  /**
+   * Returns a collection of all type nodes that are a part of this JSDocInfo.
+   * This includes @type, @this, @extends, @implements, @param, @throws,
+   * and @return.  Any future type specific JSDoc should make sure to add the
+   * appropriate nodes here.
+   * @return collection of all type nodes
+   */
+  public Collection<Node> getTypeNodes() {
+    List<Node> nodes = Lists.newArrayList();
+
+    if (type != null) {
+      nodes.add(type.getRoot());
+    }
+
+    if (thisType != null) {
+      nodes.add(thisType.getRoot());
+    }
+
+    if (info != null) {
+      if (info.baseType != null) {
+        nodes.add(info.baseType.getRoot());
+      }
+
+      if (info.implementedInterfaces != null) {
+        for (JSTypeExpression interfaceType : info.implementedInterfaces) {
+          nodes.add(interfaceType.getRoot());
+        }
+      }
+
+      if (info.parameters != null) {
+        for (JSTypeExpression parameterType : info.parameters.values()) {
+          nodes.add(parameterType.getRoot());
+        }
+      }
+
+      if (info.thrownTypes != null) {
+        for (JSTypeExpression thrownType : info.thrownTypes) {
+          nodes.add(thrownType.getRoot());
+        }
+      }
+    }
+
+    return nodes;    
+  }
 }
diff --git a/src/com/google/javascript/rhino/JSTypeExpression.java b/src/com/google/javascript/rhino/JSTypeExpression.java
index f15c97afb..a629c95ed 100644
--- a/src/com/google/javascript/rhino/JSTypeExpression.java
+++ b/src/com/google/javascript/rhino/JSTypeExpression.java
@@ -111,4 +111,8 @@ public final class JSTypeExpression implements Serializable {
   public int hashCode() {
     return root.toStringTree().hashCode();
   }
+
+  Node getRoot() {
+    return root;
+  }
 }
diff --git a/src/com/google/javascript/rhino/Node.java b/src/com/google/javascript/rhino/Node.java
index 765d1d5f4..a2e44ebf0 100644
--- a/src/com/google/javascript/rhino/Node.java
+++ b/src/com/google/javascript/rhino/Node.java
@@ -901,7 +901,12 @@ public class Node implements Cloneable, Serializable {
         sb.append(getString());
       } else if (type == Token.FUNCTION) {
         sb.append(' ');
-        sb.append(first.getString());
+        // In the case of JsDoc trees, the first child is often not a string
+        // which causes exceptions to be thrown when calling toString or
+        // toStringTree.
+        if (first.getType() == Token.STRING) {
+          sb.append(first.getString());
+        }
       } else if (this instanceof ScriptOrFnNode) {
         ScriptOrFnNode sof = (ScriptOrFnNode) this;
         if (this instanceof FunctionNode) {
diff --git a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
index 47dd1c2f8..504fc1972 100644
--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
@@ -296,6 +296,31 @@ public class CommandLineRunnerTest extends TestCase {
          });
   }
 
+  public void testForwardDeclareDroppedTypes() {
+    args.add("--manage_closure_dependencies=true");
+
+    args.add("--warning_level=VERBOSE");
+    test(new String[] {
+          "goog.require('beer');",
+          "goog.provide('beer'); /** @param {Scotch} x */ function f(x) {}",
+          "goog.provide('Scotch'); var x = 3;"
+         },
+         new String[] {
+           "var beer = {}; function f() {}",
+           ""
+         });
+
+    test(new String[] {
+          "goog.require('beer');",
+          "goog.provide('beer'); /** @param {Scotch} x */ function f(x) {}"
+         },
+         new String[] {
+           "var beer = {}; function f() {}",
+           ""
+         },
+         RhinoErrorReporter.PARSE_ERROR);
+  }
+
   /* Helper functions */
 
   private void testSame(String original) {
diff --git a/test/com/google/javascript/jscomp/ScopedAliasesTest.java b/test/com/google/javascript/jscomp/ScopedAliasesTest.java
index fbc14c4c6..0dd1854a5 100644
--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java
+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java
@@ -16,6 +16,13 @@
 
 package com.google.javascript.jscomp;
 
+import com.google.common.collect.Lists;
+import com.google.javascript.rhino.JSDocInfo;
+import com.google.javascript.rhino.Node;
+
+import java.util.Collection;
+import java.util.List;
+
 /**
  * Tests for {@link ScopedAliases}
  *
@@ -89,7 +96,151 @@ public class ScopedAliasesTest extends CompilerTestCase {
         "goog.method();g.method();");
   }
 
-  // TODO(robbyw): Test JsDoc aliasing.
+  public void testPropertiesNotChanged() {
+    testScopedNoChanges("var x = goog.dom;", "y.x();");
+  }
+
+  private void testTypes(String aliases, String code) {
+    testScopedNoChanges(aliases, code);
+    Compiler lastCompiler = getLastCompiler();
+    new TypeVerifyingPass(lastCompiler).process(lastCompiler.externsRoot,
+        lastCompiler.jsRoot);
+  }
+
+  public void testJsDocType() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @type {x} */ types.actual;"
+        + "/** @type {goog.Timer} */ types.expected;");
+  }
+
+  public void testJsDocParameter() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @param {x} a */ types.actual;"
+        + "/** @param {goog.Timer} a */ types.expected;");
+  }
+
+  public void testJsDocExtends() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @extends {x} */ types.actual;"
+        + "/** @extends {goog.Timer} */ types.expected;");
+  }
+
+  public void testJsDocImplements() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @implements {x} */ types.actual;"
+        + "/** @implements {goog.Timer} */ types.expected;");
+  }
+
+  public void testJsDocEnum() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @enum {x} */ types.actual;"
+        + "/** @enum {goog.Timer} */ types.expected;");
+  }
+
+  public void testJsDocReturn() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @return {x} */ types.actual;"
+        + "/** @return {goog.Timer} */ types.expected;");
+  }
+
+  public void testJsDocThis() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @this {x} */ types.actual;"
+        + "/** @this {goog.Timer} */ types.expected;");
+  }
+
+  public void testJsDocThrows() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @throws {x} */ types.actual;"
+        + "/** @throws {goog.Timer} */ types.expected;");
+  }
+
+  public void testJsDocSubType() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @type {x.Enum} */ types.actual;"
+        + "/** @type {goog.Timer.Enum} */ types.expected;");
+  }
+
+  public void testJsDocTypedef() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @typedef {x} */ types.actual;"
+        + "/** @typedef {goog.Timer} */ types.expected;");
+  }
+
+  public void testArrayJsDoc() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @type {Array.<x>} */ types.actual;"
+        + "/** @type {Array.<goog.Timer>} */ types.expected;");
+  }
+
+  public void testObjectJsDoc() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @type {{someKey: x}} */ types.actual;"
+        + "/** @type {{someKey: goog.Timer}} */ types.expected;");
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @type {{x: number}} */ types.actual;"
+        + "/** @type {{x: number}} */ types.expected;");
+  }
+
+  public void testUnionJsDoc() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @type {x|Object} */ types.actual;"
+        + "/** @type {goog.Timer|Object} */ types.expected;");
+  }
+
+  public void testFunctionJsDoc() {
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @type {function(x) : void} */ types.actual;"
+        + "/** @type {function(goog.Timer) : void} */ types.expected;");
+    testTypes(
+        "var x = goog.Timer;",
+        ""
+        + "/** @type {function() : x} */ types.actual;"
+        + "/** @type {function() : goog.Timer} */ types.expected;");
+  }
+
+  public void testTestTypes() {
+    try {
+      testTypes(
+          "var x = goog.Timer;",
+          ""
+          + "/** @type {function() : x} */ types.actual;"
+          + "/** @type {function() : wrong.wrong} */ types.expected;");
+      fail("Test types should fail here.");
+    } catch (AssertionError e) {
+    }
+  }
+
   // TODO(robbyw): What if it's recursive?  var goog = goog.dom;
 
   // FAILURE CASES
@@ -140,4 +291,44 @@ public class ScopedAliasesTest extends CompilerTestCase {
   protected ScopedAliases getProcessor(Compiler compiler) {
     return new ScopedAliases(compiler);
   }
+
+  private static class TypeVerifyingPass
+      implements CompilerPass, NodeTraversal.Callback {
+    private final Compiler compiler;
+    private List<String> actualTypes = null;
+
+    public TypeVerifyingPass(Compiler compiler) {
+      this.compiler = compiler;
+    }
+
+    public void process(Node externs, Node root) {
+      NodeTraversal.traverse(compiler, root, this);
+    }
+
+    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,
+        Node parent) {
+      return true;
+    }
+
+    public void visit(NodeTraversal t, Node n, Node parent) {
+      JSDocInfo info = n.getJSDocInfo();
+      if (info != null) {
+        Collection<Node> typeNodes = info.getTypeNodes();
+        if (typeNodes.size() > 0) {
+          if (actualTypes != null) {
+            List<String> expectedTypes = Lists.newArrayList();
+            for (Node typeNode : info.getTypeNodes()) {
+              expectedTypes.add(typeNode.toStringTree());
+            }
+            assertEquals(expectedTypes, actualTypes);
+          } else {
+            actualTypes = Lists.newArrayList();
+            for (Node typeNode : info.getTypeNodes()) {
+              actualTypes.add(typeNode.toStringTree());
+            }
+          }
+        }
+      }
+    }
+  }
 }
diff --git a/test/com/google/javascript/jscomp/parsing/ParserTest.java b/test/com/google/javascript/jscomp/parsing/ParserTest.java
index e5fe3c875..6ca995fc0 100644
--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java
@@ -716,6 +716,10 @@ public class ParserTest extends BaseJSTypeTestCase {
     parse("var x = /** @type {void} */ (y);");
   }
 
+  public void testUnfinishedComment() {
+    parseError("/** this is a comment ", "unterminated comment");
+  }
+
   public void testParseBlockDescription() {
     Node n = parse("/** This is a variable. */ var x;");
     Node var = n.getFirstChild();
