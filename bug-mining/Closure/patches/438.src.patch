diff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java
index 655145b88..5e3f4d6e0 100644
--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java
+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java
@@ -184,6 +184,7 @@ public final class DefaultPassConfig extends PassConfig {
     if (options.needsTranspilationFrom(ES6) || options.needsTranspilationFrom(ES7)) {
       TranspilationPasses.addEs6EarlyPasses(passes);
       TranspilationPasses.addEs6LatePasses(passes);
+      TranspilationPasses.addEs6PassesAfterNTI(passes);
       TranspilationPasses.addPostCheckPasses(passes);
       if (options.rewritePolyfills) {
         TranspilationPasses.addRewritePolyfillPass(passes);
@@ -373,6 +374,7 @@ public final class DefaultPassConfig extends PassConfig {
 
     if (options.needsTranspilationFrom(ES6)) {
       TranspilationPasses.addEs6LatePasses(checks);
+      TranspilationPasses.addEs6PassesAfterNTI(checks);
       if (options.rewritePolyfills) {
         TranspilationPasses.addRewritePolyfillPass(checks);
       }
@@ -389,7 +391,7 @@ public final class DefaultPassConfig extends PassConfig {
       checks.add(convertStaticInheritance);
     }
 
-    // End of ES6 transpilation passes.
+    // End of ES6 transpilation passes before NTI.
 
     if (!options.skipNonTranspilationPasses) {
       addNonTranspilationCheckPasses(checks);
diff --git a/src/com/google/javascript/jscomp/Es6ToEs3Converter.java b/src/com/google/javascript/jscomp/EarlyEs6ToEs3Converter.java
similarity index 55%
rename from src/com/google/javascript/jscomp/Es6ToEs3Converter.java
rename to src/com/google/javascript/jscomp/EarlyEs6ToEs3Converter.java
index 7becfb65e..041742492 100644
--- a/src/com/google/javascript/jscomp/Es6ToEs3Converter.java
+++ b/src/com/google/javascript/jscomp/EarlyEs6ToEs3Converter.java
@@ -17,9 +17,8 @@ package com.google.javascript.jscomp;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
-import com.google.common.base.Preconditions;
-import com.google.common.collect.Lists;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
+import com.google.javascript.jscomp.NodeTraversal.Callback;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.JSDocInfo;
 import com.google.javascript.rhino.JSDocInfoBuilder;
@@ -28,12 +27,11 @@ import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Locale;
 
 /**
- * Converts ES6 code to valid ES5 code. This class does most of the transpilation, and
- * https://github.com/google/closure-compiler/wiki/ECMAScript6 lists which ES6 features are
- * supported. Other classes that start with "Es6" do other parts of the transpilation.
+ * Converts ES6 code to valid ES5 code. This class does transpilation for Rest, Spread, and Symbols,
+ * which should be transpiled before NTI.
+ * Other classes that start with "Es6" do other parts of the transpilation.
  *
  * <p>In most cases, the output is valid as ES3 (hence the class name) but in some cases, if
  * the output language is set to ES5, we rely on ES5 features such as getters, setters,
@@ -41,20 +39,9 @@ import java.util.Locale;
  *
  * @author tbreisacher@google.com (Tyler Breisacher)
  */
-// TODO(tbreisacher): This class does too many things. Break it into smaller passes.
-public final class Es6ToEs3Converter implements NodeTraversal.Callback, HotSwapCompilerPass {
+public final class EarlyEs6ToEs3Converter implements Callback, HotSwapCompilerPass {
   private final AbstractCompiler compiler;
 
-  static final DiagnosticType CANNOT_CONVERT = DiagnosticType.error(
-      "JSC_CANNOT_CONVERT",
-      "This code cannot be converted from ES6. {0}");
-
-  // TODO(tbreisacher): Remove this once we have implemented transpilation for all the features
-  // we intend to support.
-  static final DiagnosticType CANNOT_CONVERT_YET = DiagnosticType.error(
-      "JSC_CANNOT_CONVERT_YET",
-      "ES6 transpilation of ''{0}'' is not yet implemented.");
-
   static final DiagnosticType BAD_REST_PARAMETER_ANNOTATION = DiagnosticType.warning(
       "BAD_REST_PARAMETER_ANNOTATION",
       "Missing \"...\" in type annotation for rest parameter.");
@@ -67,13 +54,7 @@ public final class Es6ToEs3Converter implements NodeTraversal.Callback, HotSwapC
 
   private static final String FRESH_SPREAD_VAR = "$jscomp$spread$args";
 
-  private static final String FRESH_COMP_PROP_VAR = "$jscomp$compprop";
-
-  private static final String ITER_BASE = "$jscomp$iter$";
-
-  private static final String ITER_RESULT = "$jscomp$key$";
-
-  public Es6ToEs3Converter(AbstractCompiler compiler) {
+  public EarlyEs6ToEs3Converter(AbstractCompiler compiler) {
     this.compiler = compiler;
   }
 
@@ -102,7 +83,8 @@ public final class Es6ToEs3Converter implements NodeTraversal.Callback, HotSwapC
       case GETTER_DEF:
       case SETTER_DEF:
         if (compiler.getOptions().getLanguageOut() == LanguageMode.ECMASCRIPT3) {
-          cannotConvert(n, "ES5 getters/setters (consider using --language_out=ES5)");
+          Es6ToEs3Util.cannotConvert(
+              compiler, n, "ES5 getters/setters (consider using --language_out=ES5)");
           return false;
         }
         break;
@@ -130,20 +112,6 @@ public final class Es6ToEs3Converter implements NodeTraversal.Callback, HotSwapC
           visitGetprop(t, n);
         }
         break;
-      case OBJECTLIT:
-        visitObject(n);
-        break;
-      case MEMBER_FUNCTION_DEF:
-        if (parent.isObjectLit()) {
-          visitMemberFunctionDefInObjectLit(n, parent);
-        }
-        break;
-      case FOR_OF:
-        visitForOf(n, parent);
-        break;
-      case STRING_KEY:
-        visitStringKey(n);
-        break;
       case ARRAYLIT:
       case NEW:
       case CALL:
@@ -154,14 +122,6 @@ public final class Es6ToEs3Converter implements NodeTraversal.Callback, HotSwapC
           }
         }
         break;
-      case TAGGED_TEMPLATELIT:
-        Es6TemplateLiterals.visitTaggedTemplateLiteral(t, n);
-        break;
-      case TEMPLATELIT:
-        if (!parent.isTaggedTemplateLit()) {
-          Es6TemplateLiterals.visitTemplateLiteral(t, n);
-        }
-        break;
       default:
         break;
     }
@@ -203,86 +163,6 @@ public final class Es6ToEs3Converter implements NodeTraversal.Callback, HotSwapC
     }
   }
 
-  /**
-   * Converts a member definition in an object literal to an ES3 key/value pair.
-   * Member definitions in classes are handled in {@link #Es6RewriteClass}.
-   */
-  private void visitMemberFunctionDefInObjectLit(Node n, Node parent) {
-    String name = n.getString();
-    Node nameNode = n.getFirstFirstChild();
-    Node stringKey = IR.stringKey(name, n.getFirstChild().detach());
-    stringKey.setJSDocInfo(n.getJSDocInfo());
-    parent.replaceChild(n, stringKey);
-    stringKey.useSourceInfoFrom(nameNode);
-    compiler.reportChangeToEnclosingScope(stringKey);
-  }
-
-  /**
-   * Converts extended object literal {a} to {a:a}.
-   */
-  // TODO(blickly): Separate this so it can be part of the normalization early transpilation passes.
-  private void visitStringKey(Node n) {
-    if (!n.hasChildren()) {
-      Node name = IR.name(n.getString());
-      name.useSourceInfoIfMissingFrom(n);
-      n.addChildToBack(name);
-      compiler.reportChangeToEnclosingScope(name);
-    }
-  }
-
-  private void visitForOf(Node node, Node parent) {
-    Node variable = node.removeFirstChild();
-    Node iterable = node.removeFirstChild();
-    Node body = node.removeFirstChild();
-    JSDocInfo varJSDocInfo = variable.getJSDocInfo();
-
-    Node iterName = IR.name(ITER_BASE + compiler.getUniqueNameIdSupplier().get());
-    iterName.makeNonIndexable();
-    Node getNext = IR.call(IR.getprop(iterName.cloneTree(), IR.string("next")));
-    String variableName;
-    Token declType;
-    if (variable.isName()) {
-      declType = Token.NAME;
-      variableName = variable.getQualifiedName();
-    } else {
-      Preconditions.checkState(NodeUtil.isNameDeclaration(variable),
-          "Expected var, let, or const. Got %s", variable);
-      declType = variable.getToken();
-      variableName = variable.getFirstChild().getQualifiedName();
-    }
-    Node iterResult = IR.name(ITER_RESULT + variableName);
-    iterResult.makeNonIndexable();
-
-    Node init = IR.var(iterName.cloneTree(), makeIterator(compiler, iterable));
-    Node initIterResult = iterResult.cloneTree();
-    initIterResult.addChildToFront(getNext.cloneTree());
-    init.addChildToBack(initIterResult);
-
-    Node cond = IR.not(IR.getprop(iterResult.cloneTree(), IR.string("done")));
-    Node incr = IR.assign(iterResult.cloneTree(), getNext.cloneTree());
-
-    Node declarationOrAssign;
-    if (declType == Token.NAME) {
-      declarationOrAssign = IR.assign(
-          IR.name(variableName).useSourceInfoFrom(variable),
-          IR.getprop(iterResult.cloneTree(), IR.string("value")));
-      declarationOrAssign.setJSDocInfo(varJSDocInfo);
-      declarationOrAssign = IR.exprResult(declarationOrAssign);
-    } else {
-      declarationOrAssign = new Node(
-          declType,
-          IR.name(variableName).useSourceInfoFrom(variable.getFirstChild()));
-      declarationOrAssign.getFirstChild().addChildToBack(
-          IR.getprop(iterResult.cloneTree(), IR.string("value")));
-      declarationOrAssign.setJSDocInfo(varJSDocInfo);
-    }
-    Node newBody = IR.block(declarationOrAssign, body).useSourceInfoFrom(body);
-    Node newFor = IR.forNode(init, cond, incr, newBody);
-    newFor.useSourceInfoIfMissingFromForTree(node);
-    parent.replaceChild(node, newFor);
-    compiler.reportChangeToEnclosingScope(newFor);
-  }
-
   /**
    * Processes a rest parameter
    */
@@ -382,7 +262,7 @@ public final class Es6ToEs3Converter implements NodeTraversal.Callback, HotSwapC
           groups.add(currGroup);
           currGroup = null;
         }
-        groups.add(arrayFromIterable(compiler, currElement.removeFirstChild()));
+        groups.add(Es6ToEs3Util.arrayFromIterable(compiler, currElement.removeFirstChild()));
       } else {
         if (currGroup == null) {
           currGroup = IR.arraylit();
@@ -422,7 +302,8 @@ public final class Es6ToEs3Converter implements NodeTraversal.Callback, HotSwapC
     } else {
       if (compiler.getOptions().getLanguageOut() == LanguageMode.ECMASCRIPT3) {
         // TODO(tbreisacher): Support this in ES3 too by not relying on Function.bind.
-        cannotConvert(node, "\"...\" passed to a constructor (consider using --language_out=ES5)");
+        Es6ToEs3Util.cannotConvert(
+            compiler, node, "\"...\" passed to a constructor (consider using --language_out=ES5)");
       }
       Node bindApply = NodeUtil.newQName(compiler,
           "Function.prototype.bind.apply");
@@ -432,110 +313,4 @@ public final class Es6ToEs3Converter implements NodeTraversal.Callback, HotSwapC
     parent.replaceChild(node, result);
     compiler.reportChangeToEnclosingScope(result);
   }
-
-  private void visitObject(Node obj) {
-    for (Node child : obj.children()) {
-      if (child.isComputedProp()) {
-        visitObjectWithComputedProperty(obj);
-        return;
-      }
-    }
-  }
-
-  private void visitObjectWithComputedProperty(Node obj) {
-    checkArgument(obj.isObjectLit());
-    List<Node> props = new ArrayList<>();
-    Node currElement = obj.getFirstChild();
-
-    while (currElement != null) {
-      if (currElement.getBooleanProp(Node.COMPUTED_PROP_GETTER)
-          || currElement.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
-        cannotConvertYet(currElement, "computed getter/setter in an object literal");
-        return;
-      } else if (currElement.isGetterDef() || currElement.isSetterDef()) {
-        currElement = currElement.getNext();
-      } else {
-        Node nextNode = currElement.getNext();
-        obj.removeChild(currElement);
-        props.add(currElement);
-        currElement = nextNode;
-      }
-    }
-
-    String objName = FRESH_COMP_PROP_VAR + compiler.getUniqueNameIdSupplier().get();
-
-    props = Lists.reverse(props);
-    Node result = IR.name(objName);
-    for (Node propdef : props) {
-      if (propdef.isComputedProp()) {
-        Node propertyExpression = propdef.removeFirstChild();
-        Node value = propdef.removeFirstChild();
-        result = IR.comma(
-            IR.assign(
-                IR.getelem(
-                    IR.name(objName),
-                    propertyExpression),
-                value),
-            result);
-      } else {
-        if (!propdef.hasChildren()) {
-          Node name = IR.name(propdef.getString()).useSourceInfoIfMissingFrom(propdef);
-          propdef.addChildToBack(name);
-        }
-        Node val = propdef.removeFirstChild();
-        propdef.setToken(Token.STRING);
-        Token type = propdef.isQuotedString() ? Token.GETELEM : Token.GETPROP;
-        Node access = new Node(type, IR.name(objName), propdef);
-        result = IR.comma(IR.assign(access, val), result);
-      }
-    }
-
-    Node statement = obj;
-    while (!NodeUtil.isStatement(statement)) {
-      statement = statement.getParent();
-    }
-
-    result.useSourceInfoIfMissingFromForTree(obj);
-    obj.replaceWith(result);
-
-    Node var = IR.var(IR.name(objName), obj);
-    var.useSourceInfoIfMissingFromForTree(statement);
-    statement.getParent().addChildBefore(var, statement);
-    compiler.reportChangeToEnclosingScope(var);
-  }
-
-  private void cannotConvert(Node n, String message) {
-    compiler.report(JSError.make(n, CANNOT_CONVERT, message));
-  }
-
-  /**
-   * Warns the user that the given ES6 feature cannot be converted to ES3
-   * because the transpilation is not yet implemented. A call to this method
-   * is essentially a "TODO(tbreisacher): Implement {@code feature}" comment.
-   */
-  private void cannotConvertYet(Node n, String feature) {
-    compiler.report(JSError.make(n, CANNOT_CONVERT_YET, feature));
-  }
-
-  /**
-   * Returns a call to {@code $jscomp.makeIterator} with {@code iterable} as its argument.
-   */
-  static Node makeIterator(AbstractCompiler compiler, Node iterable) {
-    return callEs6RuntimeFunction(compiler, iterable, "makeIterator");
-  }
-
-  /**
-   * Returns a call to $jscomp.arrayFromIterable with {@code iterable} as its argument.
-   */
-  private static Node arrayFromIterable(AbstractCompiler compiler, Node iterable) {
-    return callEs6RuntimeFunction(compiler, iterable, "arrayFromIterable");
-  }
-
-  private static Node callEs6RuntimeFunction(
-      AbstractCompiler compiler, Node iterable, String function) {
-    compiler.ensureLibraryInjected("es6/util/" + function.toLowerCase(Locale.US), false);
-    return IR.call(
-        NodeUtil.newQName(compiler, "$jscomp." + function),
-        iterable);
-  }
 }
diff --git a/src/com/google/javascript/jscomp/Es6ConvertSuper.java b/src/com/google/javascript/jscomp/Es6ConvertSuper.java
index 3f703a6c0..163d680f5 100644
--- a/src/com/google/javascript/jscomp/Es6ConvertSuper.java
+++ b/src/com/google/javascript/jscomp/Es6ConvertSuper.java
@@ -16,7 +16,7 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT_YET;
+import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT_YET;
 
 import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
@@ -30,7 +30,7 @@ import com.google.javascript.rhino.Token;
 /**
  * Converts {@code super.method()} calls and adds constructors to any classes that lack them.
  *
- * <p>This has to run before the main {@link Es6ToEs3Converter} pass. The super() constructor calls
+ * <p>This has to run before the main {@link Es6RewriteClass} pass. The super() constructor calls
  * are not converted here, but rather in {@link Es6ConvertSuperConstructorCalls}, which runs later.
  */
 public final class Es6ConvertSuper extends NodeTraversal.AbstractPostOrderCallback
diff --git a/src/com/google/javascript/jscomp/Es6ConvertSuperConstructorCalls.java b/src/com/google/javascript/jscomp/Es6ConvertSuperConstructorCalls.java
index 8c7176995..f19f058fd 100644
--- a/src/com/google/javascript/jscomp/Es6ConvertSuperConstructorCalls.java
+++ b/src/com/google/javascript/jscomp/Es6ConvertSuperConstructorCalls.java
@@ -18,7 +18,7 @@ package com.google.javascript.jscomp;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
+import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT;
 
 import com.google.javascript.jscomp.GlobalNamespace.Name;
 import com.google.javascript.jscomp.GlobalNamespace.Ref;
diff --git a/src/com/google/javascript/jscomp/Es6ExtractClasses.java b/src/com/google/javascript/jscomp/Es6ExtractClasses.java
index 713cba26b..6dcbf02fd 100644
--- a/src/com/google/javascript/jscomp/Es6ExtractClasses.java
+++ b/src/com/google/javascript/jscomp/Es6ExtractClasses.java
@@ -17,7 +17,7 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
+import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT;
 
 import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;
 import com.google.javascript.jscomp.deps.ModuleNames;
@@ -42,7 +42,7 @@ import java.util.Set;
  *   foo($jscomp$classdecl$var0);
  * </code>
  * <p>
- * This must be done before {@link Es6ToEs3Converter}, because that pass only handles classes
+ * This must be done before {@link Es6RewriteClass}, because that pass only handles classes
  * that are declarations or simple assignments.
  * @see Es6RewriteClass#visitClass(NodeTraversal, Node, Node)
  */
diff --git a/src/com/google/javascript/jscomp/Es6RewriteClass.java b/src/com/google/javascript/jscomp/Es6RewriteClass.java
index b4e657eb5..ee506a93e 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteClass.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteClass.java
@@ -17,8 +17,8 @@ package com.google.javascript.jscomp;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
-import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT_YET;
+import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT;
+import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT_YET;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterables;
diff --git a/src/com/google/javascript/jscomp/Es6RewriteDestructuring.java b/src/com/google/javascript/jscomp/Es6RewriteDestructuring.java
index 2431642ea..804437fe5 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteDestructuring.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteDestructuring.java
@@ -17,7 +17,7 @@ package com.google.javascript.jscomp;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.javascript.jscomp.Es6ToEs3Converter.makeIterator;
+import static com.google.javascript.jscomp.Es6ToEs3Util.makeIterator;
 
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.JSDocInfo;
diff --git a/src/com/google/javascript/jscomp/Es6RewriteGenerators.java b/src/com/google/javascript/jscomp/Es6RewriteGenerators.java
index eb5c31773..cdd1202ae 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteGenerators.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteGenerators.java
@@ -17,7 +17,7 @@ package com.google.javascript.jscomp;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.javascript.jscomp.Es6ToEs3Converter.makeIterator;
+import static com.google.javascript.jscomp.Es6ToEs3Util.makeIterator;
 
 import com.google.common.base.Joiner;
 import com.google.common.base.Supplier;
@@ -513,7 +513,7 @@ public final class Es6RewriteGenerators
         compiler.report(
             JSError.make(
                 currentStatement,
-                Es6ToEs3Converter.CANNOT_CONVERT_YET,
+                Es6ToEs3Util.CANNOT_CONVERT_YET,
                 "Breaking to a label that is not a loop"));
         return;
       }
@@ -637,7 +637,7 @@ public final class Es6RewriteGenerators
           compiler.report(
               JSError.make(
                   currentStatement,
-                  Es6ToEs3Converter.CANNOT_CONVERT_YET,
+                  Es6ToEs3Util.CANNOT_CONVERT_YET,
                   "Default case as intermediate case"));
         }
         equivBlock = IR.block(currCase.removeFirstChild());
@@ -1008,7 +1008,7 @@ public final class Es6RewriteGenerators
             compiler.report(
                 JSError.make(
                     n,
-                    Es6ToEs3Converter.CANNOT_CONVERT_YET,
+                    Es6ToEs3Util.CANNOT_CONVERT_YET,
                     "Case statements that contain yields"));
             return false;
           }
@@ -1029,7 +1029,7 @@ public final class Es6RewriteGenerators
         t.reportCodeChange();
       } else {
         compiler.report(
-            JSError.make(n, Es6ToEs3Converter.CANNOT_CONVERT, "Undecomposable expression"));
+            JSError.make(n, Es6ToEs3Util.CANNOT_CONVERT, "Undecomposable expression"));
       }
     }
 
diff --git a/src/com/google/javascript/jscomp/Es6RewriteModules.java b/src/com/google/javascript/jscomp/Es6RewriteModules.java
index 932df0350..3889b1cae 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteModules.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteModules.java
@@ -324,7 +324,7 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
       }
     } else if (export.getBooleanProp(Node.EXPORT_ALL_FROM)) {
       //   export * from 'moduleIdentifier';
-      compiler.report(JSError.make(export, Es6ToEs3Converter.CANNOT_CONVERT_YET,
+      compiler.report(JSError.make(export, Es6ToEs3Util.CANNOT_CONVERT_YET,
           "Wildcard export"));
     } else if (export.hasTwoChildren()) {
       //   export {x, y as z} from 'moduleIdentifier';
diff --git a/src/com/google/javascript/jscomp/Es6ToEs3Util.java b/src/com/google/javascript/jscomp/Es6ToEs3Util.java
new file mode 100644
index 000000000..4da1f3d2e
--- /dev/null
+++ b/src/com/google/javascript/jscomp/Es6ToEs3Util.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2014 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.javascript.jscomp;
+
+import com.google.javascript.rhino.IR;
+import com.google.javascript.rhino.Node;
+import java.util.Locale;
+
+/**
+ * Util functions for converting Es6 to Es5
+ *
+ * @author tbreisacher@google.com (Tyler Breisacher)
+ */
+public final class Es6ToEs3Util {
+
+  static final DiagnosticType CANNOT_CONVERT = DiagnosticType.error(
+      "JSC_CANNOT_CONVERT",
+      "This code cannot be converted from ES6. {0}");
+
+  // TODO(tbreisacher): Remove this once we have implemented transpilation for all the features
+  // we intend to support.
+  static final DiagnosticType CANNOT_CONVERT_YET = DiagnosticType.error(
+      "JSC_CANNOT_CONVERT_YET",
+      "ES6 transpilation of ''{0}'' is not yet implemented.");
+
+  static final DiagnosticType BAD_REST_PARAMETER_ANNOTATION = DiagnosticType.warning(
+      "BAD_REST_PARAMETER_ANNOTATION",
+      "Missing \"...\" in type annotation for rest parameter.");
+
+  static void cannotConvert(AbstractCompiler compiler, Node n, String message) {
+    compiler.report(JSError.make(n, CANNOT_CONVERT, message));
+  }
+
+  /**
+   * Warns the user that the given ES6 feature cannot be converted to ES3
+   * because the transpilation is not yet implemented. A call to this method
+   * is essentially a "TODO(tbreisacher): Implement {@code feature}" comment.
+   */
+  static void cannotConvertYet(AbstractCompiler compiler, Node n, String feature) {
+    compiler.report(JSError.make(n, CANNOT_CONVERT_YET, feature));
+  }
+
+  /**
+   * Returns a call to {@code $jscomp.makeIterator} with {@code iterable} as its argument.
+   */
+  static Node makeIterator(AbstractCompiler compiler, Node iterable) {
+    return callEs6RuntimeFunction(compiler, iterable, "makeIterator");
+  }
+
+  /**
+   * Returns a call to $jscomp.arrayFromIterable with {@code iterable} as its argument.
+   */
+  static Node arrayFromIterable(AbstractCompiler compiler, Node iterable) {
+    return callEs6RuntimeFunction(compiler, iterable, "arrayFromIterable");
+  }
+
+  static Node callEs6RuntimeFunction(
+      AbstractCompiler compiler, Node iterable, String function) {
+    compiler.ensureLibraryInjected("es6/util/" + function.toLowerCase(Locale.US), false);
+    return IR.call(
+        NodeUtil.newQName(compiler, "$jscomp." + function),
+        iterable);
+  }
+}
diff --git a/src/com/google/javascript/jscomp/LateEs6ToEs3Converter.java b/src/com/google/javascript/jscomp/LateEs6ToEs3Converter.java
new file mode 100644
index 000000000..16407a4a9
--- /dev/null
+++ b/src/com/google/javascript/jscomp/LateEs6ToEs3Converter.java
@@ -0,0 +1,269 @@
+/*
+ * Copyright 2014 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.javascript.jscomp;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
+import com.google.javascript.rhino.IR;
+import com.google.javascript.rhino.JSDocInfo;
+import com.google.javascript.rhino.Node;
+import com.google.javascript.rhino.Token;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Converts ES6 code to valid ES5 code. This class does most of the transpilation, and
+ * https://github.com/google/closure-compiler/wiki/ECMAScript6 lists which ES6 features are
+ * supported. Other classes that start with "Es6" do other parts of the transpilation.
+ *
+ * <p>In most cases, the output is valid as ES3 (hence the class name) but in some cases, if
+ * the output language is set to ES5, we rely on ES5 features such as getters, setters,
+ * and Object.defineProperties.
+ *
+ * @author tbreisacher@google.com (Tyler Breisacher)
+ */
+// TODO(tbreisacher): This class does too many things. Break it into smaller passes.
+public final class LateEs6ToEs3Converter implements NodeTraversal.Callback, HotSwapCompilerPass {
+  private final AbstractCompiler compiler;
+
+  private static final String FRESH_COMP_PROP_VAR = "$jscomp$compprop";
+
+  private static final String ITER_BASE = "$jscomp$iter$";
+
+  private static final String ITER_RESULT = "$jscomp$key$";
+
+  public LateEs6ToEs3Converter(AbstractCompiler compiler) {
+    this.compiler = compiler;
+  }
+
+  @Override
+  public void process(Node externs, Node root) {
+    TranspilationPasses.processTranspile(compiler, externs, this);
+    TranspilationPasses.processTranspile(compiler, root, this);
+  }
+
+  @Override
+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {
+    TranspilationPasses.hotSwapTranspile(compiler, scriptRoot, this);
+  }
+
+  @Override
+  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
+    switch (n.getToken()) {
+      case GETTER_DEF:
+      case SETTER_DEF:
+        if (compiler.getOptions().getLanguageOut() == LanguageMode.ECMASCRIPT3) {
+          Es6ToEs3Util.cannotConvert(
+              compiler, n, "ES5 getters/setters (consider using --language_out=ES5)");
+          return false;
+        }
+        break;
+      case FUNCTION:
+        if (n.isAsyncFunction()) {
+          throw new IllegalStateException("async functions should have already been converted");
+        }
+        break;
+      default:
+        break;
+    }
+    return true;
+  }
+
+  @Override
+  public void visit(NodeTraversal t, Node n, Node parent) {
+    switch (n.getToken()) {
+      case OBJECTLIT:
+        visitObject(n);
+        break;
+      case MEMBER_FUNCTION_DEF:
+        if (parent.isObjectLit()) {
+          visitMemberFunctionDefInObjectLit(n, parent);
+        }
+        break;
+      case FOR_OF:
+        visitForOf(n, parent);
+        break;
+      case STRING_KEY:
+        visitStringKey(n);
+        break;
+      case TAGGED_TEMPLATELIT:
+        Es6TemplateLiterals.visitTaggedTemplateLiteral(t, n);
+        break;
+      case TEMPLATELIT:
+        if (!parent.isTaggedTemplateLit()) {
+          Es6TemplateLiterals.visitTemplateLiteral(t, n);
+        }
+        break;
+      default:
+        break;
+    }
+  }
+
+  /**
+   * Converts a member definition in an object literal to an ES3 key/value pair.
+   * Member definitions in classes are handled in {@link Es6RewriteClass}.
+   */
+  private void visitMemberFunctionDefInObjectLit(Node n, Node parent) {
+    String name = n.getString();
+    Node nameNode = n.getFirstFirstChild();
+    Node stringKey = IR.stringKey(name, n.getFirstChild().detach());
+    stringKey.setJSDocInfo(n.getJSDocInfo());
+    parent.replaceChild(n, stringKey);
+    stringKey.useSourceInfoFrom(nameNode);
+    compiler.reportChangeToEnclosingScope(stringKey);
+  }
+
+  /**
+   * Converts extended object literal {a} to {a:a}.
+   */
+  // TODO(blickly): Separate this so it can be part of the normalization early transpilation passes.
+  private void visitStringKey(Node n) {
+    if (!n.hasChildren()) {
+      Node name = IR.name(n.getString());
+      name.useSourceInfoIfMissingFrom(n);
+      n.addChildToBack(name);
+      compiler.reportChangeToEnclosingScope(name);
+    }
+  }
+
+  private void visitForOf(Node node, Node parent) {
+    Node variable = node.removeFirstChild();
+    Node iterable = node.removeFirstChild();
+    Node body = node.removeFirstChild();
+    JSDocInfo varJSDocInfo = variable.getJSDocInfo();
+
+    Node iterName = IR.name(ITER_BASE + compiler.getUniqueNameIdSupplier().get());
+    iterName.makeNonIndexable();
+    Node getNext = IR.call(IR.getprop(iterName.cloneTree(), IR.string("next")));
+    String variableName;
+    Token declType;
+    if (variable.isName()) {
+      declType = Token.NAME;
+      variableName = variable.getQualifiedName();
+    } else {
+      Preconditions.checkState(NodeUtil.isNameDeclaration(variable),
+          "Expected var, let, or const. Got %s", variable);
+      declType = variable.getToken();
+      variableName = variable.getFirstChild().getQualifiedName();
+    }
+    Node iterResult = IR.name(ITER_RESULT + variableName);
+    iterResult.makeNonIndexable();
+
+    Node init = IR.var(iterName.cloneTree(), Es6ToEs3Util.makeIterator(compiler, iterable));
+    Node initIterResult = iterResult.cloneTree();
+    initIterResult.addChildToFront(getNext.cloneTree());
+    init.addChildToBack(initIterResult);
+
+    Node cond = IR.not(IR.getprop(iterResult.cloneTree(), IR.string("done")));
+    Node incr = IR.assign(iterResult.cloneTree(), getNext.cloneTree());
+
+    Node declarationOrAssign;
+    if (declType == Token.NAME) {
+      declarationOrAssign = IR.assign(
+          IR.name(variableName).useSourceInfoFrom(variable),
+          IR.getprop(iterResult.cloneTree(), IR.string("value")));
+      declarationOrAssign.setJSDocInfo(varJSDocInfo);
+      declarationOrAssign = IR.exprResult(declarationOrAssign);
+    } else {
+      declarationOrAssign = new Node(
+          declType,
+          IR.name(variableName).useSourceInfoFrom(variable.getFirstChild()));
+      declarationOrAssign.getFirstChild().addChildToBack(
+          IR.getprop(iterResult.cloneTree(), IR.string("value")));
+      declarationOrAssign.setJSDocInfo(varJSDocInfo);
+    }
+    Node newBody = IR.block(declarationOrAssign, body).useSourceInfoFrom(body);
+    Node newFor = IR.forNode(init, cond, incr, newBody);
+    newFor.useSourceInfoIfMissingFromForTree(node);
+    parent.replaceChild(node, newFor);
+    compiler.reportChangeToEnclosingScope(newFor);
+  }
+
+  private void visitObject(Node obj) {
+    for (Node child : obj.children()) {
+      if (child.isComputedProp()) {
+        visitObjectWithComputedProperty(obj);
+        return;
+      }
+    }
+  }
+
+  private void visitObjectWithComputedProperty(Node obj) {
+    checkArgument(obj.isObjectLit());
+    List<Node> props = new ArrayList<>();
+    Node currElement = obj.getFirstChild();
+
+    while (currElement != null) {
+      if (currElement.getBooleanProp(Node.COMPUTED_PROP_GETTER)
+          || currElement.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
+        Es6ToEs3Util.cannotConvertYet(
+            compiler, currElement, "computed getter/setter in an object literal");
+        return;
+      } else if (currElement.isGetterDef() || currElement.isSetterDef()) {
+        currElement = currElement.getNext();
+      } else {
+        Node nextNode = currElement.getNext();
+        obj.removeChild(currElement);
+        props.add(currElement);
+        currElement = nextNode;
+      }
+    }
+
+    String objName = FRESH_COMP_PROP_VAR + compiler.getUniqueNameIdSupplier().get();
+
+    props = Lists.reverse(props);
+    Node result = IR.name(objName);
+    for (Node propdef : props) {
+      if (propdef.isComputedProp()) {
+        Node propertyExpression = propdef.removeFirstChild();
+        Node value = propdef.removeFirstChild();
+        result = IR.comma(
+            IR.assign(
+                IR.getelem(
+                    IR.name(objName),
+                    propertyExpression),
+                value),
+            result);
+      } else {
+        if (!propdef.hasChildren()) {
+          Node name = IR.name(propdef.getString()).useSourceInfoIfMissingFrom(propdef);
+          propdef.addChildToBack(name);
+        }
+        Node val = propdef.removeFirstChild();
+        propdef.setToken(Token.STRING);
+        Token type = propdef.isQuotedString() ? Token.GETELEM : Token.GETPROP;
+        Node access = new Node(type, IR.name(objName), propdef);
+        result = IR.comma(IR.assign(access, val), result);
+      }
+    }
+
+    Node statement = obj;
+    while (!NodeUtil.isStatement(statement)) {
+      statement = statement.getParent();
+    }
+
+    result.useSourceInfoIfMissingFromForTree(obj);
+    obj.replaceWith(result);
+
+    Node var = IR.var(IR.name(objName), obj);
+    var.useSourceInfoIfMissingFromForTree(statement);
+    statement.getParent().addChildBefore(var, statement);
+    compiler.reportChangeToEnclosingScope(var);
+  }
+}
diff --git a/src/com/google/javascript/jscomp/TranspilationPasses.java b/src/com/google/javascript/jscomp/TranspilationPasses.java
index 9b9db8184..4e64362df 100644
--- a/src/com/google/javascript/jscomp/TranspilationPasses.java
+++ b/src/com/google/javascript/jscomp/TranspilationPasses.java
@@ -59,7 +59,8 @@ public class TranspilationPasses {
   }
 
   /**
-   * Adds all the late ES6 transpilation passes, which go after the Dart pass.
+   * Adds all the late ES6 transpilation passes, which go after the Dart pass
+   * and go before TypeChecking
    *
    * <p>Includes ES6 features that are best handled natively by the compiler.
    * As we convert more passes to handle these features, we will be moving the
@@ -69,8 +70,13 @@ public class TranspilationPasses {
   public static void addEs6LatePasses(List<PassFactory> passes) {
     passes.add(es6ExtractClasses);
     passes.add(es6RewriteClass);
-    passes.add(convertEs6ToEs3);
+    passes.add(earlyConvertEs6ToEs3);
     passes.add(rewriteBlockScopedDeclaration);
+  }
+
+  /** Adds all transpilation passes that runs after NTI */
+  public static void addEs6PassesAfterNTI(List<PassFactory> passes) {
+    passes.add(lateConvertEs6ToEs3);
     passes.add(rewriteGenerators);
   }
 
@@ -252,15 +258,34 @@ public class TranspilationPasses {
   };
 
   /**
-   * Does the main ES6 to ES3 conversion.
+   * Does ES6 to ES3 conversion of Rest, Spread and Symbol.
    * There are a few other passes which run before or after this one,
    * to convert constructs which are not converted by this pass.
    */
-  static final HotSwapPassFactory convertEs6ToEs3 =
-      new HotSwapPassFactory("convertEs6", true) {
+  static final HotSwapPassFactory earlyConvertEs6ToEs3 =
+      new HotSwapPassFactory("earlyConvertEs6", true) {
+    @Override
+    protected HotSwapCompilerPass create(final AbstractCompiler compiler) {
+      return new EarlyEs6ToEs3Converter(compiler);
+    }
+
+    @Override
+    protected FeatureSet featureSet() {
+      return ES8;
+    }
+  };
+
+  /**
+   * Does the main ES6 to ES3 conversion.
+   * There are a few other passes which run before this one,
+   * to convert constructs which are not converted by this pass.
+   * This pass can run after NTI
+   */
+  static final HotSwapPassFactory lateConvertEs6ToEs3 =
+      new HotSwapPassFactory("lateConvertEs6", true) {
     @Override
     protected HotSwapCompilerPass create(final AbstractCompiler compiler) {
-      return new Es6ToEs3Converter(compiler);
+      return new LateEs6ToEs3Converter(compiler);
     }
 
     @Override
diff --git a/test/com/google/javascript/jscomp/CompilerTestCase.java b/test/com/google/javascript/jscomp/CompilerTestCase.java
index 3d7f61454..1f48482de 100644
--- a/test/com/google/javascript/jscomp/CompilerTestCase.java
+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java
@@ -1678,6 +1678,7 @@ public abstract class CompilerTestCase extends TestCase {
     TranspilationPasses.addEs2016Passes(factories);
     TranspilationPasses.addEs6EarlyPasses(factories);
     TranspilationPasses.addEs6LatePasses(factories);
+    TranspilationPasses.addEs6PassesAfterNTI(factories);
     TranspilationPasses.addRewritePolyfillPass(factories);
     for (PassFactory factory : factories) {
       factory.create(compiler).process(externsRoot, codeRoot);
diff --git a/test/com/google/javascript/jscomp/Es6ExtractClassesTest.java b/test/com/google/javascript/jscomp/Es6ExtractClassesTest.java
index 5f79d133d..0556e661d 100644
--- a/test/com/google/javascript/jscomp/Es6ExtractClassesTest.java
+++ b/test/com/google/javascript/jscomp/Es6ExtractClassesTest.java
@@ -16,7 +16,7 @@
 
 package com.google.javascript.jscomp;
 
-import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
+import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT;
 
 import com.google.common.collect.ImmutableList;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
diff --git a/test/com/google/javascript/jscomp/Es6RewriteClassTest.java b/test/com/google/javascript/jscomp/Es6RewriteClassTest.java
index 6f3238bc0..632d7ded9 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteClassTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteClassTest.java
@@ -20,8 +20,8 @@ import static com.google.javascript.jscomp.Es6ConvertSuper.INVALID_SUPER_CALL;
 import static com.google.javascript.jscomp.Es6RewriteClass.CLASS_REASSIGNMENT;
 import static com.google.javascript.jscomp.Es6RewriteClass.CONFLICTING_GETTER_SETTER_TYPE;
 import static com.google.javascript.jscomp.Es6RewriteClass.DYNAMIC_EXTENDS_TYPE;
-import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
-import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT_YET;
+import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT;
+import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT_YET;
 import static com.google.javascript.jscomp.parsing.parser.FeatureSet.ES6_MODULES;
 
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
diff --git a/test/com/google/javascript/jscomp/Es6RewriteGeneratorsTest.java b/test/com/google/javascript/jscomp/Es6RewriteGeneratorsTest.java
index d8bfa4009..7d4a8e5d2 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteGeneratorsTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteGeneratorsTest.java
@@ -409,18 +409,18 @@ public final class Es6RewriteGeneratorsTest extends CompilerTestCase {
 
   public void testUndecomposableExpression() {
     testError("function *f() { obj.bar(yield 5); }",
-        Es6ToEs3Converter.CANNOT_CONVERT);
+        Es6ToEs3Util.CANNOT_CONVERT);
   }
 
   public void testGeneratorCannotConvertYet() {
     testError("function *f() {switch (i) {default: case 1: yield 1;}}",
-        Es6ToEs3Converter.CANNOT_CONVERT_YET);
+        Es6ToEs3Util.CANNOT_CONVERT_YET);
 
     testError("function *f() { l: if (true) { var x = 5; break l; x++; yield x; }; }",
-        Es6ToEs3Converter.CANNOT_CONVERT_YET);
+        Es6ToEs3Util.CANNOT_CONVERT_YET);
 
     testError("function *f(b, i) {switch (i) { case (b || (yield 1)): yield 2; }}",
-        Es6ToEs3Converter.CANNOT_CONVERT_YET);
+        Es6ToEs3Util.CANNOT_CONVERT_YET);
   }
 
   public void testThrowGenerator() {
diff --git a/test/com/google/javascript/jscomp/Es6ToEs3ConverterTest.java b/test/com/google/javascript/jscomp/Es6ToEs3ConverterTest.java
index 715b8a09f..a719addca 100644
--- a/test/com/google/javascript/jscomp/Es6ToEs3ConverterTest.java
+++ b/test/com/google/javascript/jscomp/Es6ToEs3ConverterTest.java
@@ -20,8 +20,8 @@ import static com.google.javascript.jscomp.Es6ConvertSuper.INVALID_SUPER_CALL;
 import static com.google.javascript.jscomp.Es6RewriteClass.CLASS_REASSIGNMENT;
 import static com.google.javascript.jscomp.Es6RewriteClass.CONFLICTING_GETTER_SETTER_TYPE;
 import static com.google.javascript.jscomp.Es6RewriteClass.DYNAMIC_EXTENDS_TYPE;
-import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
-import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT_YET;
+import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT;
+import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT_YET;
 import static com.google.javascript.jscomp.NewTypeInference.CANNOT_INSTANTIATE_ABSTRACT_CLASS;
 import static com.google.javascript.jscomp.TypeCheck.INSTANTIATE_ABSTRACT_CLASS;
 import static com.google.javascript.jscomp.parsing.parser.FeatureSet.ES7_MODULES;
@@ -32,7 +32,8 @@ import com.google.javascript.jscomp.parsing.parser.FeatureSet;
 
 /**
  * Test cases for ES6 transpilation. Despite the name, this isn't just testing {@link
- * Es6ToEs3Converter}, but also some other ES6 transpilation passes. See #getProcessor.
+ * EarlyEs6ToEs3Converter} and {@link LateEs6ToEs3Converter},
+ * but also some other ES6 transpilation passes. See {@link #getProcessor}.
  *
  * @author tbreisacher@google.com (Tyler Breisacher)
  */
@@ -129,7 +130,10 @@ public final class Es6ToEs3ConverterTest extends TypeICompilerTestCase {
         makePassFactory("es6ConvertSuper", new Es6ConvertSuper(compiler)));
     optimizer.addOneTimePass(makePassFactory("es6ExtractClasses", new Es6ExtractClasses(compiler)));
     optimizer.addOneTimePass(makePassFactory("es6RewriteClass", new Es6RewriteClass(compiler)));
-    optimizer.addOneTimePass(makePassFactory("convertEs6", new Es6ToEs3Converter(compiler)));
+    optimizer.addOneTimePass(
+        makePassFactory("convertEs6Early", new EarlyEs6ToEs3Converter(compiler)));
+    optimizer.addOneTimePass(
+        makePassFactory("convertEs6Late", new LateEs6ToEs3Converter(compiler)));
     optimizer.addOneTimePass(
         makePassFactory("Es6RewriteBlockScopedDeclaration",
             new Es6RewriteBlockScopedDeclaration(compiler)));
@@ -2263,9 +2267,9 @@ public final class Es6ToEs3ConverterTest extends TypeICompilerTestCase {
 
     // Warn on /** number */
     testWarning("function f(/** number */ ...zero) {}",
-                Es6ToEs3Converter.BAD_REST_PARAMETER_ANNOTATION);
+                EarlyEs6ToEs3Converter.BAD_REST_PARAMETER_ANNOTATION);
     testWarning("/** @param {number} zero */ function f(...zero) {}",
-                Es6ToEs3Converter.BAD_REST_PARAMETER_ANNOTATION);
+                EarlyEs6ToEs3Converter.BAD_REST_PARAMETER_ANNOTATION);
   }
 
   public void testDefaultAndRestParameters() {
diff --git a/test/com/google/javascript/jscomp/NewTypeInferenceTestBase.java b/test/com/google/javascript/jscomp/NewTypeInferenceTestBase.java
index eff9868ec..c4971ace3 100644
--- a/test/com/google/javascript/jscomp/NewTypeInferenceTestBase.java
+++ b/test/com/google/javascript/jscomp/NewTypeInferenceTestBase.java
@@ -253,6 +253,7 @@ public abstract class NewTypeInferenceTestBase extends CompilerTypeTestCase {
       TranspilationPasses.addEs2016Passes(passes);
       TranspilationPasses.addEs6EarlyPasses(passes);
       TranspilationPasses.addEs6LatePasses(passes);
+      TranspilationPasses.addEs6PassesAfterNTI(passes);
       TranspilationPasses.addRewritePolyfillPass(passes);
     }
     passes.add(makePassFactory("GlobalTypeInfo", new GlobalTypeInfoCollector(compiler)));
diff --git a/test/com/google/javascript/jscomp/TypeCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckTest.java
index b53553801..643437dff 100644
--- a/test/com/google/javascript/jscomp/TypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java
@@ -17990,6 +17990,7 @@ public final class TypeCheckTest extends CompilerTypeTestCase {
       TranspilationPasses.addEs2016Passes(passes);
       TranspilationPasses.addEs6EarlyPasses(passes);
       TranspilationPasses.addEs6LatePasses(passes);
+      TranspilationPasses.addEs6PassesAfterNTI(passes);
       TranspilationPasses.addRewritePolyfillPass(passes);
       PhaseOptimizer phaseopt = new PhaseOptimizer(compiler, null);
       phaseopt.consume(passes);
