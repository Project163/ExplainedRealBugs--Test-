diff --git a/javadoc/com/google/javascript/jscomp/CompilerOptions.html b/javadoc/com/google/javascript/jscomp/CompilerOptions.html
index a72e44c0c..480fdd456 100644
--- a/javadoc/com/google/javascript/jscomp/CompilerOptions.html
+++ b/javadoc/com/google/javascript/jscomp/CompilerOptions.html
@@ -657,6 +657,14 @@ Compiler options
 <TR BGCOLOR="white" CLASS="TableRowColor">
 <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 <CODE>&nbsp;boolean</CODE></FONT></TD>
+<TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/CompilerOptions.html#inlineLocalFunctions">inlineLocalFunctions</A></B></CODE>
+
+<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enhanced function inlining</TD>
+</TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
+<CODE>&nbsp;boolean</CODE></FONT></TD>
 <TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/CompilerOptions.html#inlineVariables">inlineVariables</A></B></CODE>
 
 <BR>
@@ -1676,6 +1684,18 @@ public boolean <B>inlineAnonymousFunctionExpressions</B></PRE>
 </DL>
 <HR>
 
+<A NAME="inlineLocalFunctions"><!-- --></A><H3>
+inlineLocalFunctions</H3>
+<PRE>
+public boolean <B>inlineLocalFunctions</B></PRE>
+<DL>
+<DD>Enhanced function inlining
+<P>
+<DL>
+</DL>
+</DL>
+<HR>
+
 <A NAME="crossModuleCodeMotion"><!-- --></A><H3>
 crossModuleCodeMotion</H3>
 <PRE>
diff --git a/javadoc/com/google/javascript/rhino/JSTypeExpression.html b/javadoc/com/google/javascript/rhino/JSTypeExpression.html
index 81c18e561..7d17f7c8e 100644
--- a/javadoc/com/google/javascript/rhino/JSTypeExpression.html
+++ b/javadoc/com/google/javascript/rhino/JSTypeExpression.html
@@ -178,6 +178,15 @@ Represents a type expression as a miniture Rhino AST, so that the
 <BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
 </TR>
+<TR BGCOLOR="white" CLASS="TableRowColor">
+<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
+<CODE>static&nbsp;<A HREF="../../../../com/google/javascript/rhino/JSTypeExpression.html" title="class in com.google.javascript.rhino">JSTypeExpression</A></CODE></FONT></TD>
+<TD><CODE><B><A HREF="../../../../com/google/javascript/rhino/JSTypeExpression.html#makeOptionalArg(com.google.javascript.rhino.JSTypeExpression)">makeOptionalArg</A></B>(<A HREF="../../../../com/google/javascript/rhino/JSTypeExpression.html" title="class in com.google.javascript.rhino">JSTypeExpression</A>&nbsp;expr)</CODE>
+
+<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make the given type expression into an optional type expression,
+ if possible.</TD>
+</TR>
 </TABLE>
 &nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
 <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
@@ -220,6 +229,23 @@ public <B>JSTypeExpression</B>(<A HREF="../../../../com/google/javascript/rhino/
 </TR>
 </TABLE>
 
+<A NAME="makeOptionalArg(com.google.javascript.rhino.JSTypeExpression)"><!-- --></A><H3>
+makeOptionalArg</H3>
+<PRE>
+public static <A HREF="../../../../com/google/javascript/rhino/JSTypeExpression.html" title="class in com.google.javascript.rhino">JSTypeExpression</A> <B>makeOptionalArg</B>(<A HREF="../../../../com/google/javascript/rhino/JSTypeExpression.html" title="class in com.google.javascript.rhino">JSTypeExpression</A>&nbsp;expr)</PRE>
+<DL>
+<DD>Make the given type expression into an optional type expression,
+ if possible.
+<P>
+<DD><DL>
+</DL>
+</DD>
+<DD><DL>
+</DL>
+</DD>
+</DL>
+<HR>
+
 <A NAME="isOptionalArg()"><!-- --></A><H3>
 isOptionalArg</H3>
 <PRE>
diff --git a/javadoc/index-all.html b/javadoc/index-all.html
index ca364a4ba..ceadf28e9 100644
--- a/javadoc/index-all.html
+++ b/javadoc/index-all.html
@@ -3560,6 +3560,9 @@ Variable in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/
 <DT><A HREF="./com/google/javascript/jscomp/CompilerOptions.html#inlineGetters"><B>inlineGetters</B></A> - 
 Variable in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/CompilerOptions.html" title="class in com.google.javascript.jscomp">CompilerOptions</A>
 <DD>Inlines trivial getters
+<DT><A HREF="./com/google/javascript/jscomp/CompilerOptions.html#inlineLocalFunctions"><B>inlineLocalFunctions</B></A> - 
+Variable in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/CompilerOptions.html" title="class in com.google.javascript.jscomp">CompilerOptions</A>
+<DD>Enhanced function inlining
 <DT><A HREF="./com/google/javascript/jscomp/CompilerOptions.html#inlineVariables"><B>inlineVariables</B></A> - 
 Variable in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/CompilerOptions.html" title="class in com.google.javascript.jscomp">CompilerOptions</A>
 <DD>Inlines variables
@@ -4490,6 +4493,10 @@ Static method in class com.google.javascript.jscomp.<A HREF="./com/google/javasc
 <DT><A HREF="./com/google/javascript/rhino/Kit.html#makeHashKeyFromPair(java.lang.Object, java.lang.Object)"><B>makeHashKeyFromPair(Object, Object)</B></A> - 
 Static method in class com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/Kit.html" title="class in com.google.javascript.rhino">Kit</A>
 <DD>&nbsp;
+<DT><A HREF="./com/google/javascript/rhino/JSTypeExpression.html#makeOptionalArg(com.google.javascript.rhino.JSTypeExpression)"><B>makeOptionalArg(JSTypeExpression)</B></A> - 
+Static method in class com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/JSTypeExpression.html" title="class in com.google.javascript.rhino">JSTypeExpression</A>
+<DD>Make the given type expression into an optional type expression,
+ if possible.
 <DT><A HREF="./com/google/javascript/rhino/JSDocInfoBuilder.html#markAnnotation(java.lang.String, int, int)"><B>markAnnotation(String, int, int)</B></A> - 
 Method in class com.google.javascript.rhino.<A HREF="./com/google/javascript/rhino/JSDocInfoBuilder.html" title="class in com.google.javascript.rhino">JSDocInfoBuilder</A>
 <DD>Adds a marker to the current JSDocInfo and populates the marker with the
diff --git a/javadoc/serialized-form.html b/javadoc/serialized-form.html
index dc32df630..b5dd65ef2 100644
--- a/javadoc/serialized-form.html
+++ b/javadoc/serialized-form.html
@@ -737,6 +737,17 @@ boolean <B>inlineAnonymousFunctionExpressions</B></PRE>
 </DL>
 <HR>
 <H3>
+inlineLocalFunctions</H3>
+<PRE>
+boolean <B>inlineLocalFunctions</B></PRE>
+<DL>
+<DD>Enhanced function inlining
+<P>
+<DL>
+</DL>
+</DL>
+<HR>
+<H3>
 crossModuleCodeMotion</H3>
 <PRE>
 boolean <B>crossModuleCodeMotion</B></PRE>
diff --git a/lib/google_common_deploy.jar b/lib/google_common_deploy.jar
index aceb18eb2..f9fed2e99 100755
Binary files a/lib/google_common_deploy.jar and b/lib/google_common_deploy.jar differ
diff --git a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java
index 0c8566b26..3a6717d9a 100644
--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java
+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java
@@ -150,8 +150,6 @@ public abstract class AbstractCompilerRunner<A extends Compiler,
       + "opt_parameter.")
   public static final Flag<Boolean> FLAG_third_party = Flag.value(false);
 
-  @FlagSpec(help = "Check types for validity.")
-  public static final Flag<Boolean> FLAG_check_types = Flag.value(false);
 
   @FlagSpec(help = "Controls how detailed the compilation summary is. Values:"
       + " 0 (never print summary), 1 (print summary only if there are "
@@ -556,10 +554,6 @@ public abstract class AbstractCompilerRunner<A extends Compiler,
           VariableMap.load(FLAG_property_map_input_file.get()).toBytes();
     }
 
-    if (FLAG_check_types.get()) {
-      options.checkTypes = true;
-    }
-
     if (!options.jsOutputFile.equals("")) {
       out = new PrintStream(options.jsOutputFile);
     }
diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java
index 881a6407f..03d5ceddb 100644
--- a/src/com/google/javascript/jscomp/CollapseProperties.java
+++ b/src/com/google/javascript/jscomp/CollapseProperties.java
@@ -300,7 +300,7 @@ class CollapseProperties implements CompilerPass {
     if (n.props == null) return;
 
     for (Name p : n.props) {
-      String propAlias = alias + '$' + p.name;
+      String propAlias = appendPropForAlias(alias, p.name);
 
       if (p.canCollapse()) {
         flattenReferencesTo(p, propAlias);
@@ -448,13 +448,15 @@ class CollapseProperties implements CompilerPass {
     if (n.props != null) {
       for (Name p : n.props) {
         // Recurse first so that saved node ancestries are intact when needed.
-        collapseDeclarationOfNameAndDescendants(p, alias + '$' + p.name);
+        collapseDeclarationOfNameAndDescendants(
+            p, appendPropForAlias(alias, p.name));
 
         if (!p.inExterns && canCollapseChildNames && p.declaration != null &&
             p.declaration.node != null &&
             p.declaration.node.getParent() != null &&
             p.declaration.node.getParent().getType() == Token.ASSIGN) {
-          updateSimpleDeclaration(alias + '$' + p.name, p.declaration);
+          updateSimpleDeclaration(
+              appendPropForAlias(alias, p.name), p, p.declaration);
         }
       }
     }
@@ -467,10 +469,11 @@ class CollapseProperties implements CompilerPass {
    * function whose properties aren't collapsible.
    *
    * @param alias The flattened property name (e.g. "a$b")
+   * @param refName The name for the reference being updated.
    * @param ref An object containing information about the assignment getting
    *     updated
    */
-  private void updateSimpleDeclaration(String alias, Ref ref) {
+  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {
     Node rvalue = ref.node.getNext();
     Node parent = ref.node.getParent();
     Node gramps = parent.getParent();
@@ -479,7 +482,7 @@ class CollapseProperties implements CompilerPass {
 
     // Create the new alias node.
     Node nameNode = NodeUtil.newName(alias, gramps.getFirstChild(),
-        alias.replace("$", "."));
+        refName.fullName());
     if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {
       nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
     }
@@ -609,7 +612,7 @@ class CollapseProperties implements CompilerPass {
     if (isObjLit) {
       boolean discardKeys = n.aliasingGets == 0;
       declareVarsForObjLitValues(
-          alias, rvalue,
+          n, alias, rvalue,
           varNode, varParent.getChildBefore(varNode), varParent,
           discardKeys);
     }
@@ -666,7 +669,7 @@ class CollapseProperties implements CompilerPass {
     if (isObjLit) {
       boolean discardKeys = n.aliasingGets == 0;
       numChanges += declareVarsForObjLitValues(
-          name, rvalue, varNode, gramps.getChildBefore(varNode),
+          n, name, rvalue, varNode, gramps.getChildBefore(varNode),
           gramps, discardKeys);
     }
 
@@ -719,8 +722,8 @@ class CollapseProperties implements CompilerPass {
    * @return The number of variables added
    */
   private int declareVarsForObjLitValues(
-      String alias, Node objlit, Node varNode, Node nameToAddAfter,
-      Node varParent, boolean discardKeys) {
+      Name objlitName, String alias, Node objlit, Node varNode,
+      Node nameToAddAfter, Node varParent, boolean discardKeys) {
     int numVars = 0;
     int arbitraryNameCounter = 0;
 
@@ -736,10 +739,10 @@ class CollapseProperties implements CompilerPass {
       // their values are expressions that have side effects.
       boolean isJsIdentifier = key.getType() != Token.NUMBER &&
                                TokenStream.isJSIdentifier(key.getString());
-      String propAlias = alias + '$' +
-          (isJsIdentifier ? key.getString()
-              : String.valueOf(++arbitraryNameCounter));
-      String qName = propAlias.replace('$', '.');
+      String propName = isJsIdentifier ?
+          key.getString() : String.valueOf(++arbitraryNameCounter);
+      String propAlias = appendPropForAlias(alias, propName);
+      String qName = objlitName.fullName() + '.' + propName;
 
       Node refNode = null;
       if (discardKeys) {
@@ -815,7 +818,7 @@ class CollapseProperties implements CompilerPass {
     if (n.props != null) {
       for (Name p : n.props) {
         if (p.needsToBeStubbed()) {
-          String propAlias = alias + '$' + p.name;
+          String propAlias = appendPropForAlias(alias, p.name);
           Node nameNode = Node.newString(Token.NAME, propAlias);
           Node newVar = new Node(Token.VAR, nameNode);
           if (addAfter == null) {
@@ -838,4 +841,14 @@ class CollapseProperties implements CompilerPass {
     }
     return numStubs;
   }
+
+  private static String appendPropForAlias(String root, String prop) {
+    if (prop.indexOf('$') != -1) {
+      // Encode '$' in a property as '$0'. Because '0' cannot be the
+      // start of an identifier, this will never conflict with our
+      // encoding from '.' -> '$'.
+      prop = prop.replaceAll("\\$", "\\$0");
+    }
+    return root + '$' + prop;
+  }
 }
diff --git a/src/com/google/javascript/jscomp/CompilerOptions.java b/src/com/google/javascript/jscomp/CompilerOptions.java
index d9615b179..2ff988713 100644
--- a/src/com/google/javascript/jscomp/CompilerOptions.java
+++ b/src/com/google/javascript/jscomp/CompilerOptions.java
@@ -202,6 +202,9 @@ public class CompilerOptions implements Serializable, Cloneable {
   /** Enhanced function inlining */
   public boolean inlineAnonymousFunctionExpressions;
 
+  /** Enhanced function inlining */
+  public boolean inlineLocalFunctions;
+
   /** Move code to a deeper module */
   public boolean crossModuleCodeMotion;
 
diff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java
index d8ea67f08..107c26a6c 100644
--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java
+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java
@@ -327,7 +327,7 @@ public class DefaultPassConfig extends PassConfig {
 
     passes.addAll(getCodeRemovingPasses(false));
 
-    if (options.inlineFunctions) {
+    if (options.inlineFunctions || options.inlineLocalFunctions) {
       passes.add(inlineFunctions);
     }
 
@@ -1074,9 +1074,13 @@ public class DefaultPassConfig extends PassConfig {
     protected CompilerPass createInternal(AbstractCompiler compiler) {
       boolean enableBlockInlining = !isInliningForbidden();
       return new InlineFunctions(
-          compiler, compiler.getUniqueNameIdSupplier(),
-          enableBlockInlining, options.decomposeExpressions,
-          options.inlineAnonymousFunctionExpressions);
+          compiler, 
+          compiler.getUniqueNameIdSupplier(),
+          options.inlineFunctions,
+          options.inlineLocalFunctions, 
+          options.inlineAnonymousFunctionExpressions,
+          enableBlockInlining,
+          options.decomposeExpressions);
     }
   };
 
diff --git a/src/com/google/javascript/jscomp/FoldConstants.java b/src/com/google/javascript/jscomp/FoldConstants.java
index 982e19b7e..bc1c05054 100644
--- a/src/com/google/javascript/jscomp/FoldConstants.java
+++ b/src/com/google/javascript/jscomp/FoldConstants.java
@@ -234,7 +234,7 @@ class FoldConstants extends AbstractPostOrderCallback
       tryMinimizeCondition(t, left, n);
       return;
     }
-    
+
     if (type == Token.RETURN) {
       tryReduceReturn(t, n);
       return;
@@ -787,9 +787,11 @@ class FoldConstants extends AbstractPostOrderCallback
       Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
 
       Node name1 = var.getFirstChild();
-      Node name2 = elseAssign.getFirstChild();
+      Node maybeName2 = elseAssign.getFirstChild();
 
-      if (name1.hasChildren() && name1.getString().equals(name2.getString())) {
+      if (name1.hasChildren()
+          && maybeName2.getType() == Token.NAME
+          && name1.getString().equals(maybeName2.getString())) {
         Node thenExpr = name1.removeChildren();
         Node elseExpr = elseAssign.getLastChild().detachFromParent();
         cond.detachFromParent();
diff --git a/src/com/google/javascript/jscomp/InlineFunctions.java b/src/com/google/javascript/jscomp/InlineFunctions.java
index d66bbcd1c..c639a592b 100644
--- a/src/com/google/javascript/jscomp/InlineFunctions.java
+++ b/src/com/google/javascript/jscomp/InlineFunctions.java
@@ -22,7 +22,7 @@ import com.google.common.collect.Sets;
 import com.google.javascript.jscomp.FunctionInjector.CanInlineResult;
 import com.google.javascript.jscomp.FunctionInjector.InliningMode;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
-import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;
+import com.google.javascript.jscomp.NodeTraversal.Callback;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
@@ -70,18 +70,26 @@ class InlineFunctions implements CompilerPass {
 
   private final boolean blockFunctionInliningEnabled;
   private final boolean inlineAnonymousFunctionExpressions;
+  private final boolean inlineGlobalFunctions;
+  private final boolean inlineLocalFunctions;
 
   InlineFunctions(AbstractCompiler compiler,
       Supplier<String> safeNameIdSupplier,
+      boolean inlineGlobalFunctions,
+      boolean inlineLocalFunctions,
+      boolean inlineAnonymousFunctionExpressions,
       boolean blockFunctionInliningEnabled,
-      boolean enableExpressionDecomposition,
-      boolean inlineAnonymousFunctionExpressions) {
+      boolean enableExpressionDecomposition) {
     Preconditions.checkArgument(compiler != null);
     Preconditions.checkArgument(safeNameIdSupplier != null);
     this.compiler = compiler;
-    this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;
+
+    this.inlineGlobalFunctions = inlineGlobalFunctions;
+    this.inlineLocalFunctions = inlineLocalFunctions;
     this.inlineAnonymousFunctionExpressions =
-        inlineAnonymousFunctionExpressions;
+      inlineAnonymousFunctionExpressions;
+    this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;
+
     this.injector = new FunctionInjector(
         compiler, safeNameIdSupplier, enableExpressionDecomposition);
   }
@@ -102,11 +110,6 @@ class InlineFunctions implements CompilerPass {
     Preconditions.checkState(compiler.isNormalized());
 
     NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());
-    // TODO(johnlenz): Merge FindAnonymousFunctionCalls with
-    // FindCandidateFunctions.
-    if (inlineAnonymousFunctionExpressions) {
-      NodeTraversal.traverse(compiler, root, new FindAnonymousFunctionCalls());
-    }
     if (fns.isEmpty()) {
       return;  // Nothing left to do.
     }
@@ -143,11 +146,37 @@ class InlineFunctions implements CompilerPass {
   /**
    * Find functions that might be inlined.
    */
-  private class FindCandidateFunctions
-      extends AbstractShallowStatementCallback {
+  private class FindCandidateFunctions implements Callback {
+    private int callsSeen = 0;
+
+    @Override
+    public boolean shouldTraverse(
+        NodeTraversal nodeTraversal, Node n, Node parent) {
+      // Don't traverse into function bodies
+      // if we aren't inlining local functions.
+      return inlineLocalFunctions || inlineAnonymousFunctionExpressions
+         || parent == null || NodeUtil.isControlStructure(parent)
+         || NodeUtil.isStatementBlock(parent);
+    }
+
     public void visit(NodeTraversal t, Node n, Node parent) {
-      switch (n.getType()) {
+      if ((t.inGlobalScope() && inlineGlobalFunctions)
+          || (!t.inGlobalScope() && inlineLocalFunctions)) {
+        findNamedFunctions(t, n, parent);
+      } 
+      
+      if (inlineAnonymousFunctionExpressions) {
+        findAnonymousFunctionExpressions(t, n);
+      }
+    }
+
+    public void findNamedFunctions(NodeTraversal t, Node n, Node parent) {
+      if (!NodeUtil.isStatement(n)) {
+        // There aren't any interesting functions here.
+        return;
+      }
 
+      switch (n.getType()) {
         // Anonymous functions in the form of:
         //   var fooFn = function(x) { return ... }
         case Token.VAR:
@@ -176,18 +205,14 @@ class InlineFunctions implements CompilerPass {
           break;
       }
     }
-  }
 
-  /**
-   * Find anonymous functions that are called directly in the form of
-   *   (function(a,b,...){...})(a,b,...)
-   * or
-   *   (function(a,b,...){...}).call(this,a,b, ...)
-   */
-  private class FindAnonymousFunctionCalls
-      extends AbstractPostOrderCallback {
-    private int callsSeen = 0;
-    public void visit(NodeTraversal t, Node n, Node parent) {
+    /**
+     * Find anonymous functions that are called directly in the form of
+     *   (function(a,b,...){...})(a,b,...)
+     * or
+     *   (function(a,b,...){...}).call(this,a,b, ...)
+     */
+    public void findAnonymousFunctionExpressions(NodeTraversal t, Node n) {
       switch (n.getType()) {
         // Anonymous functions in the form of:
         //   (function(){})();
diff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java
index 1e5e6379d..f5b92e110 100644
--- a/src/com/google/javascript/jscomp/Normalize.java
+++ b/src/com/google/javascript/jscomp/Normalize.java
@@ -251,10 +251,19 @@ class Normalize implements CompilerPass, Callback {
    * Do normalizations that introduce new siblings or parents.
    */
   private void doStatementNormalizations(NodeTraversal t, Node n, Node parent) {
+    if (n.getType() == Token.LABEL) {
+      normalizeLabels(n);
+    }
+
     // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these
     // are the only legal place for VARs and FOR statements.
     if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {
       extractForInitializer(n, null, null);
+    }
+
+    // Only inspect the children of SCRIPTs, BLOCKs, as all these
+    // are the only legal place for VARs.
+    if (NodeUtil.isStatementBlock(n)) {
       splitVarDeclarations(n);
     }
 
@@ -263,6 +272,33 @@ class Normalize implements CompilerPass, Callback {
     }
   }
 
+  // TODO(johnlenz): Move this to NodeTypeNormalizer once the unit tests are
+  // fixed.
+  /**
+   * Limit the number of special cases where LABELs need to be handled. Only 
+   * BLOCK and loops are allowed to be labeled.  Loop labels must remain in 
+   * place as the named continues are not allowed for labeled blocks.
+   */
+  private void normalizeLabels(Node n) {
+    Preconditions.checkArgument(n.getType() == Token.LABEL);
+    
+    Node last = n.getLastChild();
+    switch (last.getType()) {
+      case Token.LABEL:
+      case Token.BLOCK:
+      case Token.FOR:
+      case Token.WHILE:
+      case Token.DO:
+        return;
+      default:
+        Node block = new Node(Token.BLOCK);
+        n.replaceChild(last, block);
+        block.addChildToFront(last);
+        reportCodeChange("LABEL normalization");
+        return;
+    }
+  }
+
   /**
    * Bring the initializers out of FOR loops.  These need to be placed
    * before any associated LABEL nodes. This needs to be done from the top
diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
index 11afe5ed6..f7084577b 100644
--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
@@ -585,6 +585,10 @@ public final class JsDocInfoParser {
                       token = next();
                       if (JsDocToken.RB != token) {
                         reportTypeSyntaxWarning("msg.jsdoc.missing.rb");
+                      } else if (type != null) {
+                        // Make the type expression optional, if it isn't
+                        // already.
+                        type = JSTypeExpression.makeOptionalArg(type);
                       }
                     }
 
diff --git a/src/com/google/javascript/rhino/JSTypeExpression.java b/src/com/google/javascript/rhino/JSTypeExpression.java
index 23ef26a70..04d9640e3 100644
--- a/src/com/google/javascript/rhino/JSTypeExpression.java
+++ b/src/com/google/javascript/rhino/JSTypeExpression.java
@@ -71,6 +71,19 @@ public final class JSTypeExpression implements Serializable {
     this.registry = registry;
   }
 
+  /**
+   * Make the given type expression into an optional type expression,
+   * if possible.
+   */
+  public static JSTypeExpression makeOptionalArg(JSTypeExpression expr) {
+    if (expr.isOptionalArg() || expr.isVarArgs()) {
+      return expr;
+    } else {
+      return new JSTypeExpression(
+          new Node(Token.EQUALS, expr.root), expr.sourceName, expr.registry);
+    }
+  }
+
   /**
    * @return Whether this expression denotes an optional {@code @param}.
    */
diff --git a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java
index cac15c285..be84a8b5c 100644
--- a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java
+++ b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java
@@ -1111,4 +1111,26 @@ public class CollapsePropertiesTest extends CompilerTestCase {
     test("var a = {}; if (a.b = function() {}) { a.b.c = 3; a.b(a.b.c); }",
          "var a$b; if (a$b = function() {}) { a$b.c = 3; a$b(a$b.c); }");
   }
+
+  public void testPropWithDollarSign() {
+    test("var a = {$: 3}", "var a$$0 = 3;");
+  }
+
+  public void testPropWithDollarSign2() {
+    test("var a = {$: function(){}}", "var a$$0 = function(){};");
+  }
+
+  public void testPropWithDollarSign3() {
+    test("var a = {b: {c: 3}, b$c: function(){}}",
+         "var a$b$c = 3; var a$b$0c = function(){};");
+  }
+
+  public void testPropWithDollarSign4() {
+    test("var a = {$$: {$$$: 3}};", "var a$$0$0$$0$0$0 = 3;");
+  }
+
+  public void testPropWithDollarSign5() {
+    test("var a = {b: {$0c: true}, b$0c: false};",
+         "var a$b$$00c = true; var a$b$00c = false;");
+  }
 }
diff --git a/test/com/google/javascript/jscomp/FoldConstantsTest.java b/test/com/google/javascript/jscomp/FoldConstantsTest.java
index f7070ca4f..52ad0512b 100644
--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java
+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java
@@ -1037,11 +1037,17 @@ public class FoldConstantsTest extends CompilerTestCase {
     fold("function(){if(a()){return undefined;}}",
          "function(){if(a()){return}}");
   }
-  
+
   public void testBugIssue3() {
     foldSame("function foo() {" +
              "  if(sections.length != 1) children[i] = 0;" +
              "  else var selectedid = children[i]" +
              "}");
   }
+
+  public void testBugIssue43() {
+    foldSame("function foo() {" +
+             "  if (a) { var b = 1; } else { a.b = 1; }" +
+             "}");
+  }
 }
diff --git a/test/com/google/javascript/jscomp/FunctionInjectorTest.java b/test/com/google/javascript/jscomp/FunctionInjectorTest.java
index 4c4a3da27..c4e6fc283 100644
--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java
+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java
@@ -1002,9 +1002,9 @@ public class FunctionInjectorTest extends TestCase {
         "function foo(a){return true;}; " +
         "function x() {a:foo(1)?0:1 }",
         "function foo(a){return true;}; " +
-        "function x() { {var JSCompiler_inline_result_0; " +
+        "function x() { a:{{var JSCompiler_inline_result_0; " +
         "JSCompiler_inline_result_0=true;}" +
-        "a:JSCompiler_inline_result_0?0:1 }",
+        "JSCompiler_inline_result_0?0:1 }}",
         "foo", INLINE_BLOCK);
   }
 
diff --git a/test/com/google/javascript/jscomp/InlineFunctionsTest.java b/test/com/google/javascript/jscomp/InlineFunctionsTest.java
index 342fa80f2..24a128365 100644
--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java
+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java
@@ -21,9 +21,11 @@ package com.google.javascript.jscomp;
 *
  */
 public class InlineFunctionsTest extends CompilerTestCase {
+  boolean allowGlobalFunctionInlining = true;
   boolean allowBlockInlining = true;
   boolean allowExpressionDecomposition = true;
   boolean allowAnonymousFunctionExpressionInlining = true;
+  boolean allowLocalFunctionInlining = true;
 
   public InlineFunctionsTest() {
     this.enableNormalize();
@@ -40,10 +42,13 @@ public class InlineFunctionsTest extends CompilerTestCase {
   protected CompilerPass getProcessor(Compiler compiler) {
     compiler.resetUniqueNameId();
     return new InlineFunctions(
-        compiler, compiler.getUniqueNameIdSupplier(),
+        compiler, 
+        compiler.getUniqueNameIdSupplier(),
+        allowGlobalFunctionInlining,
+        allowLocalFunctionInlining,
+        allowAnonymousFunctionExpressionInlining,
         allowBlockInlining,
-        allowExpressionDecomposition,
-        allowAnonymousFunctionExpressionInlining);
+        allowExpressionDecomposition);
   }
 
   /**
@@ -928,23 +933,32 @@ public class InlineFunctionsTest extends CompilerTestCase {
   }
 
   public void testNoInlineOfNonGlobalFunction1() {
-    testSame("function _f(){function g(){return 0}}" +
-             "function _h(){return g()}");
+    test("var g;function _f(){function g(){return 0}}" +
+         "function _h(){return g()}",
+         "var g;function _f(){}" +
+         "function _h(){return g()}");
   }
 
   public void testNoInlineOfNonGlobalFunction2() {
-    testSame("function _f(){var g=function(){return 0}}" +
-             "function _h(){return g()}");
+    test("var g;function _f(){var g=function(){return 0}}" +
+         "function _h(){return g()}",
+         "var g;function _f(){}" +
+         "function _h(){return g()}");
   }
 
   public void testNoInlineOfNonGlobalFunction3() {
-    testSame("var g=3;function _f(){var g=function(){return 0}}" +
-             "function _h(){return g()}");
+    test("var g;function _f(){var g=function(){return 0}}" +
+         "function _h(){return g()}",
+         "var g;function _f(){}" +
+         "function _h(){return g()}");
   }
 
   public void testNoInlineOfNonGlobalFunction4() {
-    testSame("var g=3;function _f(){function g(){return 0}}" +
-             "function _h(){return g()}");
+    test("var g;function _f(){function g(){return 0}}" +
+         "function _h(){return g()}",
+         "var g;function _f(){}" +
+         "function _h(){return g()}");
+
   }
 
   public void testNoInlineMaskedFunction() {
@@ -1421,6 +1435,34 @@ public class InlineFunctionsTest extends CompilerTestCase {
           "{{JSCompiler_inline_f_1(JSCompiler_inline_f_1)}}}");
   }
 
+  public void testLocalFunctionInlining1() {
+    test("function _f(){ function g() {} g() }",
+         "function _f(){ void 0 }");
+  }
+
+  public void testLocalFunctionInlining2() {
+    test("function _f(){ function g() {foo(); bar();} g() }",
+         "function _f(){ {foo(); bar();} }");
+  }
+
+  public void testLocalFunctionInlining3() {
+    test("function _f(){ function g() {foo(); bar();} g() }",
+         "function _f(){ {foo(); bar();} }");
+  }
+
+  public void testLocalFunctionInlining4() {
+    test("function _f(){ function g() {return 1} return g() }",
+         "function _f(){ return 1 }");
+  }
+
+  public void testLocalFunctionInlining5() {
+    testSame("function _f(){ function g() {this;} g() }");
+  }
+
+  public void testLocalFunctionInlining6() {
+    testSame("function _f(){ function g() {this;} return g; }");
+  }
+
   // http://en.wikipedia.org/wiki/Fixed_point_combinator#Y_combinator
   public void testAnonymousFunctionYCombinator() {
     testSame(
diff --git a/test/com/google/javascript/jscomp/NormalizeTest.java b/test/com/google/javascript/jscomp/NormalizeTest.java
index 7db152dca..fe26d8cba 100644
--- a/test/com/google/javascript/jscomp/NormalizeTest.java
+++ b/test/com/google/javascript/jscomp/NormalizeTest.java
@@ -70,6 +70,12 @@ public class NormalizeTest extends CompilerTestCase {
 
     test("do var a = foo(1), b; while(false);",
          "do{var a = foo(1); var b} while(false);");
+    test("a:var a,b,c;",
+         "a:{ var a;var b; var c; }");
+    test("a:for(var a,b,c;;);",
+         "var a;var b; var c;a:for(;;);");
+    test("if (true) a:var a,b;",
+         "if (true)a:{ var a; var b; }");
   }
 
   public void testUnhandled() {
@@ -125,7 +131,8 @@ public class NormalizeTest extends CompilerTestCase {
 
   public void testMoveFunctions2() throws Exception {
     testSame("function f() { function foo() {} }");
-    testSame("function f() { f(); a:function bar() {} }");
+    test("function f() { f(); a:function bar() {} }",
+         "function f() { f(); a:{function bar() {}}}");
     testSame("function f() { f(); {function bar() {}}}");
     testSame("function f() { f(); if (true) {function bar() {}}}");
   }
@@ -172,9 +179,9 @@ public class NormalizeTest extends CompilerTestCase {
     test("var a = 1; function f(){ var a = 2 }",
          "var a = 1; function f(){ var a$$1 = 2 }");
     test("function f() { var a = 1; lable1:var a = 2 }",
-         "function f() { var a = 1; lable1:a = 2 }");
+         "function f() { var a = 1; lable1:{a = 2}}");
     test("function f() { var a = 1; lable1:var a }",
-         "function f() { var a = 1; lable1:; }");
+         "function f() { var a = 1; lable1:{} }");
     test("function f() { var a = 1; for(var a in b); }",
          "function f() { var a = 1; for(a in b); }");
   }
diff --git a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java
index fc9ba094d..b1db70a95 100644
--- a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java
@@ -139,6 +139,13 @@ public class TypeCheckFunctionCheckTest extends CompilerTestCase {
              WRONG_ARGUMENT_COUNT);
   }
 
+  public void testFunctionsWithJsDoc7() {
+    String fooDfn = "/** @param {*} [b] */ var foo = function(b) {};";
+    testSame(fooDfn + "foo();");
+    testSame(fooDfn + "foo(1);");
+    testSame(fooDfn + "foo(1, 2);", WRONG_ARGUMENT_COUNT);
+  }
+
   public void testFunctionWithDefaultCodingConvention() {
     convention = new DefaultCodingConvention();
     testSame("var foo = function(x) {}; foo(1, 2);");
