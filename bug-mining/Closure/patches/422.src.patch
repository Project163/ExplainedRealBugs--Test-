diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
index 3f3fb7931..220308c23 100644
--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
@@ -172,12 +172,7 @@ public final class ReferenceCollectingCallback implements ScopedCallback,
   @Override
   public void visit(NodeTraversal t, Node n, Node parent) {
     if (n.isName() || (n.isStringKey() && !n.hasChildren())) {
-      Var v;
-      if (n.getString().equals("arguments")) {
-        v = t.getScope().getArgumentsVar();
-      } else {
-        v = t.getScope().getVar(n.getString());
-      }
+      Var v = t.getScope().getVar(n.getString());
 
       if (v != null) {
         if (varFilter.apply(v)) {
diff --git a/src/com/google/javascript/jscomp/Scope.java b/src/com/google/javascript/jscomp/Scope.java
index 97db72c01..4c00fad23 100644
--- a/src/com/google/javascript/jscomp/Scope.java
+++ b/src/com/google/javascript/jscomp/Scope.java
@@ -181,6 +181,13 @@ public class Scope implements StaticScope {
    * Get a unique VAR object to represents "arguments" within this scope
    */
   public Var getArgumentsVar() {
+    if (isGlobal() || isModuleScope()) {
+      throw new IllegalStateException("No arguments var for scope: " + this);
+    }
+    if (!isFunctionScope() || rootNode.isArrowFunction()) {
+      return parent.getArgumentsVar();
+    }
+
     if (arguments == null) {
       arguments = Var.makeArgumentsVar(this);
     }
diff --git a/test/com/google/javascript/jscomp/Es6SyntacticScopeCreatorTest.java b/test/com/google/javascript/jscomp/Es6SyntacticScopeCreatorTest.java
index 95683a78a..70b1df846 100644
--- a/test/com/google/javascript/jscomp/Es6SyntacticScopeCreatorTest.java
+++ b/test/com/google/javascript/jscomp/Es6SyntacticScopeCreatorTest.java
@@ -560,13 +560,38 @@ public final class Es6SyntacticScopeCreatorTest extends TestCase {
     Node fBlock = NodeUtil.getFunctionBody(function);
     Scope fBlockScope = scopeCreator.createScope(fBlock, fScope);
     assertThat(fBlockScope.getVar("arguments")).isSameAs(arguments);
+    assertThat(fBlockScope.getArgumentsVar()).isSameAs(arguments);
 
     Node ifBlock = fBlock.getFirstChild().getLastChild();
     Scope blockScope = scopeCreator.createScope(ifBlock, fBlockScope);
     assertTrue(blockScope.isDeclared("arguments", false));
+    assertThat(blockScope.getArgumentsVar()).isSameAs(arguments);
     assertThat(blockScope.getVar("arguments")).isNotEqualTo(arguments);
   }
 
+  public void testArgumentsVariableInArrowFunction() {
+    String js = "function outer() { var inner = () => { alert(0); } }";
+    Node root = getRoot(js);
+    Scope global = scopeCreator.createScope(root, null);
+
+    Node outer = root.getFirstChild();
+    checkState(outer.isFunction(), outer);
+    checkState(!outer.isArrowFunction(), outer);
+    Scope outerFunctionScope = scopeCreator.createScope(outer, global);
+    Var arguments = outerFunctionScope.getArgumentsVar();
+
+    Node outerBody = NodeUtil.getFunctionBody(outer);
+    Scope outerBodyScope = scopeCreator.createScope(outerBody, outerFunctionScope);
+
+    Node inner = outerBody.getFirstChild()   // VAR
+                          .getFirstChild()   // NAME
+                          .getFirstChild();  // FUNCTION
+    checkState(inner.isFunction(), inner);
+    checkState(inner.isArrowFunction(), inner);
+    Scope innerFunctionScope = scopeCreator.createScope(inner, outerBodyScope);
+    assertThat(innerFunctionScope.getArgumentsVar()).isSameAs(arguments);
+  }
+
   public void testIsFunctionBlockScoped() {
     String js = "if (true) { function f() {}; }";
     Node root = getRoot(js);
diff --git a/test/com/google/javascript/jscomp/InferConstsTest.java b/test/com/google/javascript/jscomp/InferConstsTest.java
index cc1fe965a..da5a00c77 100644
--- a/test/com/google/javascript/jscomp/InferConstsTest.java
+++ b/test/com/google/javascript/jscomp/InferConstsTest.java
@@ -101,7 +101,7 @@ public final class InferConstsTest extends TestCase {
   }
 
   public void testArguments() {
-    testNotConsts("var arguments = 3;", "arguments");
+    testConsts("var arguments = 3;", "arguments");
   }
 
   public void testDestructuring() {
diff --git a/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java b/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java
index 8667a59f9..890805786 100644
--- a/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java
+++ b/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java
@@ -170,9 +170,11 @@ public final class MustBeReachingVariableDefTest extends TestCase {
   private void computeDefUse(String src) {
     Compiler compiler = new Compiler();
     src = "function _FUNCTION(param1, param2){" + src + "}";
-    Node root = compiler.parseTestCode(src).getFirstChild();
+    Node script = compiler.parseTestCode(src);
+    Node root = script.getFirstChild();
     assertEquals(0, compiler.getErrorCount());
-    Scope scope = SyntacticScopeCreator.makeUntyped(compiler).createScope(root, null);
+    Scope globalScope = SyntacticScopeCreator.makeUntyped(compiler).createScope(script, null);
+    Scope scope = SyntacticScopeCreator.makeUntyped(compiler).createScope(root, globalScope);
     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
     cfa.process(null, root);
     ControlFlowGraph<Node> cfg = cfa.getCfg();
