diff --git a/src/com/google/javascript/jscomp/NewTypeInference.java b/src/com/google/javascript/jscomp/NewTypeInference.java
index c555cd5e0..d62f5ebfc 100644
--- a/src/com/google/javascript/jscomp/NewTypeInference.java
+++ b/src/com/google/javascript/jscomp/NewTypeInference.java
@@ -427,6 +427,9 @@ public class NewTypeInference implements CompilerPass {
       JSType declType = currentScope.getDeclaredTypeOf(name);
       JSType initType = declType == null
           ? envGetType(entryEnv, name) : pickInitialType(declType);
+      println("Adding non-local ", name,
+          " with decltype: ", declType,
+          " and inittype: ", initType);
       entryEnv = envPutType(entryEnv, name, initType);
     }
 
@@ -1354,8 +1357,8 @@ public class NewTypeInference implements CompilerPass {
     // First, evaluate ignoring the specialized context
     objPair = analyzeExprFwd(obj, inEnv);
     JSType objType = objPair.type;
-    if (!objType.equals(JSType.TOP) &&
-        !objType.equals(JSType.UNKNOWN) &&
+    if (!objType.isTop() &&
+        !objType.isUnknown() &&
         !objType.hasNonScalar()) {
       warnInvalidOperand(
           obj, Token.INSTANCEOF,
@@ -1475,8 +1478,7 @@ public class NewTypeInference implements CompilerPass {
       warnInvalidOperand(lhs, Token.ASSIGN_ADD, JSType.NUM_OR_STR, lhsType);
     }
     // if lhs is a string, rhs can still be a number
-    JSType rhsReqType = lhsType.equals(JSType.NUMBER) ?
-        JSType.NUMBER : JSType.NUM_OR_STR;
+    JSType rhsReqType = lhsType.isNumber() ? JSType.NUMBER : JSType.NUM_OR_STR;
     EnvTypePair pair = analyzeExprFwd(rhs, lvalue.env, rhsReqType);
     if (!pair.type.isSubtypeOf(rhsReqType)) {
       warnInvalidOperand(rhs, Token.ASSIGN_ADD, rhsReqType, pair.type);
@@ -2704,7 +2706,7 @@ public class NewTypeInference implements CompilerPass {
       case Token.URSH:
         return analyzeBinaryNumericOpBwd(expr, outEnv);
       case Token.ADD:
-        return analyzeAddBwd(expr, outEnv);
+        return analyzeAddBwd(expr, outEnv, requiredType);
       case Token.OR:
       case Token.AND:
         return analyzeLogicalOpBwd(expr, outEnv);
@@ -2840,11 +2842,12 @@ public class NewTypeInference implements CompilerPass {
     return pair;
   }
 
-  private EnvTypePair analyzeAddBwd(Node expr, TypeEnv outEnv) {
+  private EnvTypePair analyzeAddBwd(Node expr, TypeEnv outEnv, JSType requiredType) {
     Node lhs = expr.getFirstChild();
     Node rhs = expr.getLastChild();
-    EnvTypePair rhsPair = analyzeExprBwd(rhs, outEnv, JSType.NUM_OR_STR);
-    EnvTypePair lhsPair = analyzeExprBwd(lhs, rhsPair.env, JSType.NUM_OR_STR);
+    JSType randType = requiredType.isNumber() ? JSType.NUMBER : JSType.NUM_OR_STR;
+    EnvTypePair rhsPair = analyzeExprBwd(rhs, outEnv, randType);
+    EnvTypePair lhsPair = analyzeExprBwd(lhs, rhsPair.env, randType);
     lhsPair.type = JSType.plus(lhsPair.type, rhsPair.type);
     return lhsPair;
   }
@@ -2911,8 +2914,7 @@ public class NewTypeInference implements CompilerPass {
         requiredType, JSType.NUM_OR_STR);
     LValueResultBwd lvalue = analyzeLValueBwd(lhs, outEnv, lhsReqType, false);
     // if lhs is a string, rhs can still be a number
-    JSType rhsReqType = lvalue.type.equals(JSType.NUMBER) ?
-        JSType.NUMBER : JSType.NUM_OR_STR;
+    JSType rhsReqType = lvalue.type.isNumber() ? JSType.NUMBER : JSType.NUM_OR_STR;
     EnvTypePair pair = analyzeExprBwd(rhs, outEnv, rhsReqType);
     pair.env = analyzeLValueBwd(lhs, pair.env, lhsReqType, false).env;
     return pair;
@@ -3362,7 +3364,7 @@ public class NewTypeInference implements CompilerPass {
   private LValueResultFwd analyzeArrayElmLvalFwd(
       Node prop, LValueResultFwd lvalue) {
     EnvTypePair pair = analyzeExprFwd(prop, lvalue.env, JSType.NUMBER);
-    if (!pair.type.equals(JSType.NUMBER)) {
+    if (!pair.type.isNumber()) {
       // Some unknown computed property; don't treat as element access.
       return new LValueResultFwd(pair.env, JSType.UNKNOWN, null, null);
     }
diff --git a/src/com/google/javascript/jscomp/newtypes/JSType.java b/src/com/google/javascript/jscomp/newtypes/JSType.java
index 752c9ab09..a481cb58b 100644
--- a/src/com/google/javascript/jscomp/newtypes/JSType.java
+++ b/src/com/google/javascript/jscomp/newtypes/JSType.java
@@ -271,6 +271,10 @@ public abstract class JSType implements TypeI {
     return STRING_MASK == getMask();
   }
 
+  public boolean isNumber() {
+    return NUMBER_MASK == getMask();
+  }
+
   public boolean isNullOrUndef() {
     int nullUndefMask = NULL_MASK | UNDEFINED_MASK;
     return getMask() != 0 && (getMask() | nullUndefMask) == nullUndefMask;
diff --git a/test/com/google/javascript/jscomp/NewTypeInferenceES5OrLowerTest.java b/test/com/google/javascript/jscomp/NewTypeInferenceES5OrLowerTest.java
index f0fe1da94..daf4c1044 100644
--- a/test/com/google/javascript/jscomp/NewTypeInferenceES5OrLowerTest.java
+++ b/test/com/google/javascript/jscomp/NewTypeInferenceES5OrLowerTest.java
@@ -10469,4 +10469,17 @@ public class NewTypeInferenceES5OrLowerTest extends NewTypeInferenceTestBase {
         + "  }\n"
         + "}");
   }
+
+  public void testPlusBackwardInference() {
+    typeCheck(
+        "function f(/** number */ x, w) {\n"
+        + "  var y = x + 2;\n"
+        + "  function g() { return (y + 2) - 5; }\n"
+        + "}\n");
+
+    typeCheck(
+        "function f(/** number */ x, w) {\n"
+        + "  function h() { return (w + 2) - 5; }\n"
+        + "}\n");
+  }
 }
