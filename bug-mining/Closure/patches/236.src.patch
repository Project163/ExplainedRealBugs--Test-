diff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java
index 942779410..c4b2e6dc5 100644
--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java
+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java
@@ -1162,7 +1162,7 @@ public class DefaultPassConfig extends PassConfig {
         }
         @Override
         public void hotSwapScript(Node scriptRoot, Node originalRoot) {
-          makeTypeInference(compiler).inferTypes(scriptRoot);
+          makeTypeInference(compiler).inferAllScopes(scriptRoot);
         }
       };
     }
diff --git a/src/com/google/javascript/jscomp/Scope.java b/src/com/google/javascript/jscomp/Scope.java
index 933d114d5..b1180b954 100644
--- a/src/com/google/javascript/jscomp/Scope.java
+++ b/src/com/google/javascript/jscomp/Scope.java
@@ -16,8 +16,6 @@
 
 package com.google.javascript.jscomp;
 
-import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS;
-
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
@@ -60,9 +58,6 @@ public class Scope
   private final int depth;
   private final Node rootNode;
 
-  /** The type of {@code this} in the current scope. */
-  private final ObjectType thisType;
-
   /** Whether this is a bottom scope for the purposes of type inference. */
   private final boolean isBottom;
 
@@ -394,42 +389,31 @@ public class Scope
 
     this.parent = parent;
     this.rootNode = rootNode;
-    JSType nodeType = rootNode.getJSType();
-    if (nodeType != null && nodeType.isFunctionType()) {
-      thisType = nodeType.toMaybeFunctionType().getTypeOfThis();
-    } else {
-      thisType = parent.thisType;
-    }
     this.isBottom = false;
     this.depth = parent.depth + 1;
   }
 
-
-  /**
-   * Creates a global Scope.
-   * @param rootNode  Typically the global BLOCK node.
-   */
-  Scope(Node rootNode, AbstractCompiler compiler) {
-    this.parent = null;
-    this.rootNode = rootNode;
-    thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);
-    this.isBottom = false;
-    this.depth = 0;
-  }
-
   /**
    * Creates a empty Scope (bottom of the lattice).
    * @param rootNode Typically a FUNCTION node or the global BLOCK node.
-   * @param thisType the type of {@code this} in this scope
+   * @param isBottom Whether this is the bottom of a lattice. Otherwise,
+   *     it must be a global scope.
    */
-  Scope(Node rootNode, ObjectType thisType) {
+  private Scope(Node rootNode, boolean isBottom) {
     this.parent = null;
     this.rootNode = rootNode;
-    this.thisType = thisType;
-    this.isBottom = true;
+    this.isBottom = isBottom;
     this.depth = 0;
   }
 
+  static Scope createGlobalScope(Node rootNode) {
+    return new Scope(rootNode, false);
+  }
+
+  static Scope createLatticeBottom(Node rootNode) {
+    return new Scope(rootNode, true);
+  }
+
   /** The depth of the scope. The global scope has depth 0. */
   int getDepth() {
     return depth;
@@ -471,7 +455,17 @@ public class Scope
    */
   @Override
   public ObjectType getTypeOfThis() {
-    return thisType;
+    if (isGlobal()) {
+      return ObjectType.cast(rootNode.getJSType());
+    }
+
+    Preconditions.checkState(rootNode.isFunction());
+    JSType nodeType = rootNode.getJSType();
+    if (nodeType != null && nodeType.isFunctionType()) {
+      return nodeType.toMaybeFunctionType().getTypeOfThis();
+    } else {
+      return parent.getTypeOfThis();
+    }
   }
 
   /**
diff --git a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java
index d7f81c713..e1caa7144 100644
--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java
+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java
@@ -68,7 +68,7 @@ class SyntacticScopeCreator implements ScopeCreator {
   public Scope createScope(Node n, Scope parent) {
     inputId = null;
     if (parent == null) {
-      scope = new Scope(n, compiler);
+      scope = Scope.createGlobalScope(n);
     } else {
       scope = new Scope(parent, n);
     }
diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java
index 48c762ee0..cf3424f22 100644
--- a/src/com/google/javascript/jscomp/TypeCheck.java
+++ b/src/com/google/javascript/jscomp/TypeCheck.java
@@ -278,7 +278,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {
   private final JSTypeRegistry typeRegistry;
   private Scope topScope;
 
-  private ScopeCreator scopeCreator;
+  private MemoizedScopeCreator scopeCreator;
 
   private final CheckLevel reportMissingOverride;
   private final CheckLevel reportUnknownTypes;
@@ -303,7 +303,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {
       ReverseAbstractInterpreter reverseInterpreter,
       JSTypeRegistry typeRegistry,
       Scope topScope,
-      ScopeCreator scopeCreator,
+      MemoizedScopeCreator scopeCreator,
       CheckLevel reportMissingOverride,
       CheckLevel reportUnknownTypes) {
     this.compiler = compiler;
diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java
index c2a9d1727..b70c08452 100644
--- a/src/com/google/javascript/jscomp/TypeInference.java
+++ b/src/com/google/javascript/jscomp/TypeInference.java
@@ -78,6 +78,9 @@ class TypeInference
   private final FlowScope bottomScope;
   private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;
 
+  // For convenience
+  private final ObjectType unknownType;
+
   TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,
                 ReverseAbstractInterpreter reverseInterpreter,
                 Scope functionScope,
@@ -86,7 +89,11 @@ class TypeInference
     this.compiler = compiler;
     this.registry = compiler.getTypeRegistry();
     this.reverseInterpreter = reverseInterpreter;
+    this.unknownType = registry.getNativeObjectType(UNKNOWN_TYPE);
+
     this.syntacticScope = functionScope;
+    inferArguments(functionScope);
+
     this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);
     this.assertionFunctionsMap = assertionFunctionsMap;
 
@@ -105,7 +112,40 @@ class TypeInference
     }
 
     this.bottomScope = LinkedFlowScope.createEntryLattice(
-        new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis()));
+        Scope.createLatticeBottom(functionScope.getRootNode()));
+  }
+
+  /**
+   * Infers all of a function's arguments if their types aren't declared.
+   */
+  private void inferArguments(Scope functionScope) {
+    Node functionNode = functionScope.getRootNode();
+    Node astParameters = functionNode.getFirstChild().getNext();
+    FunctionType functionType =
+        JSType.toMaybeFunctionType(functionNode.getJSType());
+    if (functionType != null) {
+      Node parameterTypes = functionType.getParametersNode();
+      if (parameterTypes != null) {
+        Node parameterTypeNode = parameterTypes.getFirstChild();
+        for (Node astParameter : astParameters.children()) {
+          if (parameterTypeNode == null) {
+            return;
+          }
+
+          Var var = functionScope.getVar(astParameter.getString());
+          Preconditions.checkNotNull(var);
+          if (var.isTypeInferred() &&
+              var.getType() == unknownType &&
+              parameterTypeNode.getJSType() != null) {
+            JSType newType = parameterTypeNode.getJSType();
+            var.setType(newType);
+            astParameter.setJSType(newType);
+          }
+
+          parameterTypeNode = parameterTypeNode.getNext();
+        }
+      }
+    }
   }
 
   @Override
@@ -494,7 +534,7 @@ class TypeInference
         String qualifiedName = left.getQualifiedName();
         if (qualifiedName != null) {
           scope.inferQualifiedSlot(left, qualifiedName,
-              leftType == null ? getNativeType(UNKNOWN_TYPE) : leftType,
+              leftType == null ? unknownType : leftType,
               resultType);
         }
 
@@ -640,7 +680,7 @@ class TypeInference
         if (!unflowable && !nonLocalInferredSlot) {
           type = var.getType();
           if (type == null) {
-            type = getNativeType(UNKNOWN_TYPE);
+            type = unknownType;
           }
         }
       }
@@ -692,7 +732,7 @@ class TypeInference
         JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(
             name, rawValueType);
         if (valueType == null) {
-          valueType = getNativeType(UNKNOWN_TYPE);
+          valueType = unknownType;
         }
         objectType.defineInferredProperty(memberName, valueType, name);
 
@@ -707,11 +747,11 @@ class TypeInference
           }
 
           scope.inferQualifiedSlot(name, qKeyName,
-              oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType,
+              oldType == null ? unknownType : oldType,
               valueType);
         }
       } else {
-        n.setJSType(getNativeType(UNKNOWN_TYPE));
+        n.setJSType(unknownType);
       }
     }
     return scope;
@@ -725,17 +765,17 @@ class TypeInference
     JSType leftType = left.getJSType();
     JSType rightType = right.getJSType();
 
-    JSType type = getNativeType(UNKNOWN_TYPE);
+    JSType type = unknownType;
     if (leftType != null && rightType != null) {
       boolean leftIsUnknown = leftType.isUnknownType();
       boolean rightIsUnknown = rightType.isUnknownType();
       if (leftIsUnknown && rightIsUnknown) {
-        type = getNativeType(UNKNOWN_TYPE);
+        type = unknownType;
       } else if ((!leftIsUnknown && leftType.isString()) ||
                  (!rightIsUnknown && rightType.isString())) {
         type = getNativeType(STRING_TYPE);
       } else if (leftIsUnknown || rightIsUnknown) {
-        type = getNativeType(UNKNOWN_TYPE);
+        type = unknownType;
       } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) {
         type = getNativeType(NUMBER_TYPE);
       } else {
@@ -950,7 +990,6 @@ class TypeInference
             iArgumentType.isFunctionType() &&
             iArgument.getJSDocInfo() == null) {
           iArgument.setJSType(restrictedParameter);
-          iArgument.putBooleanProp(Node.INFERRED_FUNCTION, true);
         }
       }
       i++;
@@ -1115,7 +1154,7 @@ class TypeInference
     if (constructorType != null) {
       constructorType = constructorType.restrictByNotNullOrUndefined();
       if (constructorType.isUnknownType()) {
-        type = getNativeType(UNKNOWN_TYPE);
+        type = unknownType;
       } else {
         FunctionType ct = constructorType.toMaybeFunctionType();
         if (ct == null && constructorType instanceof FunctionType) {
@@ -1214,7 +1253,6 @@ class TypeInference
     // 2) A globally declared qualified name (which is in the FlowScope)
     // 3) A property on the owner type (which is on objType)
     // 4) A name in the type registry (as a last resort)
-    JSType unknownType = getNativeType(UNKNOWN_TYPE);
     JSType propertyType = null;
     boolean isLocallyInferred = false;
 
@@ -1249,7 +1287,7 @@ class TypeInference
     }
 
     if (propertyType == null) {
-      return getNativeType(UNKNOWN_TYPE);
+      return unknownType;
     } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) {
       // If the type has been checked in this scope,
       // then use CHECKED_UNKNOWN_TYPE instead to indicate that.
@@ -1473,7 +1511,7 @@ class TypeInference
       // halting the compilation but we should log this and analyze to track
       // down why it happens. This is not critical and will be resolved over
       // time as the type checker is extended.
-      return getNativeType(UNKNOWN_TYPE);
+      return unknownType;
     } else {
       return jsType;
     }
diff --git a/src/com/google/javascript/jscomp/TypeInferencePass.java b/src/com/google/javascript/jscomp/TypeInferencePass.java
index 0dce18a89..cd3d14aa2 100644
--- a/src/com/google/javascript/jscomp/TypeInferencePass.java
+++ b/src/com/google/javascript/jscomp/TypeInferencePass.java
@@ -38,12 +38,12 @@ class TypeInferencePass implements CompilerPass {
   private final AbstractCompiler compiler;
   private final ReverseAbstractInterpreter reverseInterpreter;
   private Scope topScope;
-  private ScopeCreator scopeCreator;
+  private MemoizedScopeCreator scopeCreator;
   private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;
 
   TypeInferencePass(AbstractCompiler compiler,
       ReverseAbstractInterpreter reverseInterpreter,
-      Scope topScope, ScopeCreator scopeCreator) {
+      Scope topScope, MemoizedScopeCreator scopeCreator) {
     this.compiler = compiler;
     this.reverseInterpreter = reverseInterpreter;
     this.topScope = topScope;
@@ -70,17 +70,43 @@ class TypeInferencePass implements CompilerPass {
     Preconditions.checkState(
         externsRoot == null || externsAndJs.hasChild(externsRoot));
 
-    inferTypes(externsAndJs);
+    inferAllScopes(externsAndJs);
   }
 
   /** Entry point for type inference when running over part of the tree. */
-  void inferTypes(Node node) {
-    NodeTraversal inferTypes = new NodeTraversal(
-        compiler, new TypeInferringCallback(), scopeCreator);
-    inferTypes.traverseWithScope(node, topScope);
+  void inferAllScopes(Node node) {
+    // Type analysis happens in two major phases.
+    // 1) Finding all the symbols.
+    // 2) Propagating all the inferred types.
+    //
+    // The order of this analysis is non-obvious. In a complete inference
+    // system, we may need to backtrack arbitrarily far. But the compile-time
+    // costs would be unacceptable.
+    //
+    // We do one pass where we do typed scope creation for all scopes
+    // in pre-order.
+    //
+    // Then we do a second pass where we do all type inference
+    // (type propagation) in pre-order.
+    //
+    // We use a memoized scope creator so that we never create a scope
+    // more than once.
+    //
+    // This will allow us to handle cases like:
+    // var ns = {};
+    // (function() { /** JSDoc */ ns.method = function() {}; })();
+    // ns.method();
+    // In this code, we need to build the symbol table for the inner scope in
+    // order to propagate the type of ns.method in the outer scope.
+    (new NodeTraversal(
+        compiler, new FirstScopeBuildingCallback(), scopeCreator))
+        .traverseWithScope(node, topScope);
+    (new NodeTraversal(
+        compiler, new SecondScopeBuildingCallback(), scopeCreator))
+        .traverseWithScope(node, topScope);
   }
 
-  void inferTypes(NodeTraversal t, Node n, Scope scope) {
+  void inferScope(Node n, Scope scope) {
     TypeInference typeInference =
         new TypeInference(
             compiler, computeCfg(n), reverseInterpreter, scope,
@@ -92,14 +118,26 @@ class TypeInferencePass implements CompilerPass {
       compiler.getTypeRegistry().resolveTypesInScope(scope);
 
     } catch (DataFlowAnalysis.MaxIterationsExceededException e) {
-      compiler.report(t.makeError(n, DATAFLOW_ERROR));
+      compiler.report(JSError.make(n.getSourceFileName(), n, DATAFLOW_ERROR));
     }
   }
 
-  private class TypeInferringCallback extends AbstractScopedCallback {
+  private class FirstScopeBuildingCallback extends AbstractScopedCallback {
     @Override
     public void enterScope(NodeTraversal t) {
-      inferTypes(t, t.getCurrentNode(), t.getScope());
+      t.getScope();
+    }
+
+    @Override
+    public void visit(NodeTraversal t, Node n, Node parent) {
+      // Do nothing
+    }
+  }
+
+  private class SecondScopeBuildingCallback extends AbstractScopedCallback {
+    @Override
+    public void enterScope(NodeTraversal t) {
+      inferScope(t.getScope().getRootNode(), t.getScope());
     }
 
     @Override
diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java
index 7433cba78..ae3d5331c 100644
--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java
+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java
@@ -148,6 +148,9 @@ final class TypedScopeCreator implements ScopeCreator {
   private final Map<Node, AstFunctionContents> functionAnalysisResults =
       Maps.newHashMap();
 
+  // For convenience
+  private final ObjectType unknownType;
+
   /**
    * Defer attachment of types to nodes until all type names
    * have been resolved. Then, we can resolve the type and attach it.
@@ -183,6 +186,7 @@ final class TypedScopeCreator implements ScopeCreator {
     this.codingConvention = codingConvention;
     this.typeRegistry = compiler.getTypeRegistry();
     this.typeParsingErrorReporter = typeRegistry.getErrorReporter();
+    this.unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);
   }
 
   /**
@@ -197,6 +201,15 @@ final class TypedScopeCreator implements ScopeCreator {
     Scope newScope = null;
     AbstractScopeBuilder scopeBuilder = null;
     if (parent == null) {
+      JSType globalThis =
+          typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
+
+      // Mark the main root, the externs root, and the src root
+      // with the global this type.
+      root.setJSType(globalThis);
+      root.getFirstChild().setJSType(globalThis);
+      root.getLastChild().setJSType(globalThis);
+
       // Run a first-order analysis over the syntax tree.
       (new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))
           .process(root.getFirstChild(), root.getLastChild());
@@ -298,7 +311,7 @@ final class TypedScopeCreator implements ScopeCreator {
     NodeTraversal.traverse(
         compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));
 
-    Scope s = new Scope(root, compiler);
+    Scope s = Scope.createGlobalScope(root);
     declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);
     declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);
     declareNativeFunctionType(s, DATE_FUNCTION_TYPE);
@@ -613,7 +626,7 @@ final class TypedScopeCreator implements ScopeCreator {
         } else {
           type = lendsVar.getType();
           if (type == null) {
-            type = typeRegistry.getNativeType(UNKNOWN_TYPE);
+            type = unknownType;
           }
           if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {
             compiler.report(
@@ -791,8 +804,7 @@ final class TypedScopeCreator implements ScopeCreator {
       JSType type = getDeclaredType(sourceName, info, name, value);
       if (type == null) {
         // The variable's type will be inferred.
-        type = name.isFromExterns() ?
-            getNativeType(UNKNOWN_TYPE) : null;
+        type = name.isFromExterns() ? unknownType : null;
       }
       defineSlot(name, var, type);
     }
@@ -900,17 +912,16 @@ final class TypedScopeCreator implements ScopeCreator {
             }
           }
 
-          FunctionType overriddenPropType = null;
+          FunctionType overriddenType = null;
           if (ownerType != null && propName != null) {
-            overriddenPropType =
-                findOverriddenFunction(ownerType, propName);
+            overriddenType = findOverriddenFunction(ownerType, propName);
           }
 
           FunctionTypeBuilder builder =
               new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,
                   scope)
               .setContents(getFunctionAnalysisResults(fnRoot))
-              .inferFromOverriddenFunction(overriddenPropType, parametersNode)
+              .inferFromOverriddenFunction(overriddenType, parametersNode)
               .inferTemplateTypeName(info)
               .inferReturnType(info)
               .inferInheritance(info);
@@ -1686,7 +1697,6 @@ final class TypedScopeCreator implements ScopeCreator {
         // If we see a stub property, make sure to register this property
         // in the type registry.
         ObjectType ownerType = getObjectSlot(ownerName);
-        ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);
         defineSlot(n, parent, unknownType, true);
 
         if (ownerType != null &&
@@ -1832,7 +1842,7 @@ final class TypedScopeCreator implements ScopeCreator {
       // TODO(nicksantos|user): This is a terrible, terrible hack
       // to bail out on recursive typedefs. We'll eventually need
       // to handle these properly.
-      typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));
+      typeRegistry.declareType(typedef, unknownType);
 
       JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);
       if (realType == null) {
@@ -1934,8 +1944,6 @@ final class TypedScopeCreator implements ScopeCreator {
     private void declareArguments(Node functionNode) {
       Node astParameters = functionNode.getFirstChild().getNext();
       Node body = astParameters.getNext();
-      boolean isFnTypeInferred = functionNode.getBooleanProp(
-          Node.INFERRED_FUNCTION);
       FunctionType functionType =
           JSType.toMaybeFunctionType(functionNode.getJSType());
       if (functionType != null) {
@@ -1943,12 +1951,17 @@ final class TypedScopeCreator implements ScopeCreator {
         if (jsDocParameters != null) {
           Node jsDocParameter = jsDocParameters.getFirstChild();
           for (Node astParameter : astParameters.children()) {
+            JSType paramType = jsDocParameter == null ?
+                unknownType : jsDocParameter.getJSType();
+            if (paramType == null) {
+              paramType = unknownType;
+            }
+
+            defineSlot(astParameter, functionNode, paramType,
+                // inferred iff this is the unknown type.
+                unknownType == paramType);
             if (jsDocParameter != null) {
-              defineSlot(astParameter, functionNode,
-                  jsDocParameter.getJSType(), isFnTypeInferred);
               jsDocParameter = jsDocParameter.getNext();
-            } else {
-              defineSlot(astParameter, functionNode, null, true);
             }
           }
         }
diff --git a/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java b/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java
index 5164d0d3e..f70ec7c38 100644
--- a/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java
+++ b/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java
@@ -25,7 +25,6 @@ import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollect
 import com.google.javascript.jscomp.Scope.Var;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
-import com.google.javascript.rhino.jstype.ObjectType;
 
 import junit.framework.TestCase;
 
@@ -51,7 +50,7 @@ public class GlobalVarReferenceMapTest extends TestCase {
       Lists.newArrayList(INPUT1, INPUT2, INPUT3), Lists.newArrayList(EXTERN1));
   private final Map<Var, ReferenceCollection> globalMap = Maps.newHashMap();
   private final Node root = new Node(Token.BLOCK);
-  private final Scope globalScope = new Scope(root, (ObjectType) null);
+  private final Scope globalScope = Scope.createGlobalScope(root);
   private Node scriptRoot = new Node(Token.SCRIPT);
 
   // In the initial setUp we have 3 references to var1 (one in each input) and
@@ -179,7 +178,7 @@ public class GlobalVarReferenceMapTest extends TestCase {
   }
 
   public void testUpdateReferencesWithGlobalScope() {
-    Scope newGlobalScope = new Scope(root, (ObjectType) null);
+    Scope newGlobalScope = Scope.createGlobalScope(root);
     map.updateReferencesWithGlobalScope(newGlobalScope);
     ReferenceCollection references =
         map.getReferences(globalScope.getVar(VAR1));
diff --git a/test/com/google/javascript/jscomp/InferJSDocInfoTest.java b/test/com/google/javascript/jscomp/InferJSDocInfoTest.java
index dde18b723..bc2edcf62 100644
--- a/test/com/google/javascript/jscomp/InferJSDocInfoTest.java
+++ b/test/com/google/javascript/jscomp/InferJSDocInfoTest.java
@@ -20,7 +20,6 @@ package com.google.javascript.jscomp;
 import com.google.common.collect.Lists;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.jscomp.NodeTraversal.Callback;
-import com.google.javascript.jscomp.ScopeCreator;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.jstype.FunctionType;
 import com.google.javascript.rhino.jstype.JSType;
@@ -67,7 +66,7 @@ public class InferJSDocInfoTest extends CompilerTestCase {
     return new CompilerPass() {
       @Override
       public void process(Node externs, Node root) {
-        ScopeCreator scopeCreator =
+        MemoizedScopeCreator scopeCreator =
             new MemoizedScopeCreator(new TypedScopeCreator(compiler));
         Scope topScope = scopeCreator.createScope(root.getParent(), null);
         (new TypeInferencePass(
diff --git a/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java b/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java
index cb7e72361..07a903a01 100644
--- a/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java
+++ b/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java
@@ -42,7 +42,7 @@ public class LinkedFlowScopeTest extends CompilerTypeTestCase {
   public void setUp() throws Exception {
     super.setUp();
 
-    globalScope = new Scope(blockNode, compiler);
+    globalScope = Scope.createGlobalScope(blockNode);
     globalScope.declare("globalA", null, null, null);
     globalScope.declare("globalB", null, null, null);
 
diff --git a/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java b/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java
index 6ac7f64bb..035fab7dc 100644
--- a/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java
+++ b/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java
@@ -365,7 +365,7 @@ public class LiveVariableAnalysisTest extends TestCase {
     script.setInputId(new InputId("test"));
     assertEquals(0, compiler.getErrorCount());
     Scope scope = new SyntacticScopeCreator(compiler).createScope(
-        n, new Scope(script, compiler));
+        n, Scope.createGlobalScope(script));
     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
     cfa.process(null, n);
     ControlFlowGraph<Node> cfg = cfa.getCfg();
diff --git a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java
index cf2ce518c..373ae6716 100644
--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java
@@ -6848,7 +6848,8 @@ public class LooseTypeCheckTest extends CompilerTypeTestCase {
   public void testTypeCheckStandaloneAST() throws Exception {
     Node n = compiler.parseTestCode("function Foo() { }");
     typeCheck(n);
-    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);
+    MemoizedScopeCreator scopeCreator =
+        new MemoizedScopeCreator(new TypedScopeCreator(compiler));
     Scope topScope = scopeCreator.createScope(n, null);
 
     Node second = compiler.parseTestCode("new Foo");
diff --git a/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java b/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java
index 00e23bef8..632f5a892 100644
--- a/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java
+++ b/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java
@@ -42,7 +42,7 @@ public class SemanticReverseAbstractInterpreterTest
   }
 
   public FlowScope newScope() {
-    Scope globalScope = new Scope(new Node(Token.EMPTY), compiler);
+    Scope globalScope = Scope.createGlobalScope(new Node(Token.EMPTY));
     functionScope = new Scope(globalScope, new Node(Token.EMPTY));
     return LinkedFlowScope.createEntryLattice(functionScope);
   }
diff --git a/test/com/google/javascript/jscomp/TypeCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckTest.java
index be9749ac0..26573c2cc 100644
--- a/test/com/google/javascript/jscomp/TypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java
@@ -5848,6 +5848,34 @@ public class TypeCheckTest extends CompilerTypeTestCase {
         "required: boolean");
   }
 
+  public void testIssue61() throws Exception {
+    testTypes(
+        "var ns = {};" +
+        "(function() {" +
+        "  /** @param {string} b */" +
+        "  ns.a = function(b) {};" +
+        "})();" +
+        "function d() {" +
+        "  ns.a(123);" +
+        "}",
+        "actual parameter 1 of ns.a does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
+  public void testIssue61b() throws Exception {
+    testTypes(
+        "var ns = {};" +
+        "(function() {" +
+        "  /** @param {string} b */" +
+        "  ns.a = function(b) {};" +
+        "})();" +
+        "ns.a(123);",
+        "actual parameter 1 of ns.a does not match formal parameter\n" +
+        "found   : number\n" +
+        "required: string");
+  }
+
   public void testIssue86() throws Exception {
     testTypes(
         "/** @interface */ function I() {}" +
@@ -6517,11 +6545,12 @@ public class TypeCheckTest extends CompilerTypeTestCase {
 
   public void testQualifiedNameInference6() throws Exception {
     testTypes(
-        "var ns = {}; " +
+        "/** @const */ var ns = {}; " +
         "/** @param {number} x */ ns.foo = function(x) {};" +
         "(function() { " +
         "    ns.foo = function(x) {};" +
-        "    ns.foo(true); })();",
+        "    ns.foo(true); " +
+        "})();",
         "actual parameter 1 of ns.foo does not match formal parameter\n" +
         "found   : boolean\n" +
         "required: number");
@@ -6542,7 +6571,9 @@ public class TypeCheckTest extends CompilerTypeTestCase {
   }
 
   public void testQualifiedNameInference8() throws Exception {
-    testTypes(
+    // We may need to reshuffle name resolution order so that the @param
+    // type resolves correctly.
+    testClosureTypesMultipleWarnings(
         "var ns = {}; " +
         "(function() { " +
         "  /** @constructor \n * @param {number} x */ " +
@@ -6550,7 +6581,11 @@ public class TypeCheckTest extends CompilerTypeTestCase {
         "})();" +
         "/** @param {ns.Foo} x */ function f(x) {}" +
         "f(new ns.Foo(true));",
-        "Bad type annotation. Unknown type ns.Foo");
+        Lists.newArrayList(
+            "Bad type annotation. Unknown type ns.Foo",
+            "actual parameter 1 of ns.Foo does not match formal parameter\n" +
+            "found   : boolean\n" +
+            "required: number"));
   }
 
   public void testQualifiedNameInference9() throws Exception {
@@ -9746,7 +9781,8 @@ public class TypeCheckTest extends CompilerTypeTestCase {
   public void testTypeCheckStandaloneAST() throws Exception {
     Node n = compiler.parseTestCode("function Foo() { }");
     typeCheck(n);
-    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);
+    MemoizedScopeCreator scopeCreator = new MemoizedScopeCreator(
+        new TypedScopeCreator(compiler));
     Scope topScope = scopeCreator.createScope(n, null);
 
     Node second = compiler.parseTestCode("new Foo");
diff --git a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
index 78c7baedd..da832f8fc 100644
--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
@@ -29,7 +29,6 @@ import com.google.common.collect.Lists;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.jscomp.NodeTraversal.Callback;
 import com.google.javascript.jscomp.Scope.Var;
-import com.google.javascript.jscomp.ScopeCreator;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.EnumType;
@@ -76,7 +75,7 @@ public class TypedScopeCreatorTest extends CompilerTestCase {
     return new CompilerPass() {
       @Override
       public void process(Node externs, Node root) {
-        ScopeCreator scopeCreator =
+        MemoizedScopeCreator scopeCreator =
             new MemoizedScopeCreator(new TypedScopeCreator(compiler));
         Scope topScope = scopeCreator.createScope(root.getParent(), null);
         (new TypeInferencePass(
