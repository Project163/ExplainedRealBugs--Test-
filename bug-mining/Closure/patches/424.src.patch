diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
index 26b6d445f..421d88ece 100644
--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
@@ -483,7 +483,7 @@ public final class ReferenceCollectingCallback implements ScopedCallback,
     private boolean isInitializingAssignmentAt(int index) {
       if (index < references.size() && index > 0) {
         Reference maybeDecl = references.get(index - 1);
-        if (maybeDecl.isVarDeclaration()) {
+        if (maybeDecl.isVarDeclaration() || maybeDecl.isLetDeclaration()) {
           Preconditions.checkState(!maybeDecl.isInitializingDeclaration());
           Reference maybeInit = references.get(index);
           if (maybeInit.isSimpleAssignmentToName()) {
diff --git a/test/com/google/javascript/jscomp/ReferenceCollectingCallbackTest.java b/test/com/google/javascript/jscomp/ReferenceCollectingCallbackTest.java
index 3edc20671..2e1055884 100644
--- a/test/com/google/javascript/jscomp/ReferenceCollectingCallbackTest.java
+++ b/test/com/google/javascript/jscomp/ReferenceCollectingCallbackTest.java
@@ -29,6 +29,7 @@ public final class ReferenceCollectingCallbackTest extends CompilerTestCase {
   @Override
   public void setUp() {
     setLanguage(ECMASCRIPT_NEXT, ECMASCRIPT_NEXT);
+    behavior = null;
   }
 
   @Override
@@ -96,4 +97,50 @@ public final class ReferenceCollectingCallbackTest extends CompilerTestCase {
             "  y;y;" ,
             "}"));
   }
+
+  public void testLetAssignedOnceInLifetime1() {
+    behavior = new Behavior() {
+      @Override
+      public void afterExitScope(NodeTraversal t, ReferenceMap rm)  {
+        if (t.getScope().isCatchScope()) {
+          ReferenceCollection e = rm.getReferences(t.getScope().getVar("e"));
+          assertThat(e.isAssignedOnceInLifetime()).isTrue();
+          ReferenceCollection y = rm.getReferences(t.getScope().getVar("y"));
+          assertThat(y.isAssignedOnceInLifetime()).isTrue();
+          assertThat(y.isWellDefined()).isTrue();
+        }
+      }
+    };
+    testSame(
+        LINE_JOINER.join(
+            "try {",
+            "} catch (e) {",
+            "  let y = e;",
+            "  g();" ,
+            "  y;y;" ,
+            "}"));
+  }
+
+  public void testLetAssignedOnceInLifetime2() {
+    behavior = new Behavior() {
+      @Override
+      public void afterExitScope(NodeTraversal t, ReferenceMap rm)  {
+        if (t.getScope().isCatchScope()) {
+          ReferenceCollection e = rm.getReferences(t.getScope().getVar("e"));
+          assertThat(e.isAssignedOnceInLifetime()).isTrue();
+          ReferenceCollection y = rm.getReferences(t.getScope().getVar("y"));
+          assertThat(y.isAssignedOnceInLifetime()).isTrue();
+          assertThat(y.isWellDefined()).isTrue();
+        }
+      }
+    };
+    testSame(
+        LINE_JOINER.join(
+            "try {",
+            "} catch (e) {",
+            "  let y; y = e;",
+            "  g();" ,
+            "  y;y;" ,
+            "}"));
+  }
 }
