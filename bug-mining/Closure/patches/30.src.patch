diff --git a/externs/gecko_dom.js b/externs/gecko_dom.js
index 7dd5d869d..83498ccf7 100644
--- a/externs/gecko_dom.js
+++ b/externs/gecko_dom.js
@@ -454,7 +454,7 @@ Window.prototype.sizeToContent;
 /**
  * @see http://msdn.microsoft.com/en-us/library/ms536769(VS.85).aspx
  */
-Window.prototype.stop;
+Window.prototype.stop = function() {};
 
 Window.prototype.unescape;
 Window.prototype.updateCommands;
diff --git a/externs/window.js b/externs/window.js
index 10e5deebc..de9441e2c 100644
--- a/externs/window.js
+++ b/externs/window.js
@@ -146,17 +146,17 @@ function prompt(message, opt_value) {}
 /**
  * @param {Function|string} callback
  * @param {number} delay
- * @param {...*} var_args
  * @return {number}
  * @see https://developer.mozilla.org/en/DOM/window.setInterval
+ * @see https://msdn.microsoft.com/en-us/library/ms536749(v=VS.85).aspx
  */
-function setInterval(callback, delay, var_args) {}
+function setInterval(callback, delay) {}
 
 /**
  * @param {Function|string} callback
  * @param {number} delay
- * @param {...*} var_args
  * @return {number}
  * @see https://developer.mozilla.org/en/DOM/window.setTimeout
+ * @see https://msdn.microsoft.com/en-us/library/ms536753(VS.85).aspx
  */
-function setTimeout(callback, delay, var_args) {}
+function setTimeout(callback, delay) {}
diff --git a/javadoc/com/google/javascript/jscomp/ClosureCodingConvention.html b/javadoc/com/google/javascript/jscomp/ClosureCodingConvention.html
index d9b9b37dc..f60e8bbb6 100644
--- a/javadoc/com/google/javascript/jscomp/ClosureCodingConvention.html
+++ b/javadoc/com/google/javascript/jscomp/ClosureCodingConvention.html
@@ -538,7 +538,7 @@ public <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-e
 <DL>
 <DD><B>Description copied from interface: <CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#getAbstractMethodName()">CodingConvention</A></CODE></B></DD>
 <DD>Function name for abstract methods. An abstract method can be assigned to
- an interface method instead of an anonymous function in order to avoid
+ an interface method instead of an function expression in order to avoid
  linter warnings produced by assigning a function without a return value
  where a return value is expected.
 <P>
diff --git a/javadoc/com/google/javascript/jscomp/CodingConvention.html b/javadoc/com/google/javascript/jscomp/CodingConvention.html
index f6e00eb9a..18fc21fa4 100644
--- a/javadoc/com/google/javascript/jscomp/CodingConvention.html
+++ b/javadoc/com/google/javascript/jscomp/CodingConvention.html
@@ -199,7 +199,7 @@ CodingConvention defines a set of hooks to customize the behavior of the
 <CODE>&nbsp;void</CODE></FONT></TD>
 <TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#defineDelegateProxyProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, java.util.Map)">defineDelegateProxyProperties</A></B>(<A HREF="../../../../com/google/javascript/rhino/jstype/JSTypeRegistry.html" title="class in com.google.javascript.rhino.jstype">JSTypeRegistry</A>&nbsp;registry,
                               <A HREF="../../../../com/google/javascript/jscomp/Scope.html" title="class in com.google.javascript.jscomp">Scope</A>&nbsp;scope,
-                              <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&lt;<A HREF="../../../../com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>,<A HREF="../../../../com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>&gt;&nbsp;delegateProxyMap)</CODE>
+                              <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&lt;<A HREF="../../../../com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>,<A HREF="../../../../com/google/javascript/rhino/jstype/FunctionType.html" title="class in com.google.javascript.rhino.jstype">FunctionType</A>&gt;&nbsp;delegateProxyMap)</CODE>
 
 <BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the delegate proxy properties.</TD>
@@ -663,7 +663,7 @@ getAbstractMethodName</H3>
 <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>getAbstractMethodName</B>()</PRE>
 <DL>
 <DD>Function name for abstract methods. An abstract method can be assigned to
- an interface method instead of an anonymous function in order to avoid
+ an interface method instead of an function expression in order to avoid
  linter warnings produced by assigning a function without a return value
  where a return value is expected.
 <P>
@@ -751,13 +751,14 @@ defineDelegateProxyProperties</H3>
 <PRE>
 void <B>defineDelegateProxyProperties</B>(<A HREF="../../../../com/google/javascript/rhino/jstype/JSTypeRegistry.html" title="class in com.google.javascript.rhino.jstype">JSTypeRegistry</A>&nbsp;registry,
                                    <A HREF="../../../../com/google/javascript/jscomp/Scope.html" title="class in com.google.javascript.jscomp">Scope</A>&nbsp;scope,
-                                   <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&lt;<A HREF="../../../../com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>,<A HREF="../../../../com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>&gt;&nbsp;delegateProxyMap)</PRE>
+                                   <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&lt;<A HREF="../../../../com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>,<A HREF="../../../../com/google/javascript/rhino/jstype/FunctionType.html" title="class in com.google.javascript.rhino.jstype">FunctionType</A>&gt;&nbsp;delegateProxyMap)</PRE>
 <DL>
 <DD>Defines the delegate proxy properties. Their types depend on properties of
  the delegate base methods.
 <P>
 <DD><DL>
-</DL>
+<DT><B>Parameters:</B><DD><CODE>delegateProxyMap</CODE> - Map from delegate proxy prototype to delegate base
+     constructor.</DL>
 </DD>
 </DL>
 <HR>
diff --git a/javadoc/com/google/javascript/jscomp/DefaultCodingConvention.html b/javadoc/com/google/javascript/jscomp/DefaultCodingConvention.html
index 04a317182..646ee5e3d 100644
--- a/javadoc/com/google/javascript/jscomp/DefaultCodingConvention.html
+++ b/javadoc/com/google/javascript/jscomp/DefaultCodingConvention.html
@@ -196,7 +196,7 @@ CodingConvention defines a set of hooks to customize the behavior of the
 <CODE>&nbsp;void</CODE></FONT></TD>
 <TD><CODE><B><A HREF="../../../../com/google/javascript/jscomp/DefaultCodingConvention.html#defineDelegateProxyProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, java.util.Map)">defineDelegateProxyProperties</A></B>(<A HREF="../../../../com/google/javascript/rhino/jstype/JSTypeRegistry.html" title="class in com.google.javascript.rhino.jstype">JSTypeRegistry</A>&nbsp;registry,
                               <A HREF="../../../../com/google/javascript/jscomp/Scope.html" title="class in com.google.javascript.jscomp">Scope</A>&nbsp;scope,
-                              <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&lt;<A HREF="../../../../com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>,<A HREF="../../../../com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>&gt;&nbsp;delegateProxyMap)</CODE>
+                              <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&lt;<A HREF="../../../../com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>,<A HREF="../../../../com/google/javascript/rhino/jstype/FunctionType.html" title="class in com.google.javascript.rhino.jstype">FunctionType</A>&gt;&nbsp;delegateProxyMap)</CODE>
 
 <BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the delegate proxy properties.</TD>
@@ -751,7 +751,7 @@ public <A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-e
 <DL>
 <DD><B>Description copied from interface: <CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#getAbstractMethodName()">CodingConvention</A></CODE></B></DD>
 <DD>Function name for abstract methods. An abstract method can be assigned to
- an interface method instead of an anonymous function in order to avoid
+ an interface method instead of an function expression in order to avoid
  linter warnings produced by assigning a function without a return value
  where a return value is expected.
 <P>
@@ -860,7 +860,7 @@ defineDelegateProxyProperties</H3>
 <PRE>
 public void <B>defineDelegateProxyProperties</B>(<A HREF="../../../../com/google/javascript/rhino/jstype/JSTypeRegistry.html" title="class in com.google.javascript.rhino.jstype">JSTypeRegistry</A>&nbsp;registry,
                                           <A HREF="../../../../com/google/javascript/jscomp/Scope.html" title="class in com.google.javascript.jscomp">Scope</A>&nbsp;scope,
-                                          <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&lt;<A HREF="../../../../com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>,<A HREF="../../../../com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>&gt;&nbsp;delegateProxyMap)</PRE>
+                                          <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&lt;<A HREF="../../../../com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>,<A HREF="../../../../com/google/javascript/rhino/jstype/FunctionType.html" title="class in com.google.javascript.rhino.jstype">FunctionType</A>&gt;&nbsp;delegateProxyMap)</PRE>
 <DL>
 <DD><B>Description copied from interface: <CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#defineDelegateProxyProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, java.util.Map)">CodingConvention</A></CODE></B></DD>
 <DD>Defines the delegate proxy properties. Their types depend on properties of
@@ -870,7 +870,8 @@ public void <B>defineDelegateProxyProperties</B>(<A HREF="../../../../com/google
 <DT><B>Specified by:</B><DD><CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html#defineDelegateProxyProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, java.util.Map)">defineDelegateProxyProperties</A></CODE> in interface <CODE><A HREF="../../../../com/google/javascript/jscomp/CodingConvention.html" title="interface in com.google.javascript.jscomp">CodingConvention</A></CODE></DL>
 </DD>
 <DD><DL>
-</DL>
+<DD><CODE>delegateProxyMap</CODE> - Map from delegate proxy prototype to delegate base
+     constructor.</DL>
 </DD>
 </DL>
 <HR>
diff --git a/javadoc/index-all.html b/javadoc/index-all.html
index 50f002b51..d181f667c 100644
--- a/javadoc/index-all.html
+++ b/javadoc/index-all.html
@@ -1336,10 +1336,10 @@ Constructor for class com.google.javascript.jscomp.<A HREF="./com/google/javascr
 <DT><A HREF="./com/google/javascript/rhino/jstype/ObjectType.html#defineDeclaredProperty(java.lang.String, com.google.javascript.rhino.jstype.JSType, boolean)"><B>defineDeclaredProperty(String, JSType, boolean)</B></A> - 
 Method in class com.google.javascript.rhino.jstype.<A HREF="./com/google/javascript/rhino/jstype/ObjectType.html" title="class in com.google.javascript.rhino.jstype">ObjectType</A>
 <DD>Defines a property whose type is synthesized (i.e.
-<DT><A HREF="./com/google/javascript/jscomp/CodingConvention.html#defineDelegateProxyProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, java.util.Map)"><B>defineDelegateProxyProperties(JSTypeRegistry, Scope, Map&lt;ObjectType, ObjectType&gt;)</B></A> - 
+<DT><A HREF="./com/google/javascript/jscomp/CodingConvention.html#defineDelegateProxyProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, java.util.Map)"><B>defineDelegateProxyProperties(JSTypeRegistry, Scope, Map&lt;ObjectType, FunctionType&gt;)</B></A> - 
 Method in interface com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/CodingConvention.html" title="interface in com.google.javascript.jscomp">CodingConvention</A>
 <DD>Defines the delegate proxy properties.
-<DT><A HREF="./com/google/javascript/jscomp/DefaultCodingConvention.html#defineDelegateProxyProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, java.util.Map)"><B>defineDelegateProxyProperties(JSTypeRegistry, Scope, Map&lt;ObjectType, ObjectType&gt;)</B></A> - 
+<DT><A HREF="./com/google/javascript/jscomp/DefaultCodingConvention.html#defineDelegateProxyProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, java.util.Map)"><B>defineDelegateProxyProperties(JSTypeRegistry, Scope, Map&lt;ObjectType, FunctionType&gt;)</B></A> - 
 Method in class com.google.javascript.jscomp.<A HREF="./com/google/javascript/jscomp/DefaultCodingConvention.html" title="class in com.google.javascript.jscomp">DefaultCodingConvention</A>
 <DD>&nbsp;
 <DT><A HREF="./com/google/javascript/rhino/jstype/EnumType.html#defineElement(java.lang.String)"><B>defineElement(String)</B></A> - 
diff --git a/lib/google_common_deploy.jar b/lib/google_common_deploy.jar
index 60cbecf33..0cde7cf86 100755
Binary files a/lib/google_common_deploy.jar and b/lib/google_common_deploy.jar differ
diff --git a/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java b/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java
index 190c4aafc..b413beb3f 100644
--- a/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java
+++ b/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java
@@ -92,7 +92,7 @@ class CheckRequiresForConstructors implements CompilerPass {
           }
           break;
         case Token.FUNCTION:
-          if (NodeUtil.isFunctionAnonymous(n)) {
+          if (NodeUtil.isFunctionExpression(n)) {
             if (parent.getType() == Token.NAME) {
               String functionName = parent.getString();
               info = (JSDocInfo) parent.getProp(Node.JSDOC_INFO_PROP);
diff --git a/src/com/google/javascript/jscomp/CodingConvention.java b/src/com/google/javascript/jscomp/CodingConvention.java
index 4416fc4c9..b2d26e9b0 100644
--- a/src/com/google/javascript/jscomp/CodingConvention.java
+++ b/src/com/google/javascript/jscomp/CodingConvention.java
@@ -166,7 +166,7 @@ public interface CodingConvention {
 
   /**
    * Function name for abstract methods. An abstract method can be assigned to
-   * an interface method instead of an anonymous function in order to avoid
+   * an interface method instead of an function expression in order to avoid
    * linter warnings produced by assigning a function without a return value
    * where a return value is expected.
    * @return function name.
@@ -208,10 +208,13 @@ public interface CodingConvention {
   /**
    * Defines the delegate proxy properties. Their types depend on properties of
    * the delegate base methods.
+   *
+   * @param delegateProxyMap Map from delegate proxy prototype to delegate base
+   *     constructor.
    */
   public void defineDelegateProxyProperties(
       JSTypeRegistry registry, Scope scope,
-      Map<ObjectType, ObjectType> delegateProxyMap);
+      Map<ObjectType, FunctionType> delegateProxyMap);
 
   /**
    * Gets the name of the global object.
diff --git a/src/com/google/javascript/jscomp/CollapseAnonymousFunctions.java b/src/com/google/javascript/jscomp/CollapseAnonymousFunctions.java
index ba079fac4..b1ca18b81 100644
--- a/src/com/google/javascript/jscomp/CollapseAnonymousFunctions.java
+++ b/src/com/google/javascript/jscomp/CollapseAnonymousFunctions.java
@@ -21,7 +21,7 @@ import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
 /**
- * Collapses anonymous function declarations into named function declarations,
+ * Collapses anonymous function expressions into named function declarations,
  * i.e. the following:
  *
  * <pre>
diff --git a/src/com/google/javascript/jscomp/DefaultCodingConvention.java b/src/com/google/javascript/jscomp/DefaultCodingConvention.java
index a485ce339..5390b0450 100644
--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java
+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java
@@ -155,7 +155,7 @@ public class DefaultCodingConvention implements CodingConvention {
   @Override
   public void defineDelegateProxyProperties(
       JSTypeRegistry registry, Scope scope,
-      Map<ObjectType, ObjectType> delegateProxyMap) {
+      Map<ObjectType, FunctionType> delegateProxyMap) {
     // do nothing.
   }
 
diff --git a/src/com/google/javascript/jscomp/DefinitionsRemover.java b/src/com/google/javascript/jscomp/DefinitionsRemover.java
index 42f481c87..4bcb6c80e 100644
--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java
+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java
@@ -44,10 +44,10 @@ class DefinitionsRemover {
     if (NodeUtil.isVarDeclaration(n) && n.hasChildren()) {
       return new VarDefinition(n);
     } else if(NodeUtil.isFunction(parent) && parent.getFirstChild() == n) {
-      if (!NodeUtil.isAnonymousFunction(parent)) {
+      if (!NodeUtil.isFunctionExpression(parent)) {
         return new NamedFunctionDefinition(parent);
       } else if (!n.getString().equals("")) {
-        return new AnonymousFunctionDefinition(parent);
+        return new FunctionExpressionDefinition(parent);
       }
     } else if (NodeUtil.isAssign(parent) && parent.getFirstChild() == n) {
       return new AssignmentDefinition(parent);
@@ -201,11 +201,11 @@ class DefinitionsRemover {
    * Represents a function expression that acts as a rhs.  The defined
    * name is only reachable from within the function.
    */
-  static final class AnonymousFunctionDefinition extends FunctionDefinition {
-    AnonymousFunctionDefinition(Node node) {
+  static final class FunctionExpressionDefinition extends FunctionDefinition {
+    FunctionExpressionDefinition(Node node) {
       super(node);
       Preconditions.checkArgument(
-          NodeUtil.isAnonymousFunction(node));
+          NodeUtil.isFunctionExpression(node));
     }
 
     @Override
diff --git a/src/com/google/javascript/jscomp/FunctionNames.java b/src/com/google/javascript/jscomp/FunctionNames.java
index edb8b50d3..90f769c44 100644
--- a/src/com/google/javascript/jscomp/FunctionNames.java
+++ b/src/com/google/javascript/jscomp/FunctionNames.java
@@ -62,7 +62,7 @@ class FunctionNames implements CompilerPass, Serializable {
   @Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, functionListExtractor);
-    AnonymousFunctionNamer namer = new AnonymousFunctionNamer(functionMap);
+    FunctionExpressionNamer namer = new FunctionExpressionNamer(functionMap);
     AnonymousFunctionNamingCallback namingCallback =
         new AnonymousFunctionNamingCallback(namer);
     NodeTraversal.traverse(compiler, root, namingCallback);
@@ -145,14 +145,14 @@ class FunctionNames implements CompilerPass, Serializable {
     }
   }
 
-  private static class AnonymousFunctionNamer
+  private static class FunctionExpressionNamer
       implements AnonymousFunctionNamingCallback.FunctionNamer {
     private static final char DELIMITER = '.';
     private static final NodeNameExtractor extractor =
         new NodeNameExtractor(DELIMITER);
     private final Map<Node, FunctionRecord> functionMap;
 
-    AnonymousFunctionNamer(Map<Node, FunctionRecord> functionMap) {
+    FunctionExpressionNamer(Map<Node, FunctionRecord> functionMap) {
       this.functionMap = functionMap;
     }
 
diff --git a/src/com/google/javascript/jscomp/FunctionRewriter.java b/src/com/google/javascript/jscomp/FunctionRewriter.java
index 7e2bd8fd9..07f46266b 100644
--- a/src/com/google/javascript/jscomp/FunctionRewriter.java
+++ b/src/com/google/javascript/jscomp/FunctionRewriter.java
@@ -243,7 +243,7 @@ class FunctionRewriter implements CompilerPass {
 
     @Override
     public Node reduce(Node node) {
-      if (!NodeUtil.isAnonymousFunction(node)) {
+      if (!NodeUtil.isFunctionExpression(node)) {
         return node;
       }
 
@@ -314,7 +314,7 @@ class FunctionRewriter implements CompilerPass {
 
     @Override
     public Node reduce(Node node) {
-      if (!NodeUtil.isAnonymousFunction(node)) {
+      if (!NodeUtil.isFunctionExpression(node)) {
         return node;
       }
 
@@ -374,7 +374,7 @@ class FunctionRewriter implements CompilerPass {
 
     @Override
     public Node reduce(Node node) {
-      if (!NodeUtil.isAnonymousFunction(node)) {
+      if (!NodeUtil.isFunctionExpression(node)) {
         return node;
       }
 
@@ -428,7 +428,7 @@ class FunctionRewriter implements CompilerPass {
 
     @Override
     public Node reduce(Node node) {
-      if (!NodeUtil.isAnonymousFunction(node)) {
+      if (!NodeUtil.isFunctionExpression(node)) {
         return node;
       }
 
@@ -490,7 +490,7 @@ class FunctionRewriter implements CompilerPass {
 
     @Override
     public Node reduce(Node node) {
-      if (!NodeUtil.isAnonymousFunction(node)) {
+      if (!NodeUtil.isFunctionExpression(node)) {
         return node;
       }
 
diff --git a/src/com/google/javascript/jscomp/GlobalNamespace.java b/src/com/google/javascript/jscomp/GlobalNamespace.java
index 0a4fd6dfe..0c6f89d41 100644
--- a/src/com/google/javascript/jscomp/GlobalNamespace.java
+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java
@@ -278,7 +278,7 @@ class GlobalNamespace {
               case Token.FUNCTION:
                 Node gramps = parent.getParent();
                 if (gramps == null ||
-                    NodeUtil.isFunctionAnonymous(parent)) return;
+                    NodeUtil.isFunctionExpression(parent)) return;
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
diff --git a/src/com/google/javascript/jscomp/InferJSDocInfo.java b/src/com/google/javascript/jscomp/InferJSDocInfo.java
index c544e0601..0d788b5dc 100644
--- a/src/com/google/javascript/jscomp/InferJSDocInfo.java
+++ b/src/com/google/javascript/jscomp/InferJSDocInfo.java
@@ -53,7 +53,7 @@ import javax.annotation.Nullable;
  * Foo.prototype.bar = goog.abstractMethod;
  * </code>
  * the JSDocInfo will appear in two places in the type system: in the 'bar'
- * slot of Foo.prototype, and on the anonymous function type created by
+ * slot of Foo.prototype, and on the function expression type created by
  * this expression.
  *
  * @author nicksantos@google.com (Nick Santos)
diff --git a/src/com/google/javascript/jscomp/InlineFunctions.java b/src/com/google/javascript/jscomp/InlineFunctions.java
index 7f1bc2392..8e7beb439 100644
--- a/src/com/google/javascript/jscomp/InlineFunctions.java
+++ b/src/com/google/javascript/jscomp/InlineFunctions.java
@@ -69,7 +69,7 @@ class InlineFunctions implements CompilerPass {
   private final FunctionInjector injector;
 
   private final boolean blockFunctionInliningEnabled;
-  private final boolean inlineAnonymousFunctionExpressions;
+  private final boolean inlineFunctionExpressions;
   private final boolean inlineGlobalFunctions;
   private final boolean inlineLocalFunctions;
 
@@ -77,7 +77,7 @@ class InlineFunctions implements CompilerPass {
       Supplier<String> safeNameIdSupplier,
       boolean inlineGlobalFunctions,
       boolean inlineLocalFunctions,
-      boolean inlineAnonymousFunctionExpressions,
+      boolean inlineFunctionExpressions,
       boolean blockFunctionInliningEnabled,
       boolean enableExpressionDecomposition) {
     Preconditions.checkArgument(compiler != null);
@@ -86,8 +86,8 @@ class InlineFunctions implements CompilerPass {
 
     this.inlineGlobalFunctions = inlineGlobalFunctions;
     this.inlineLocalFunctions = inlineLocalFunctions;
-    this.inlineAnonymousFunctionExpressions =
-      inlineAnonymousFunctionExpressions;
+    this.inlineFunctionExpressions =
+      inlineFunctionExpressions;
     this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;
 
     this.injector = new FunctionInjector(
@@ -152,7 +152,7 @@ class InlineFunctions implements CompilerPass {
         NodeTraversal nodeTraversal, Node n, Node parent) {
       // Don't traverse into function bodies
       // if we aren't inlining local functions.
-      return inlineLocalFunctions || inlineAnonymousFunctionExpressions
+      return inlineLocalFunctions || inlineFunctionExpressions
          || parent == null || NodeUtil.isControlStructure(parent)
          || NodeUtil.isStatementBlock(parent);
     }
@@ -162,8 +162,8 @@ class InlineFunctions implements CompilerPass {
           || (!t.inGlobalScope() && inlineLocalFunctions)) {
         findNamedFunctions(t, n, parent);
 
-        if (inlineAnonymousFunctionExpressions) {
-          findAnonymousFunctionExpressions(t, n);
+        if (inlineFunctionExpressions) {
+          findFunctionExpressions(t, n);
         }
       }
     }
@@ -175,7 +175,7 @@ class InlineFunctions implements CompilerPass {
       }
 
       switch (n.getType()) {
-        // Anonymous functions in the form of:
+        // Functions expressions in the form of:
         //   var fooFn = function(x) { return ... }
         case Token.VAR:
           // TODO(johnlenz): Make this a Preconditions check.
@@ -195,7 +195,7 @@ class InlineFunctions implements CompilerPass {
         case Token.FUNCTION:
           Preconditions.checkState(NodeUtil.isStatementBlock(parent)
               || parent.getType() == Token.LABEL);
-          if (!NodeUtil.isFunctionAnonymous(n)) {
+          if (!NodeUtil.isFunctionExpression(n)) {
             Function fn = new NamedFunction(n);
             maybeAddFunction(fn, t.getModule());
           }
@@ -204,14 +204,14 @@ class InlineFunctions implements CompilerPass {
     }
 
     /**
-     * Find anonymous functions that are called directly in the form of
+     * Find function expressions that are called directly in the form of
      *   (function(a,b,...){...})(a,b,...)
      * or
      *   (function(a,b,...){...}).call(this,a,b, ...)
      */
-    public void findAnonymousFunctionExpressions(NodeTraversal t, Node n) {
+    public void findFunctionExpressions(NodeTraversal t, Node n) {
       switch (n.getType()) {
-        // Anonymous functions in the form of:
+        // Functions expressions in the form of:
         //   (function(){})();
         case Token.CALL:
           Node fnNode = null;
@@ -226,7 +226,7 @@ class InlineFunctions implements CompilerPass {
 
           // If a interesting function was discovered, add it.
           if (fnNode != null) {
-            Function fn = new AnonymousFunction(fnNode, callsSeen++);
+            Function fn = new FunctionExpression(fnNode, callsSeen++);
             maybeAddFunction(fn, t.getModule());
             anonFns.put(fnNode, fn.getName());
           }
@@ -893,7 +893,10 @@ class InlineFunctions implements CompilerPass {
     }
   }
 
-  /** Interface for dealing with named and anonymous functions equally */
+  /** 
+   * Interface for dealing with function declarations and function 
+   * expressions equally 
+   */
   private static interface Function {
     /** Gets the name of the function */
     public String getName();
@@ -947,12 +950,12 @@ class InlineFunctions implements CompilerPass {
     }
   }
 
-  /** AnonymousFunction implementation of the Function interface */
-  private static class AnonymousFunction implements Function {
+  /** FunctionExpression implementation of the Function interface */
+  private static class FunctionExpression implements Function {
     private final Node fn;
     private final String fakeName;
 
-    public AnonymousFunction(Node fn, int index) {
+    public FunctionExpression(Node fn, int index) {
       this.fn = fn;
       // A number is not a valid function javascript indentifier
       // so we don't need to worry about collisions.
diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java
index 054b8b3bb..b9538c350 100644
--- a/src/com/google/javascript/jscomp/InlineVariables.java
+++ b/src/com/google/javascript/jscomp/InlineVariables.java
@@ -328,6 +328,8 @@ class InlineVariables implements CompilerPass {
                         Reference init, Reference reference) {
       Node value = init.getAssignedValue();
       Preconditions.checkState(value != null);
+      // Check for function declarations before the value is moved in the AST.
+      boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value);
 
       inlineValue(v, reference, value.detachFromParent());
       if (declaration != init) {
@@ -335,7 +337,13 @@ class InlineVariables implements CompilerPass {
         Preconditions.checkState(expressRoot.getType() == Token.EXPR_RESULT);
         NodeUtil.removeChild(expressRoot.getParent(), expressRoot);
       }
-      removeDeclaration(declaration);
+
+      // Function declarations have already been removed.
+      if (!isFunctionDeclaration) {
+        removeDeclaration(declaration);
+      } else {
+        compiler.reportCodeChange();
+      }
     }
 
     /**
@@ -429,7 +437,7 @@ class InlineVariables implements CompilerPass {
       Node value = init.getAssignedValue();
       if (value == null) {
         // This constant is either externally defined or initialized indirectly
-        // (e.g. in an anonymous function used to hide
+        // (e.g. in an function expression used to hide
         // temporary variables), so the constant is ineligible for inlining.
         return false;
       }
@@ -539,7 +547,7 @@ class InlineVariables implements CompilerPass {
      * If the value is a literal, we can cross more boundaries to inline it.
      */
     private boolean canMoveAggressively(Node value) {
-      // Anonymous functions and other mutable objects can move within
+      // Function expressions and other mutable objects can move within
       // the same basic block.
       return NodeUtil.isLiteralValue(value)
           || value.getType() == Token.FUNCTION;
@@ -584,23 +592,25 @@ class InlineVariables implements CompilerPass {
     }
 
     /**
-     * @return true if the reference is a normal VAR declaration (only normal
-     * VARs can be inlined).
+     * @return true if the reference is a normal VAR or FUNCTION declaration.
      */
     private boolean isValidDeclaration(Reference declaration) {
-      return declaration.getParent().getType() == Token.VAR
-          && declaration.getGrandparent().getType() != Token.FOR;
+      return (declaration.getParent().getType() == Token.VAR
+          && declaration.getGrandparent().getType() != Token.FOR)
+          || NodeUtil.isFunctionDeclaration(declaration.getParent());
     }
 
     /**
-     * @return Whether
+     * @return Whether there is a initial value.
      */
     private boolean isValidInitialization(Reference initialization) {
       if (initialization == null) {
         return false;
       } else if (initialization.isDeclaration()) {
-        // The reference is a normal VAR declaration with
-        return initialization.getNameNode().getFirstChild() != null;
+        // The reference is a FUNCTION declaration or normal VAR declaration
+        // with a value.
+        return NodeUtil.isFunctionDeclaration(initialization.getParent())
+            || initialization.getNameNode().getFirstChild() != null;
       } else {
         Node parent = initialization.getParent();
         Preconditions.checkState(
diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java
index 3b8bbd448..d9409b886 100644
--- a/src/com/google/javascript/jscomp/NameAnalyzer.java
+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java
@@ -864,8 +864,8 @@ final class NameAnalyzer implements CompilerPass {
         }
       } else {
         // No named dependency scope found.  Unfortunately that might
-        // mean that the expression is a child of an anonymous
-        // function or assignment with a complex lhs.  In those cases,
+        // mean that the expression is a child of an function expression
+        // or assignment with a complex lhs.  In those cases,
         // protect this node by creating a reference to WINDOW.
         for (Node ancestor : n.getAncestors()) {
           if (NodeUtil.isAssignmentOp(ancestor) ||
@@ -1388,8 +1388,8 @@ final class NameAnalyzer implements CompilerPass {
 
   /**
    * Get dependency scope defined by the enclosing function, or null.
-   * If enclosing function is anonymous, determine scope based on its
-   * parent if the parent node is a variable declaration or
+   * If enclosing function is a function expression, determine scope based on
+   * its parent if the parent node is a variable declaration or
    * assignment.
    */
   private NameInformation getEnclosingFunctionDependencyScope(NodeTraversal t) {
@@ -1403,7 +1403,7 @@ final class NameAnalyzer implements CompilerPass {
       return ref;
     }
 
-    // anonymous function.  try to get a name from the parent var
+    // Function expression.  try to get a name from the parent var
     // declaration or assignment.
     Node parent = function.getParent();
     if (parent != null) {
diff --git a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java
index e6afe612f..d5603d744 100644
--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java
+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java
@@ -606,7 +606,7 @@ class NameReferenceGraphConstruction implements CompilerPass {
   }
 
   /**
-   * Find the first containing function that's not an anonymous
+   * Find the first containing function that's not an function expression
    * closure.
    */
   private Name getNamedContainingFunction() {
diff --git a/src/com/google/javascript/jscomp/NodeTraversal.java b/src/com/google/javascript/jscomp/NodeTraversal.java
index d75d89d1a..6a162066b 100644
--- a/src/com/google/javascript/jscomp/NodeTraversal.java
+++ b/src/com/google/javascript/jscomp/NodeTraversal.java
@@ -486,18 +486,20 @@ public class NodeTraversal {
 
     final Node fnName = n.getFirstChild();
 
-    boolean anonymous = parent != null && NodeUtil.isFunctionAnonymous(n);
+    boolean isFunctionExpression = (parent != null)
+        && NodeUtil.isFunctionExpression(n);
 
-    if (!anonymous) {
-      // Named functions are parent of the containing scope.
+    if (!isFunctionExpression) {
+      // Functions declarations are in the scope containing the declaration.
       traverseBranch(fnName, n);
     }
 
     curNode = n;
     pushScope(n);
 
-    if (anonymous) {
-      // Anonymous function names are parent of the contained scope.
+    if (isFunctionExpression) {
+      // Function expression names are only accessible within the function
+      // scope.
       traverseBranch(fnName, n);
     }
 
diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java
index 08b35b34e..04b926c2b 100644
--- a/src/com/google/javascript/jscomp/NodeUtil.java
+++ b/src/com/google/javascript/jscomp/NodeUtil.java
@@ -144,7 +144,7 @@ public final class NodeUtil {
    * <li>{@code var name2 = function name1() ...}</li>
    * <li>{@code qualified.name2 = function name1() ...}</li>
    * </ul>
-   * In two last cases with named anonymous functions, the second name is
+   * In two last cases with named function expressions, the second name is
    * returned (the variable of qualified name).
    *
    * @param n a node whose type is {@link Token#FUNCTION}
@@ -404,12 +404,10 @@ public final class NodeUtil {
         break;
 
       case Token.FUNCTION:
-        // Anonymous functions don't have side-effects, but named ones
-        // change the namespace. Therefore, we check if the function has
-        // a name. Either way, we don't need to check the children, since
-        // they aren't executed at declaration time.
-        //
-        return !isFunctionAnonymous(n);
+        // Function expressions don't have side-effects, but function
+        // declarations change the namespace. Either way, we don't need to
+        // check the children, since they aren't executed at declaration time.
+        return !isFunctionExpression(n);
 
       case Token.NEW:
         if (checkForNewObjects) {
@@ -624,9 +622,9 @@ public final class NodeUtil {
         return true;
 
       case Token.FUNCTION:
-        // Anonymous functions definitions are not changed by side-effects,
-        // and named functions are not part of expressions.
-        Preconditions.checkState(isAnonymousFunction(n));
+        // Function expression are not changed by side-effects,
+        // and function declarations are not part of expressions.
+        Preconditions.checkState(isFunctionExpression(n));
         return false;
     }
 
@@ -1049,9 +1047,8 @@ public final class NodeUtil {
   static boolean isStatement(Node n) {
     Node parent = n.getParent();
     // It is not possible to determine definitely if a node is a statement
-    // or not if it is not part of the AST.  A FUNCTION node, for instance,
-    // is either part of an expression (as a anonymous function) or as
-    // a statement.
+    // or not if it is not part of the AST.  A FUNCTION node can be
+    // either part of an expression or a statement.
     Preconditions.checkState(parent != null);
     switch (parent.getType()) {
       case Token.SCRIPT:
@@ -1070,7 +1067,7 @@ public final class NodeUtil {
 
   /**
    * @return Whether the name is a reference to a variable, function or
-   *       function parameter (not a label or a empty anonymous function name).
+   *       function parameter (not a label or a empty function expression name).
    */
   static boolean isReferenceName(Node n) {
     return isName(n) && !n.getString().isEmpty();
@@ -1191,10 +1188,10 @@ public final class NodeUtil {
   /**
    * Is this node a function declaration? A function declaration is a function
    * that has a name that is added to the current scope (i.e. a function that
-   * is not anonymous; see {@link #isFunctionAnonymous}).
+   * is not part of a expression; see {@link #isFunctionExpression}).
    */
   static boolean isFunctionDeclaration(Node n) {
-    return n.getType() == Token.FUNCTION && !isFunctionAnonymous(n);
+    return n.getType() == Token.FUNCTION && isStatement(n);
   }
 
   /**
@@ -1208,41 +1205,31 @@ public final class NodeUtil {
             || n.getParent().getParent().getType() == Token.FUNCTION);
   }
 
-
-  /**
-   * Is this node an anonymous function? An anonymous function is one that has
-   * either no name or a name that is not added to the current scope (see
-   * {@link #isFunctionAnonymous}).
-   */
-  static boolean isAnonymousFunction(Node n) {
-    return n.getType() == Token.FUNCTION && isFunctionAnonymous(n);
-  }
-
   /**
-   * Is a FUNCTION node an anonymous function? An anonymous function is one that
-   * has either no name or a name that is not added to the current scope.
+   * Is a FUNCTION node an function expression? An function expression is one
+   * that has either no name or a name that is not added to the current scope.
    *
-   * <p>Some examples of anonymous functions:
+   * <p>Some examples of function expressions:
    * <pre>
-   * function () {}
+   * (function () {})
    * (function f() {})()
    * [ function f() {} ]
    * var f = function f() {};
    * for (function f() {};;) {}
    * </pre>
    *
-   * <p>Some examples of functions that are <em>not</em> anonymous:
+   * <p>Some examples of functions that are <em>not</em> expressions:
    * <pre>
    * function f() {}
    * if (x); else function f() {}
    * for (;;) { function f() {} }
    * </pre>
    *
-   * @param n A FUNCTION node
-   * @return Whether n is an anonymous function
+   * @param n A node
+   * @return Whether n is an function used within an expression.
    */
-  static boolean isFunctionAnonymous(Node n) {
-    return !isStatement(n);
+  static boolean isFunctionExpression(Node n) {
+    return n.getType() == Token.FUNCTION && !isStatement(n);
   }
 
   /**
diff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java
index 5c5f2fca7..bca6ff3ee 100644
--- a/src/com/google/javascript/jscomp/Normalize.java
+++ b/src/com/google/javascript/jscomp/Normalize.java
@@ -296,7 +296,7 @@ class Normalize implements CompilerPass {
      */
     private void normalizeFunctionDeclaration(Node n) {
       Preconditions.checkState(n.getType() == Token.FUNCTION);
-      if (!NodeUtil.isFunctionAnonymous(n)
+      if (!NodeUtil.isFunctionExpression(n)
           && !NodeUtil.isHoistedFunctionDeclaration(n)) {
         rewriteFunctionDeclaration(n);
       }
diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java
index f45fccefb..fb69d3229 100644
--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java
+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java
@@ -207,7 +207,7 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback
         // If this is a declaration of a provided named function, this is an
         // error. Hosited functions will explode if the're provided.
         if (t.inGlobalScope() &&
-            !NodeUtil.isFunctionAnonymous(n)) {
+            !NodeUtil.isFunctionExpression(n)) {
           String name = n.getFirstChild().getString();
           ProvidedName pn = providedNames.get(name);
           if (pn != null) {
diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
index 061e3aba8..1e4b0ae92 100644
--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
@@ -453,11 +453,12 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {
     }
 
    /**
-    * @return For an assignment or variable declaration return the assigned
-    * value, otherwise null.
+    * @return For an assignment, variable declaration, or function declaration 
+    * return the assigned value, otherwise null.
     */
     Node getAssignedValue() {
-      return NodeUtil.getAssignedValue(getNameNode());
+      return (parent.getType() == Token.FUNCTION)
+          ? parent : NodeUtil.getAssignedValue(getNameNode());
     }
 
     BasicBlock getBasicBlock() {
diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java
index 1202f99af..d2792aec1 100644
--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java
+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java
@@ -54,7 +54,7 @@ class RemoveUnusedVars implements CompilerPass {
 
   private final boolean removeGlobals;
 
-  private boolean preserveAnonymousFunctionNames;
+  private boolean preserveFunctionExpressionNames;
 
   /**
    * Keeps track of what variables we've warned about, so that we don't do it
@@ -70,10 +70,10 @@ class RemoveUnusedVars implements CompilerPass {
   RemoveUnusedVars(
       AbstractCompiler compiler,
       boolean removeGlobals,
-      boolean preserveAnonymousFunctionNames) {
+      boolean preserveFunctionExpressionNames) {
     compiler_ = compiler;
     this.removeGlobals = removeGlobals;
-    this.preserveAnonymousFunctionNames = preserveAnonymousFunctionNames;
+    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;
   }
 
   /**
@@ -121,9 +121,9 @@ class RemoveUnusedVars implements CompilerPass {
       // Otherwise we traverse into the function only when we encounter
       // a reference to it (see markReferencedVar())
       case Token.FUNCTION:
-        // If it's an exported function, or an anonymous function, assume
+        // If it's an exported function, or an function expression, assume
         // that it'll be called.
-        if (NodeUtil.isFunctionAnonymous(n) ||
+        if (NodeUtil.isFunctionExpression(n) ||
             compiler_.getCodingConvention().isExported(
                 n.getFirstChild().getString())) {
           traverseFunction(n, scope);
@@ -245,9 +245,8 @@ class RemoveUnusedVars implements CompilerPass {
             parent.getType() == Token.FUNCTION) {
           // Don't remove function arguments here. That's a special case
           // that's taken care of in removeUnreferencedFunctionArgs.
-        } else if (toRemove.getType() == Token.FUNCTION &&
-            NodeUtil.isFunctionAnonymous(toRemove)) {
-          if (!preserveAnonymousFunctionNames) {
+        } else if (NodeUtil.isFunctionExpression(toRemove)) {
+          if (!preserveFunctionExpressionNames) {
             toRemove.getFirstChild().setString("");
             compiler_.reportCodeChange();
           }
diff --git a/src/com/google/javascript/jscomp/RenameVars.java b/src/com/google/javascript/jscomp/RenameVars.java
index d6c5db1f0..33704edbd 100644
--- a/src/com/google/javascript/jscomp/RenameVars.java
+++ b/src/com/google/javascript/jscomp/RenameVars.java
@@ -100,11 +100,11 @@ final class RenameVars implements CompilerPass {
   private final boolean localRenamingOnly;
 
   /**
-   * Whether anonymous function names should be preserved. Typically, for
+   * Whether function expression names should be preserved. Typically, for
    * debugging purposes.
    * @see NameAnonymousFunctions
    */
-  private boolean preserveAnonymousFunctionNames;
+  private boolean preserveFunctionExpressionNames;
 
   /** Generate pseudo names for variables for debugging purposes */
   private boolean generatePseudoNames;
@@ -118,7 +118,7 @@ final class RenameVars implements CompilerPass {
   RenameVars(AbstractCompiler compiler,
       String prefix,
       boolean localRenamingOnly,
-      boolean preserveAnonymousFunctionNames,
+      boolean preserveFunctionExpressionNames,
       boolean generatePseudoNames,
       VariableMap prevUsedRenameMap,
       @Nullable char[] reservedCharacters,
@@ -126,7 +126,7 @@ final class RenameVars implements CompilerPass {
     this.compiler = compiler;
     this.prefix = prefix == null ? "" : prefix;
     this.localRenamingOnly = localRenamingOnly;
-    this.preserveAnonymousFunctionNames = preserveAnonymousFunctionNames;
+    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;
     this.generatePseudoNames = generatePseudoNames;
     this.prevUsedRenameMap = prevUsedRenameMap;
     this.reservedCharacters = reservedCharacters;
@@ -190,10 +190,10 @@ final class RenameVars implements CompilerPass {
         return;
       }
 
-      // Are we renaming anonymous function names?
-      if (preserveAnonymousFunctionNames
+      // Are we renaming function expression names?
+      if (preserveFunctionExpressionNames
           && var != null
-          && NodeUtil.isAnonymousFunction(var.getParentNode())) {
+          && NodeUtil.isFunctionExpression(var.getParentNode())) {
         reservedNames.add(name);
         return;
       }
diff --git a/src/com/google/javascript/jscomp/SuspiciousPropertiesCheck.java b/src/com/google/javascript/jscomp/SuspiciousPropertiesCheck.java
index 983297a61..4793a6a08 100644
--- a/src/com/google/javascript/jscomp/SuspiciousPropertiesCheck.java
+++ b/src/com/google/javascript/jscomp/SuspiciousPropertiesCheck.java
@@ -167,7 +167,7 @@ class SuspiciousPropertiesCheck implements CompilerPass {
           String name = n.getString();
 
           // Avoid anonymous functions
-          if (name.length() > 0) {
+          if (!name.isEmpty()) {
             // Only count globals
             Scope.Var var = t.getScope().getVar(name);
             if (var != null && !var.isLocal()) {
diff --git a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java
index 6601af81e..27af6ef9f 100644
--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java
+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java
@@ -92,7 +92,7 @@ class SyntacticScopeCreator implements ScopeCreator {
       // Bleed the function name into the scope, if it hasn't
       // been declared in the outer scope.
       String fnName = fnNameNode.getString();
-      if (!fnName.isEmpty() && NodeUtil.isFunctionAnonymous(n)) {
+      if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {
         declareVar(fnName, fnNameNode, n, null, null, n);
       }
 
@@ -132,7 +132,7 @@ class SyntacticScopeCreator implements ScopeCreator {
         return;
 
       case Token.FUNCTION:
-        if (NodeUtil.isFunctionAnonymous(n)) {
+        if (NodeUtil.isFunctionExpression(n)) {
           return;
         }
 
diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java
index 6c8491c7c..10858af0f 100644
--- a/src/com/google/javascript/jscomp/TypeInference.java
+++ b/src/com/google/javascript/jscomp/TypeInference.java
@@ -864,7 +864,7 @@ class TypeInference
                 JSType jArgumentType = getJSType(jArgument);
                 if (jArgument.getType() == Token.FUNCTION &&
                     jArgumentType instanceof FunctionType) {
-                  // If it's an anonymous function, update the type of this
+                  // If it's an function expression, update the type of this
                   // using the actual type of T.
                   FunctionType jArgumentFnType =(FunctionType) jArgumentType;
                   if (jArgumentFnType.getTypeOfThis().isUnknownType()) {
diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java
index 1e9a86b8e..3226a0977 100644
--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java
+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java
@@ -104,7 +104,7 @@ final class TypedScopeCreator implements ScopeCreator {
   private final TypeValidator validator;
   private final CodingConvention codingConvention;
   private final JSTypeRegistry typeRegistry;
-  private Map<ObjectType, ObjectType> delegateProxyMap = Maps.newHashMap();
+  private Map<ObjectType, FunctionType> delegateProxyMap = Maps.newHashMap();
 
   /**
    * Defer attachment of types to nodes until all type names
@@ -892,47 +892,7 @@ final class TypedScopeCreator implements ScopeCreator {
           DelegateRelationship delegateRelationship =
               codingConvention.getDelegateRelationship(n);
           if (delegateRelationship != null) {
-            ObjectType delegatorObject = ObjectType.cast(
-                typeRegistry.getType(delegateRelationship.delegator));
-            ObjectType delegateBaseObject = ObjectType.cast(
-                typeRegistry.getType(delegateRelationship.delegateBase));
-            ObjectType delegateSuperObject = ObjectType.cast(
-                typeRegistry.getType(
-                    codingConvention.getDelegateSuperclassName()));
-            if (delegatorObject != null &&
-                delegateBaseObject != null &&
-                delegateSuperObject != null) {
-              FunctionType delegatorCtor = delegatorObject.getConstructor();
-              FunctionType delegateBaseCtor =
-                  delegateBaseObject.getConstructor();
-              FunctionType delegateSuperCtor =
-                  delegateSuperObject.getConstructor();
-
-              if (delegatorCtor != null && delegateBaseCtor != null &&
-                  delegateSuperCtor != null) {
-                FunctionParamBuilder functionParamBuilder =
-                    new FunctionParamBuilder(typeRegistry);
-                functionParamBuilder.addRequiredParams(
-                    typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE));
-                FunctionType findDelegate = typeRegistry.createFunctionType(
-                    typeRegistry.createDefaultObjectUnion(
-                        delegateBaseObject),
-                    functionParamBuilder.build());
-
-                FunctionType delegateProxy =
-                    typeRegistry.createConstructorType(
-                        delegateBaseObject.getReferenceName(), null, null,
-                        null);
-                delegateProxy.setPrototypeBasedOn(delegateBaseCtor);
-
-                codingConvention.applyDelegateRelationship(
-                    delegateSuperObject, delegateBaseObject, delegatorObject,
-                    delegateProxy, findDelegate);
-                delegateProxyMap.put(
-                    delegateProxy.getPrototype(),
-                    delegateBaseCtor.getPrototype());
-              }
-            }
+            applyDelegateRelationship(delegateRelationship);
           }
 
           ObjectLiteralCast objectLiteralCast =
@@ -1003,6 +963,46 @@ final class TypedScopeCreator implements ScopeCreator {
       }
     }
 
+    private void applyDelegateRelationship(
+        DelegateRelationship delegateRelationship) {
+      ObjectType delegatorObject = ObjectType.cast(
+          typeRegistry.getType(delegateRelationship.delegator));
+      ObjectType delegateBaseObject = ObjectType.cast(
+          typeRegistry.getType(delegateRelationship.delegateBase));
+      ObjectType delegateSuperObject = ObjectType.cast(
+          typeRegistry.getType(codingConvention.getDelegateSuperclassName()));
+      if (delegatorObject != null &&
+          delegateBaseObject != null &&
+          delegateSuperObject != null) {
+        FunctionType delegatorCtor = delegatorObject.getConstructor();
+        FunctionType delegateBaseCtor = delegateBaseObject.getConstructor();
+        FunctionType delegateSuperCtor = delegateSuperObject.getConstructor();
+
+        if (delegatorCtor != null && delegateBaseCtor != null &&
+            delegateSuperCtor != null) {
+          FunctionParamBuilder functionParamBuilder =
+              new FunctionParamBuilder(typeRegistry);
+          functionParamBuilder.addRequiredParams(
+              typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE));
+          FunctionType findDelegate = typeRegistry.createFunctionType(
+              typeRegistry.createDefaultObjectUnion(delegateBaseObject),
+              functionParamBuilder.build());
+
+          // The suffix is necessary for the proxy to be distinguished from
+          // the base.
+          FunctionType delegateProxy = typeRegistry.createConstructorType(
+              delegateBaseObject.getReferenceName() + "(Proxy)",
+              null, null, null);
+          delegateProxy.setPrototypeBasedOn(delegateBaseObject);
+
+          codingConvention.applyDelegateRelationship(
+              delegateSuperObject, delegateBaseObject, delegatorObject,
+              delegateProxy, findDelegate);
+          delegateProxyMap.put(delegateProxy.getPrototype(), delegateBaseCtor);
+        }
+      }
+    }
+
     /**
      * Handle typedefs.
      * @param t The current traversal.
diff --git a/src/com/google/javascript/jscomp/VarCheck.java b/src/com/google/javascript/jscomp/VarCheck.java
index e133335ec..e5de984ca 100644
--- a/src/com/google/javascript/jscomp/VarCheck.java
+++ b/src/com/google/javascript/jscomp/VarCheck.java
@@ -99,7 +99,7 @@ class VarCheck extends AbstractPostOrderCallback implements CompilerPass {
 
       // A function declaration with an empty name passes Rhino,
       // but is supposed to be a syntax error according to the spec.
-      if (!NodeUtil.isAnonymousFunction(parent)) {
+      if (!NodeUtil.isFunctionExpression(parent)) {
         t.report(n, INVALID_FUNCTION_DECL);
       }
       return;
@@ -109,7 +109,7 @@ class VarCheck extends AbstractPostOrderCallback implements CompilerPass {
     Scope scope = t.getScope();
     Scope.Var var = scope.getVar(varName);
     if (var == null) {
-      if (NodeUtil.isAnonymousFunction(parent)) {
+      if (NodeUtil.isFunctionExpression(parent)) {
         // e.g. [ function foo() {} ], it's okay if "foo" isn't defined in the
         // current scope.
       } else {
diff --git a/test/com/google/javascript/jscomp/CodePrinterTest.java b/test/com/google/javascript/jscomp/CodePrinterTest.java
index 9be994746..f8b16110a 100644
--- a/test/com/google/javascript/jscomp/CodePrinterTest.java
+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java
@@ -184,7 +184,7 @@ public class CodePrinterTest extends TestCase {
     assertPrint("typeof ({})", "typeof{}");
     assertPrint("f({})", "f({})");
 
-    // Anonymous functions.
+    // Anonymous function expressions.
     assertPrint("(function(){})", "(function(){})");
     assertPrint("(function(){})()", "(function(){})()");
     assertPrint("(function(){})instanceof Object",
@@ -195,8 +195,10 @@ public class CodePrinterTest extends TestCase {
     assertPrint("var x = function() { }();", "var x=function(){}()");
     assertPrint("(function() {}), 2", "(function(){}),2");
 
-    // Named functions
+    // Name functions expression.
     assertPrint("(function f(){})", "(function f(){})");
+    
+    // Function declaration.
     assertPrint("function f(){}", "function f(){}");
 
     // Make sure we don't treat non-latin character escapes as raw strings.
diff --git a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
index 9593eb651..f18b3f80d 100644
--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
@@ -215,22 +215,20 @@ public class CommandLineRunnerTest extends TestCase {
     args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
     args.add("--warning_level=QUIET");
     args.add("--debug=false");
-    test("function Foo() {};" +
+    test("function Foo() {}" +
          "Foo.x = 1;" +
          "function f() {throw new Foo().x;} f();",
-         "function a() {};" +
-         "throw new a().a;");
+         "throw (new function() {}).a;");
   }
 
   public void testDebugFlag4() {
     args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
     args.add("--warning_level=QUIET");
     args.add("--debug=true");
-    test("function Foo() {};" +
+    test("function Foo() {}" +
         "Foo.x = 1;" +
         "function f() {throw new Foo().x;} f();",
-        "function $Foo$$() {};" +
-        "throw new $Foo$$().$x$;");
+        "throw (new function Foo() {}).$x$;");
   }
 
   public void testHelpFlag() {
diff --git a/test/com/google/javascript/jscomp/DefinitionsRemoverTest.java b/test/com/google/javascript/jscomp/DefinitionsRemoverTest.java
index a2b3d51aa..c630faf23 100644
--- a/test/com/google/javascript/jscomp/DefinitionsRemoverTest.java
+++ b/test/com/google/javascript/jscomp/DefinitionsRemoverTest.java
@@ -57,7 +57,7 @@ public class DefinitionsRemoverTest extends CompilerTestCase {
     test("foo({ 'one' : 1 , 'two' : 2 })", "foo({ })");
   }
 
-  public void testRemoveAnonymousFunctionName() {
+  public void testRemoveFunctionExpressionName() {
     test("foo(function f(){})", "foo(function (){})");
   }
 
diff --git a/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java b/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java
index d2dcd234f..e3252d5b3 100644
--- a/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java
+++ b/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java
@@ -134,8 +134,8 @@ public class ExpresssionDecomposerTest extends TestCase {
   }
 
   public void testCanExposeExpression7() {
-    // Verify calls to anonymous function are movable.
-    helperCanExposeAnonymousFunctionExpression(
+    // Verify calls to function expressions are movable.
+    helperCanExposeFunctionExpression(
         DecompositionType.MOVABLE,
         "(function(map){descriptions_=map})(\n" +
             "function(){\n" +
@@ -403,7 +403,7 @@ public class ExpresssionDecomposerTest extends TestCase {
     helperCanExposeExpression(expectedResult, code, fnName, null);
   }
 
-  private void helperCanExposeAnonymousFunctionExpression(
+  private void helperCanExposeFunctionExpression(
       DecompositionType expectedResult, String code, int call) {
     Compiler compiler = new Compiler();
     Set<String> knownConstants = Sets.newHashSet();
diff --git a/test/com/google/javascript/jscomp/InlineFunctionsTest.java b/test/com/google/javascript/jscomp/InlineFunctionsTest.java
index 2494ecc8c..eaac9cf2b 100644
--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java
+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java
@@ -25,7 +25,7 @@ public class InlineFunctionsTest extends CompilerTestCase {
   boolean allowGlobalFunctionInlining = true;
   boolean allowBlockInlining = true;
   final boolean allowExpressionDecomposition = true;
-  final boolean allowAnonymousFunctionExpressionInlining = true;
+  final boolean allowFunctionExpressionInlining = true;
   final boolean allowLocalFunctionInlining = true;
 
   public InlineFunctionsTest() {
@@ -49,7 +49,7 @@ public class InlineFunctionsTest extends CompilerTestCase {
         compiler.getUniqueNameIdSupplier(),
         allowGlobalFunctionInlining,
         allowLocalFunctionInlining,
-        allowAnonymousFunctionExpressionInlining,
+        allowFunctionExpressionInlining,
         allowBlockInlining,
         allowExpressionDecomposition);
   }
@@ -1333,7 +1333,7 @@ public class InlineFunctionsTest extends CompilerTestCase {
         "x = JSCompiler_temp_const_0 + JSCompiler_inline_result_1;");
   }
 
-  public void testDecomposeAnonymousInCall() {
+  public void testDecomposeFunctionExpressionInCall() {
     test(
         "(function(map){descriptions_=map})(\n" +
            "function(){\n" +
@@ -1380,89 +1380,89 @@ public class InlineFunctionsTest extends CompilerTestCase {
          "function _g() {var t; {x.call(this); t = void 0}}");
   }
 
-  public void testAnonymousFunctionInlining1() {
+  public void testFunctionExpressionInlining1() {
     test("(function(){})()",
          "void 0");
   }
 
-  public void testAnonymousFunctionInlining2() {
+  public void testFunctionExpressionInlining2() {
     test("(function(){foo()})()",
          "{foo()}");
   }
 
-  public void testAnonymousFunctionInlining3() {
+  public void testFunctionExpressionInlining3() {
     test("var a = (function(){return foo()})()",
          "var a = foo()");
   }
 
-  public void testAnonymousFunctionInlining4() {
+  public void testFunctionExpressionInlining4() {
     test("var a; a = 1 + (function(){return foo()})()",
          "var a; a = 1 + foo()");
   }
 
-  public void testAnonymousFunctionCallInlining1() {
+  public void testFunctionExpressionCallInlining1() {
     test("(function(){}).call(this)",
          "void 0");
   }
 
-  public void testAnonymousFunctionCallInlining2() {
+  public void testFunctionExpressionCallInlining2() {
     test("(function(){foo(this)}).call(this)",
          "{foo(this)}");
   }
 
-  public void testAnonymousFunctionCallInlining3() {
+  public void testFunctionExpressionCallInlining3() {
     test("var a = (function(){return foo(this)}).call(this)",
          "var a = foo(this)");
   }
 
-  public void testAnonymousFunctionCallInlining4() {
+  public void testFunctionExpressionCallInlining4() {
     test("var a; a = 1 + (function(){return foo(this)}).call(this)",
          "var a; a = 1 + foo(this)");
   }
 
-  public void testAnonymousFunctionCallInlining5() {
+  public void testFunctionExpressionCallInlining5() {
     test("a:(function(){return foo()})()",
          "a:foo()");
   }
 
-  public void testAnonymousFunctionCallInlining6() {
+  public void testFunctionExpressionCallInlining6() {
     test("a:(function(){return foo()}).call(this)",
          "a:foo()");
   }
 
-  public void testAnonymousFunctionCallInlining7() {
+  public void testFunctionExpressionCallInlining7() {
     test("a:(function(){})()",
          "a:void 0");
   }
 
-  public void testAnonymousFunctionCallInlining8() {
+  public void testFunctionExpressionCallInlining8() {
     test("a:(function(){}).call(this)",
          "a:void 0");
   }
 
-  public void testAnonymousFunctionCallInlining9() {
+  public void testFunctionExpressionCallInlining9() {
     // ... with unused recursive name.
     test("(function foo(){})()",
          "void 0");
   }
 
-  public void testAnonymousFunctionCallInlining10() {
+  public void testFunctionExpressionCallInlining10() {
     // ... with unused recursive name.
     test("(function foo(){}).call(this)",
          "void 0");
   }
 
-  public void testAnonymousFunctionCallInlining11() {
+  public void testFunctionExpressionCallInlining11() {
     // Can't inline functions that return inner functions.
     testSame("((function(){return function(){foo()}})())();");
   }
 
-  public void testAnonymousFunctionCallInlining12() {
+  public void testFunctionExpressionCallInlining12() {
     // Can't inline functions that recurse.
     testSame("(function foo(){foo()})()");
   }
 
-  public void testAnonymousFunctionOmega() {
+  public void testFunctionExpressionOmega() {
     // ... with unused recursive name.
     test("(function (f){f(f)})(function(f){f(f)})",
          "{var f$$inline_1=function(f$$1){f$$1(f$$1)};" +
@@ -1529,7 +1529,7 @@ public class InlineFunctionsTest extends CompilerTestCase {
   }
 
   // http://en.wikipedia.org/wiki/Fixed_point_combinator#Y_combinator
-  public void testAnonymousFunctionYCombinator() {
+  public void testFunctionExpressionYCombinator() {
     testSame(
         "var factorial = ((function(M) {\n" +
         "      return ((function(f) {\n" +
diff --git a/test/com/google/javascript/jscomp/InlineVariablesTest.java b/test/com/google/javascript/jscomp/InlineVariablesTest.java
index fab23ea57..f4742731a 100644
--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java
+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java
@@ -281,9 +281,14 @@ public class InlineVariablesTest extends CompilerTestCase {
     testSame(
         new String[] { "var x = a;", "",
             "(function() { a++; })(); var z = x;"});
+    test(
+        new String[] { "var x = a;", "",
+            "function cow() { a++; }; cow(); var z = x;"}, 
+        new String[] { "var x = a;", "",
+            ";(function cow(){ a++; })(); var z = x;"});
     testSame(
         new String[] { "var x = a;", "",
-            "function cow() { a++; }; cow(); var z = x;"});
+            "cow(); var z = x; function cow() { a++; };"});
   }
 
   // Test movement of constant values
@@ -532,6 +537,10 @@ public class InlineVariablesTest extends CompilerTestCase {
     testSame("var x = 0; (function x() { return x ? x() : 3; })();");
   }
 
+  public void testRecursiveFunction2() {
+    testSame("function y() { return y(); }");
+  }
+
   public void testUnreferencedBleedingFunction() {
     testSame("var x = function y() {}");
   }
@@ -717,26 +726,50 @@ public class InlineVariablesTest extends CompilerTestCase {
       );
   }
 
-  public void testInlineFunctionAlias1() {
+  public void testInlineFunctionAlias1a() {
     test(
-      "function f(x) {};" +
+      "function f(x) {}" +
       "var y = f;" +
       "g();" +
       "y();y();",
+      "var y = function f(x) {};" +
+      "g();" +
+      "y();y();"
+      );
+  }
+
+  public void testInlineFunctionAlias1b() {
+    test(
       "function f(x) {};" +
+      "f;var y = f;" +
       "g();" +
+      "y();y();",
+      "function f(x) {};" +
+      "f;g();" +
       "f();f();"
       );
   }
 
-  public void testInlineFunctionAlias2() {
+  public void testInlineFunctionAlias2a() {
     test(
-      "function f(x) {};" +
+      "function f(x) {}" +
       "var y; y = f;" +
       "g();" +
       "y();y();",
+      "var y; y = function f(x) {};" +
+      "g();" +
+      "y();y();"
+      );
+  }
+
+  public void testInlineFunctionAlias2b() {
+    test(
+      "function f(x) {};" +
+      "f; var y; y = f;" +
+      "g();" +
+      "y();y();",
       "function f(x) {};" +
-      "f;" +
+      "f; f;" +
       "g();" +
       "f();f();"
       );
@@ -836,4 +869,8 @@ public class InlineVariablesTest extends CompilerTestCase {
     testSame(
         "function f() { var a = this; var g = function() { a.y(); }; a.z(); }");
   }
+
+  public void testInlineNamedFunction() {
+    test("function f() {} f();", "(function f(){})()");
+  }
 }
diff --git a/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java b/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java
index 930e8559e..371e7bee1 100644
--- a/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java
+++ b/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java
@@ -137,7 +137,7 @@ public class MakeDeclaredNamesUniqueTest extends CompilerTestCase {
          "function foo(a){var b}" +
          "function boo(a$$1){var b$$1}");
 
-    // Verify anonymous functions are renamed.
+    // Verify functions expressions are renamed.
     testWithInversion(
         "var a = function foo(){foo()};var b = function foo(){foo()};",
         "var a = function foo(){foo()};var b = function foo$$1(){foo$$1()};");
@@ -236,7 +236,7 @@ public class MakeDeclaredNamesUniqueTest extends CompilerTestCase {
          "function foo$$unique_1(){var b$$unique_3;a$$unique_0}" +
          "function boo$$unique_2(){var b$$unique_4;a$$unique_0}");
 
-    // Verify anonymous functions are renamed.
+    // Verify function expressions are renamed.
     test("var a = function foo(){foo()};",
          "var a$$unique_0 = function foo$$unique_1(){foo$$unique_1()};");
 
diff --git a/test/com/google/javascript/jscomp/MoveFunctionDeclarationsTest.java b/test/com/google/javascript/jscomp/MoveFunctionDeclarationsTest.java
index 1843b73d5..7d11ae54f 100644
--- a/test/com/google/javascript/jscomp/MoveFunctionDeclarationsTest.java
+++ b/test/com/google/javascript/jscomp/MoveFunctionDeclarationsTest.java
@@ -37,7 +37,7 @@ public class MoveFunctionDeclarationsTest extends CompilerTestCase {
          new String[] { "function f(){} function g(){} a" });
   }
 
-  public void testAnonymousFunctions() {
+  public void testFunctionsExpression() {
     testSame("a; f = function(){}");
   }
 
diff --git a/test/com/google/javascript/jscomp/NodeIteratorsTest.java b/test/com/google/javascript/jscomp/NodeIteratorsTest.java
index d74ed5f01..f49f1245e 100644
--- a/test/com/google/javascript/jscomp/NodeIteratorsTest.java
+++ b/test/com/google/javascript/jscomp/NodeIteratorsTest.java
@@ -51,12 +51,12 @@ public class NodeIteratorsTest extends TestCase {
         Token.VAR, Token.NAME, Token.VAR, Token.SCRIPT);
   }
 
-  public void testAnonymousFunction() {
+  public void testFunctionExpression() {
     testVarMotionWithCode("var X = 3, Y = function() {}; 3;",
         Token.NAME, Token.VAR, Token.NUMBER, Token.EXPR_RESULT, Token.SCRIPT);
   }
 
-  public void testAnonymousFunction2() {
+  public void testFunctionExpression2() {
     testVarMotionWithCode("var X = 3; var Y = function() {}; 3;",
         Token.VAR, Token.NAME, Token.VAR, Token.NUMBER,
         Token.EXPR_RESULT, Token.SCRIPT);
diff --git a/test/com/google/javascript/jscomp/NodeUtilTest.java b/test/com/google/javascript/jscomp/NodeUtilTest.java
index 68e8358cb..740045241 100644
--- a/test/com/google/javascript/jscomp/NodeUtilTest.java
+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java
@@ -347,7 +347,7 @@ public class NodeUtilTest extends TestCase {
   }
 
 
-  public void testIsFunctionAnonymous() {
+  public void testIsFunctionExpression() {
     assertContainsAnonFunc(true, "(function(){})");
     assertContainsAnonFunc(true, "[function a(){}]");
     assertContainsAnonFunc(false, "{x: function a(){}}");
@@ -393,7 +393,7 @@ public class NodeUtilTest extends TestCase {
     Node funcParent = findParentOfFuncDescendant(parse(js));
     assertNotNull("Expected function node in parse tree of: " + js, funcParent);
     Node funcNode = getFuncChild(funcParent);
-    assertEquals(expected, NodeUtil.isFunctionAnonymous(funcNode));
+    assertEquals(expected, NodeUtil.isFunctionExpression(funcNode));
   }
 
   private Node findParentOfFuncDescendant(Node n) {
@@ -539,7 +539,7 @@ public class NodeUtilTest extends TestCase {
     assertTrue(NodeUtil.isControlStructureCodeBlock(ifNode, elseCase));
   }
 
-  public void testIsAnonymousFunction1() {
+  public void testIsFunctionExpression1() {
     Compiler compiler = new Compiler();
 
     Node root = parse("(function foo() {})");
@@ -547,16 +547,16 @@ public class NodeUtilTest extends TestCase {
     assertTrue(NodeUtil.isExpressionNode(StatementNode));
     Node functionNode = StatementNode.getFirstChild();
     assertTrue(NodeUtil.isFunction(functionNode));
-    assertTrue(NodeUtil.isAnonymousFunction(functionNode));
+    assertTrue(NodeUtil.isFunctionExpression(functionNode));
   }
 
-  public void testIsAnonymousFunction2() {
+  public void testIsFunctionExpression2() {
     Compiler compiler = new Compiler();
 
     Node root = parse("function foo() {}");
     Node functionNode = root.getFirstChild();
     assertTrue(NodeUtil.isFunction(functionNode));
-    assertFalse(NodeUtil.isAnonymousFunction(functionNode));
+    assertFalse(NodeUtil.isFunctionExpression(functionNode));
   }
 
   public void testRemoveTryChild() {
diff --git a/test/com/google/javascript/jscomp/NormalizeTest.java b/test/com/google/javascript/jscomp/NormalizeTest.java
index 7f42a2a7e..4ab4f6c65 100644
--- a/test/com/google/javascript/jscomp/NormalizeTest.java
+++ b/test/com/google/javascript/jscomp/NormalizeTest.java
@@ -212,7 +212,7 @@ public class NormalizeTest extends CompilerTestCase {
          "function foo(a){var b}" +
          "function boo(a$$1){var b$$1}");
 
-    // Verify anonymous functions are renamed.
+    // Verify function expressions are renamed.
     test("var a = function foo(){foo()};var b = function foo(){foo()};",
          "var a = function foo(){foo()};var b = function foo$$1(){foo$$1()};");
 
diff --git a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java
index 53ade289c..2c109d322 100644
--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java
+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java
@@ -20,7 +20,7 @@ package com.google.javascript.jscomp;
 public class RemoveUnusedVarsTest extends CompilerTestCase {
 
   private boolean removeGlobal = true;
-  private boolean preserveAnonymousFunctionNames = false;
+  private boolean preserveFunctionExpressionNames = false;
   
   public RemoveUnusedVarsTest() {
     super("", false);
@@ -29,13 +29,13 @@ public class RemoveUnusedVarsTest extends CompilerTestCase {
   @Override
   public void setUp() {
     removeGlobal = true;
-    preserveAnonymousFunctionNames = false;
+    preserveFunctionExpressionNames = false;
   }
   
   @Override
   protected CompilerPass getProcessor(final Compiler compiler) {
     return new RemoveUnusedVars(
-        compiler, removeGlobal, preserveAnonymousFunctionNames);
+        compiler, removeGlobal, preserveFunctionExpressionNames);
   }
 
   public void testRemoveUnusedVars() {
@@ -71,7 +71,7 @@ public class RemoveUnusedVarsTest extends CompilerTestCase {
          "var arg=\"foo\";if(arg.length>40)arg=arg.substr(0,40)+\"...\";" +
          "x+=arg}");
 
-    // Test with anonymous functions in another function call
+    // Test with function expressions in another function call
     test("function A(){}" +
          "if(0){function B(){}}win.setTimeout(function(){A()})",
          "function A(){}" +
@@ -201,7 +201,7 @@ public class RemoveUnusedVarsTest extends CompilerTestCase {
     test("var x=function f(){};x()",
          "var x=function(){};x()");
 
-    preserveAnonymousFunctionNames = true;
+    preserveFunctionExpressionNames = true;
     testSame("var x=function f(){};x()");
   }
 
@@ -209,7 +209,7 @@ public class RemoveUnusedVarsTest extends CompilerTestCase {
     test("foo(function bar(){})",
          "foo(function(){})");
 
-    preserveAnonymousFunctionNames = true;
+    preserveFunctionExpressionNames = true;
     testSame("foo(function bar(){})");    
   }
   
diff --git a/test/com/google/javascript/jscomp/RenameVarsTest.java b/test/com/google/javascript/jscomp/RenameVarsTest.java
index 9e55e05e6..c3e9e03d7 100644
--- a/test/com/google/javascript/jscomp/RenameVarsTest.java
+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java
@@ -34,7 +34,7 @@ public class RenameVarsTest extends CompilerTestCase {
   private RenameVars renameVars;
   private boolean withClosurePass = false;
   private boolean localRenamingOnly = false;
-  private boolean preserveAnonymousFunctionNames = false;
+  private boolean preserveFunctionExpressionNames = false;
   private boolean useGoogleCodingConvention = true;
   private boolean generatePseudoNames = false;
 
@@ -53,7 +53,7 @@ public class RenameVarsTest extends CompilerTestCase {
       return new ClosurePassAndRenameVars(compiler);
     } else {
       return renameVars = new RenameVars(compiler, prefix,
-          localRenamingOnly, preserveAnonymousFunctionNames,
+          localRenamingOnly, preserveFunctionExpressionNames,
           generatePseudoNames,
           previouslyUsedMap, null, null);
     }
@@ -71,7 +71,7 @@ public class RenameVarsTest extends CompilerTestCase {
     prefix = DEFAULT_PREFIX;
     withClosurePass = false;
     localRenamingOnly = false;
-    preserveAnonymousFunctionNames = false;
+    preserveFunctionExpressionNames = false;
     generatePseudoNames = false;
 
     // TODO(johnlenz): Enable Normalize during these tests.
@@ -129,7 +129,7 @@ public class RenameVarsTest extends CompilerTestCase {
   }
 
   public void testRecursiveFunctions2() {
-    preserveAnonymousFunctionNames = true;
+    preserveFunctionExpressionNames = true;
 
     test("var walk = function walk(node, aFunction) {" +
          "  walk(node, aFunction);" +
diff --git a/test/com/google/javascript/jscomp/TypeCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckTest.java
index 6cca8abc4..51c947208 100644
--- a/test/com/google/javascript/jscomp/TypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java
@@ -1234,7 +1234,7 @@ public class TypeCheckTest extends CompilerTypeTestCase {
   }
 
   public void testScoping11() throws Exception {
-    // named anonymous functions create a binding in their body only
+    // named function expressions create a binding in their body only
     // the return is wrong but the assignment is ok since the type of b is ?
     testTypes(
         "/** @return number */var a = function b(){ return b };",
@@ -4214,7 +4214,7 @@ public class TypeCheckTest extends CompilerTypeTestCase {
    * inferred and calling this variable is legal.
    */
   public void testBug911118() throws Exception {
-    // verifying the type assigned to anonymous functions assigned variables
+    // verifying the type assigned to function expressions assigned variables
     Scope s = parseAndTypeCheckWithScope("var a = function(){};").scope;
     JSType type = s.getVar("a").getType();
     assertEquals("function (): ?", type.toString());
