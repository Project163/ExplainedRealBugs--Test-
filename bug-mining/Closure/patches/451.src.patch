diff --git a/src/com/google/javascript/jscomp/TypedCodeGenerator.java b/src/com/google/javascript/jscomp/TypedCodeGenerator.java
index 868b0be11..aedc0104c 100644
--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java
+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java
@@ -16,6 +16,7 @@
 
 package com.google.javascript.jscomp;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
@@ -143,9 +144,8 @@ class TypedCodeGenerator extends CodeGenerator {
     for (int i = 0; i < formals.size(); i++) {
       sb.append(" * ");
       appendAnnotation(sb, "param", getParameterJSDocType(formals, i, minArity, maxArity));
-      sb.append(" ")
-          .append(paramNode == null ? "p" + i : paramNode.getString())
-          .append("\n");
+      String parameterName = getParameterJSDocName(paramNode, i);
+      sb.append(" ").append(parameterName).append("\n");
       if (paramNode != null) {
         paramNode = paramNode.getNext();
       }
@@ -192,6 +192,42 @@ class TypedCodeGenerator extends CodeGenerator {
     return sb.toString();
   }
 
+  /**
+   * Return the name of the parameter to be used in JSDoc, generating one for destructuring
+   * parameters.
+   *
+   * @param paramNode child node of a parameter list
+   * @param paramIndex position of child in the list
+   * @return name to use in JSDoc
+   */
+  private String getParameterJSDocName(Node paramNode, int paramIndex) {
+    Node nameNode = null;
+    if (paramNode != null) {
+      checkArgument(paramNode.getParent().isParamList(), paramNode);
+      if (paramNode.isRest()) {
+        // use `restParam` of `...restParam`
+        // restParam might still be a destructuring pattern
+        paramNode = paramNode.getOnlyChild();
+      } else if (paramNode.isDefaultValue()) {
+        // use `defaultParam` of `defaultParam = something`
+        // defaultParam might still be a destructuring pattern
+        paramNode = paramNode.getFirstChild();
+      }
+      if (paramNode.isName()) {
+        nameNode = paramNode;
+      } else {
+        checkState(paramNode.isObjectPattern() || paramNode.isArrayPattern(), paramNode);
+        nameNode = null; // must generate a fake name
+      }
+    }
+    if (nameNode == null) {
+      return "p" + paramIndex;
+    } else {
+      checkState(nameNode.isName(), nameNode);
+      return nameNode.getString();
+    }
+  }
+
   private String formatTypeVar(JSType var) {
     return var.toAnnotationString(Nullability.IMPLICIT);
   }
diff --git a/test/com/google/javascript/jscomp/CodePrinterTest.java b/test/com/google/javascript/jscomp/CodePrinterTest.java
index 7151ca31f..516fe119b 100644
--- a/test/com/google/javascript/jscomp/CodePrinterTest.java
+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java
@@ -17,6 +17,7 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.javascript.jscomp.CompilerTestCase.lines;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
@@ -1343,6 +1344,121 @@ public final class CodePrinterTest extends CodePrinterTestBase {
             "a.Bar = function() {\n};\n"));
   }
 
+  public void testTypeAnnotationClassImplements() {
+    languageMode = LanguageMode.ECMASCRIPT_2015;
+    assertTypeAnnotations(
+        lines(
+            "/** @interface */ class Foo {}", //
+            "/** @implements {Foo} */ class Bar {}"),
+        lines(
+            // TODO(b/111818228): Should print annotations
+            // "/**\n * @interface\n */",
+            "class Foo {\n}",
+            // "/**\n * @implements {Foo}\n */",
+            "class Bar {\n}\n"));
+  }
+
+  public void testTypeAnnotationClassMember() {
+    languageMode = LanguageMode.ECMASCRIPT_2015;
+    assertTypeAnnotations(
+        lines(
+            "class Foo {", //
+            "  /** @return {number} */ method(/** string */ arg) {}",
+            "}"),
+        lines(
+            "class Foo {",
+            // TODO(b/111818228): Should print annotations
+            // "  /**\n * @param {string} arg\n * @return {number}\n */",
+            "  method(arg) {\n  }",
+            "}\n"));
+  }
+
+  public void testRestParameter() {
+    languageMode = LanguageMode.ECMASCRIPT_2015;
+    assertTypeAnnotations(
+        lines(
+            "/** @param {...string} args */", //
+            "function f(...args) {}"),
+        lines(
+            "/**\n * @param {...string} args\n * @return {undefined}\n */",
+            "function f(...args) {\n}\n"));
+  }
+
+  public void testDefaultParameter() {
+    languageMode = LanguageMode.ECMASCRIPT_2015;
+    assertTypeAnnotations(
+        lines(
+            "/** @param {string=} msg */", //
+            "function f(msg = 'hi') {}"),
+        lines(
+            "/**\n * @param {string=} msg\n * @return {undefined}\n */",
+            "function f(msg = \"hi\") {\n}\n"));
+  }
+
+  public void testObjectDestructuringParameter() {
+    languageMode = LanguageMode.ECMASCRIPT_2015;
+    assertTypeAnnotations(
+        lines(
+            "/** @param {{a: number, b: number}} ignoredName */", //
+            "function f({a, b}) {}"),
+        lines(
+            "/**",
+            " * @param {{a: number, b: number}} p0", // old JSDoc name is ignored
+            " * @return {undefined}",
+            " */",
+            "function f({a, b}) {", // whitespace in output must match
+            "}",
+            ""));
+  }
+
+  public void testObjectDestructuringParameterWithDefault() {
+    languageMode = LanguageMode.ECMASCRIPT_2015;
+    assertTypeAnnotations(
+        lines(
+            "/** @param {{a: number, b: number}=} ignoredName */", //
+            "function f({a, b} = {a: 1, b: 2}) {}"),
+        lines(
+            "/**",
+            " * @param {{a: number, b: number}=} p0", // old JSDoc name is ignored
+            " * @return {undefined}",
+            " */",
+            "function f({a, b} = {a:1, b:2}) {", // whitespace in output must match
+            "}",
+            ""));
+  }
+
+  public void testArrayDestructuringParameter() {
+    languageMode = LanguageMode.ECMASCRIPT_2015;
+    assertTypeAnnotations(
+        lines(
+            "/** @param {!Iterable<number>} ignoredName */", //
+            "function f([a, b]) {}"),
+        lines(
+            "/**",
+            " * @param {!Iterable<number>} p0", // old JSDoc name is ignored
+            " * @return {undefined}",
+            " */",
+            "function f([a, b]) {", // whitespace in output must match
+            "}",
+            ""));
+  }
+
+  public void testArrayDestructuringParameterWithDefault() {
+    languageMode = LanguageMode.ECMASCRIPT_2015;
+    assertTypeAnnotations(
+        lines(
+            "/** @param {!Iterable<number>=} ignoredName */", //
+            "function f([a, b] = [1, 2]) {}"),
+        lines(
+            "/**",
+            " * @param {!Iterable<number>=} p0", // old JSDoc name is ignored
+            " * @return {undefined}",
+            " */",
+            "function f([a, b] = [1, 2]) {", // whitespace in output must match
+            "}",
+            ""));
+  }
+
   public void testU2UFunctionTypeAnnotation1() {
     assertTypeAnnotations(
         "/** @type {!Function} */ var x = function() {}",
