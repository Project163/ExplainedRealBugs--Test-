diff --git a/src/com/google/javascript/jscomp/AstValidator.java b/src/com/google/javascript/jscomp/AstValidator.java
index b70371264..182f2b834 100644
--- a/src/com/google/javascript/jscomp/AstValidator.java
+++ b/src/com/google/javascript/jscomp/AstValidator.java
@@ -197,6 +197,7 @@ public final class AstValidator implements CompilerPass {
     switch (n.getType()) {
       // Childless expressions
       case Token.FALSE:
+      case Token.NEW_TARGET:
       case Token.NULL:
       case Token.SUPER:
       case Token.THIS:
diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java
index 6ae97e3e6..cb7d0aaa2 100644
--- a/src/com/google/javascript/jscomp/CodeGenerator.java
+++ b/src/com/google/javascript/jscomp/CodeGenerator.java
@@ -824,6 +824,11 @@ class CodeGenerator {
         add("super");
         break;
 
+      case Token.NEW_TARGET:
+        Preconditions.checkState(childCount == 0);
+        add("new.target");
+        break;
+
       case Token.YIELD:
         add("yield");
         if (n.isYieldFor()) {
diff --git a/src/com/google/javascript/jscomp/Es6ToEs3Converter.java b/src/com/google/javascript/jscomp/Es6ToEs3Converter.java
index 4f2486458..fcaad9245 100644
--- a/src/com/google/javascript/jscomp/Es6ToEs3Converter.java
+++ b/src/com/google/javascript/jscomp/Es6ToEs3Converter.java
@@ -122,6 +122,8 @@ public final class Es6ToEs3Converter implements NodeTraversal.Callback, HotSwapC
           return false;
         }
         break;
+      case Token.NEW_TARGET:
+        cannotConvertYet(n, "new.target");
     }
     return true;
   }
diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java
index abfc33a69..f74e0ed42 100644
--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java
+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java
@@ -98,6 +98,7 @@ import com.google.javascript.jscomp.parsing.parser.trees.MissingPrimaryExpressio
 import com.google.javascript.jscomp.parsing.parser.trees.NamespaceDeclarationTree;
 import com.google.javascript.jscomp.parsing.parser.trees.NamespaceNameTree;
 import com.google.javascript.jscomp.parsing.parser.trees.NewExpressionTree;
+import com.google.javascript.jscomp.parsing.parser.trees.NewTargetExpressionTree;
 import com.google.javascript.jscomp.parsing.parser.trees.NullTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ObjectLiteralExpressionTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ObjectPatternTree;
@@ -2125,6 +2126,11 @@ class IRFactory {
       return newNode(Token.SUPER);
     }
 
+    Node processNewTarget(NewTargetExpressionTree tree) {
+      maybeWarnEs6Feature(tree, Feature.NEW_TARGET);
+      return newNode(Token.NEW_TARGET);
+    }
+
     Node processMemberVariable(MemberVariableTree tree) {
       Node member = newStringNode(Token.MEMBER_VARIABLE_DEF, tree.name.value);
       maybeProcessType(member, tree.declaredType);
@@ -2698,6 +2704,8 @@ class IRFactory {
           return processClassDeclaration(node.asClassDeclaration());
         case SUPER_EXPRESSION:
           return processSuper(node.asSuperExpression());
+        case NEW_TARGET_EXPRESSION:
+          return processNewTarget(node.asNewTargetExpression());
         case YIELD_EXPRESSION:
           return processYield(node.asYieldStatement());
         case FOR_OF_STATEMENT:
diff --git a/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java b/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java
index 05a233de6..281430edf 100644
--- a/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java
+++ b/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java
@@ -92,6 +92,7 @@ public final class FeatureSet implements Serializable {
     // ES6 features that are not yet implemented in browsers
     DEFAULT_PARAMETERS("default parameter", ES6),
     DESTRUCTURING("destructuring", ES6),
+    NEW_TARGET("new.target", ES6),
     REGEXP_FLAG_U("RegExp flag 'u'", ES6),
     REGEXP_FLAG_Y("RegExp flag 'y'", ES6),
 
diff --git a/src/com/google/javascript/jscomp/parsing/parser/Parser.java b/src/com/google/javascript/jscomp/parsing/parser/Parser.java
index 236b584fc..689921177 100644
--- a/src/com/google/javascript/jscomp/parsing/parser/Parser.java
+++ b/src/com/google/javascript/jscomp/parsing/parser/Parser.java
@@ -77,6 +77,7 @@ import com.google.javascript.jscomp.parsing.parser.trees.MissingPrimaryExpressio
 import com.google.javascript.jscomp.parsing.parser.trees.NamespaceDeclarationTree;
 import com.google.javascript.jscomp.parsing.parser.trees.NamespaceNameTree;
 import com.google.javascript.jscomp.parsing.parser.trees.NewExpressionTree;
+import com.google.javascript.jscomp.parsing.parser.trees.NewTargetExpressionTree;
 import com.google.javascript.jscomp.parsing.parser.trees.NullTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ObjectLiteralExpressionTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ObjectPatternTree;
@@ -3069,9 +3070,12 @@ public class Parser {
         || peek(TokenType.TEMPLATE_HEAD);
   }
 
-  // 11.2 New Expression
   private ParseTree parseNewExpression() {
-    if (peek(TokenType.NEW)) {
+    if (!peek(TokenType.NEW)) {
+      return parseMemberExpressionNoNew();
+    } else if (peek(1, TokenType.PERIOD)) {
+      return parseNewDotSomething();
+    } else {
       SourcePosition start = getTreeStartLocation();
       eat(TokenType.NEW);
       ParseTree operand = parseNewExpression();
@@ -3080,11 +3084,19 @@ public class Parser {
         arguments = parseArguments();
       }
       return new NewExpressionTree(getTreeLocation(start), operand, arguments);
-    } else {
-      return parseMemberExpressionNoNew();
     }
   }
 
+  private ParseTree parseNewDotSomething() {
+    // currently only "target" is valid after "new."
+    features = features.require(Feature.NEW_TARGET);
+    SourcePosition start = getTreeStartLocation();
+    eat(TokenType.NEW);
+    eat(TokenType.PERIOD);
+    eatPredefinedString("target");
+    return new NewTargetExpressionTree(getTreeLocation(start));
+  }
+
   private ArgumentListTree parseArguments() {
     // ArgumentList :
     //   AssignmentOrSpreadExpression
diff --git a/src/com/google/javascript/jscomp/parsing/parser/trees/NewTargetExpressionTree.java b/src/com/google/javascript/jscomp/parsing/parser/trees/NewTargetExpressionTree.java
new file mode 100644
index 000000000..0214353c3
--- /dev/null
+++ b/src/com/google/javascript/jscomp/parsing/parser/trees/NewTargetExpressionTree.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2016 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp.parsing.parser.trees;
+
+import com.google.javascript.jscomp.parsing.parser.util.SourceRange;
+
+/**
+ * Represents 'new.target'.
+ */
+public class NewTargetExpressionTree extends ParseTree {
+  public NewTargetExpressionTree(SourceRange location) {
+    super(ParseTreeType.NEW_TARGET_EXPRESSION, location);
+  }
+}
diff --git a/src/com/google/javascript/jscomp/parsing/parser/trees/ParseTree.java b/src/com/google/javascript/jscomp/parsing/parser/trees/ParseTree.java
index 39838a458..c3f1a3d58 100644
--- a/src/com/google/javascript/jscomp/parsing/parser/trees/ParseTree.java
+++ b/src/com/google/javascript/jscomp/parsing/parser/trees/ParseTree.java
@@ -154,6 +154,9 @@ public class ParseTree {
   public IndexSignatureTree asIndexSignature() { return (IndexSignatureTree) this; }
   public CallSignatureTree asCallSignature() { return (CallSignatureTree) this; }
 
+  public NewTargetExpressionTree asNewTargetExpression() {
+    return (NewTargetExpressionTree) this;
+  }
   public boolean isPattern() {
     ParseTree parseTree = this;
     while (parseTree.type == ParseTreeType.PAREN_EXPRESSION) {
diff --git a/src/com/google/javascript/jscomp/parsing/parser/trees/ParseTreeType.java b/src/com/google/javascript/jscomp/parsing/parser/trees/ParseTreeType.java
index 87ba1787e..4cfef2e36 100644
--- a/src/com/google/javascript/jscomp/parsing/parser/trees/ParseTreeType.java
+++ b/src/com/google/javascript/jscomp/parsing/parser/trees/ParseTreeType.java
@@ -116,4 +116,5 @@ public enum ParseTreeType {
   AMBIENT_DECLARATION,
   INDEX_SIGNATURE,
   CALL_SIGNATURE,
+  NEW_TARGET_EXPRESSION,
 }
diff --git a/src/com/google/javascript/rhino/Token.java b/src/com/google/javascript/rhino/Token.java
index 000b329e3..92079239e 100644
--- a/src/com/google/javascript/rhino/Token.java
+++ b/src/com/google/javascript/rhino/Token.java
@@ -53,6 +53,8 @@ public class Token {
 
   /**
    * Token types.
+   *
+   * TODO(bradfordcsmith): Add instructions for assigning new values.
    */
   public static final int
       RETURN = 4,
@@ -188,6 +190,7 @@ public class Token {
       TEMPLATELIT_SUB = 179, // template literal substitution
 
       DEFAULT_VALUE = 180, // Formal parameter or destructuring element with a default value
+      NEW_TARGET = 181, // new.target
 
       // Used by type declaration ASTs
       STRING_TYPE = 200,
@@ -528,6 +531,8 @@ public class Token {
         return "COMPUTED_PROP";
       case DEFAULT_VALUE:
         return "DEFAULT_VALUE";
+      case NEW_TARGET:
+        return "NEW_TARGET";
       case MEMBER_VARIABLE_DEF:
         return "MEMBER_VARIABLE_DEF";
 
diff --git a/test/com/google/javascript/jscomp/AstValidatorTest.java b/test/com/google/javascript/jscomp/AstValidatorTest.java
index 54bd67274..bf08f432a 100644
--- a/test/com/google/javascript/jscomp/AstValidatorTest.java
+++ b/test/com/google/javascript/jscomp/AstValidatorTest.java
@@ -105,6 +105,11 @@ public final class AstValidatorTest extends CompilerTestCase {
     expectInvalid(n, Check.SCRIPT);
   }
 
+  public void testNewTargetIsValidExpression() {
+    Node n = new Node(Token.NEW_TARGET);
+    expectValid(n, Check.EXPRESSION);
+  }
+
   public void testInvalidEmptyStatement() {
     Node n = new Node(Token.EMPTY, new Node(Token.TRUE));
     expectInvalid(n, Check.STATEMENT);
diff --git a/test/com/google/javascript/jscomp/CodePrinterTest.java b/test/com/google/javascript/jscomp/CodePrinterTest.java
index 055dfa752..0faf0d05e 100644
--- a/test/com/google/javascript/jscomp/CodePrinterTest.java
+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java
@@ -2029,6 +2029,12 @@ public final class CodePrinterTest extends CodePrinterTestBase {
     assertPrintSame("class C extends D{member(){super.foo()}}");
   }
 
+  public void testNewTarget() {
+    languageMode = LanguageMode.ECMASCRIPT6;
+    assertPrintSame("function f(){new.target}");
+    assertPrint("function f() {\nnew\n.\ntarget;\n}", "function f(){new.target}");
+  }
+
   public void testGeneratorYield() {
     languageMode = LanguageMode.ECMASCRIPT6;
     assertPrintSame("function*f(){yield 1}");
diff --git a/test/com/google/javascript/jscomp/Es6ToEs3ConverterTest.java b/test/com/google/javascript/jscomp/Es6ToEs3ConverterTest.java
index d621a6e01..6c2629301 100644
--- a/test/com/google/javascript/jscomp/Es6ToEs3ConverterTest.java
+++ b/test/com/google/javascript/jscomp/Es6ToEs3ConverterTest.java
@@ -248,6 +248,10 @@ public final class Es6ToEs3ConverterTest extends CompilerTestCase {
     testError("f(class extends D { f() { super.g() } })", CANNOT_CONVERT);
   }
 
+  public void testNewTarget() {
+    testError("function Foo() { new.target; }", CANNOT_CONVERT_YET);
+  }
+
   public void testClassWithJsDoc() {
     test("class C { }", "/** @constructor @struct */ var C = function() { };");
 
diff --git a/test/com/google/javascript/jscomp/parsing/ParserTest.java b/test/com/google/javascript/jscomp/parsing/ParserTest.java
index fd1a5093d..7dfdb1b99 100644
--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java
@@ -2676,6 +2676,33 @@ public final class ParserTest extends BaseJSTypeTestCase {
         "this language feature is only supported in es6 mode: super");
   }
 
+  public void testNewTarget() {
+    expectedFeatures = FeatureSet.ES6;
+    mode = LanguageMode.ECMASCRIPT6;
+
+    // TODO(bradfordcsmith): new.target in global scope should be a syntax error
+    parse("new.target;");
+
+    parse("function f() { new.target; };");
+
+    mode = LanguageMode.ECMASCRIPT5;
+    parseWarning(
+        "function f() { new.target; }",
+        "this language feature is only supported in es6 mode: new.target");
+
+    mode = LanguageMode.ECMASCRIPT3;
+    parseWarning(
+        "function f() { new.target; }",
+        "this language feature is only supported in es6 mode: new.target");
+  }
+
+  public void testNewDotSomethingInvalid() {
+    expectedFeatures = FeatureSet.ES6;
+    mode = LanguageMode.ECMASCRIPT6;
+
+    parseError("function f(){new.something}", "'target' expected");
+  }
+
   public void testArrow1() {
     expectedFeatures = FeatureSet.ES6_IMPL;
     mode = LanguageMode.ECMASCRIPT6;
