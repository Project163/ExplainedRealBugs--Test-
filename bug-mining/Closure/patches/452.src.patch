diff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java
index cae6270e2..a05c376fb 100644
--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java
+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java
@@ -69,6 +69,7 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.function.Supplier;
 import javax.annotation.Nullable;
 
 /**
@@ -153,11 +154,14 @@ public final class DefaultPassConfig extends PassConfig {
       passes.add(convertEs6TypedToEs6);
     }
 
+    passes.add(gatherModuleMetadataPass);
+
     if (options.getLanguageIn().toFeatureSet().has(FeatureSet.Feature.MODULES)) {
       passes.add(rewriteGoogJsImports);
       switch (options.getEs6ModuleTranspilation()) {
         case COMPILE:
-          TranspilationPasses.addEs6ModulePass(passes, preprocessorSymbolTableFactory);
+          TranspilationPasses.addEs6ModulePass(
+              passes, moduleMetadataMapSupplier, preprocessorSymbolTableFactory);
           break;
         case TO_COMMON_JS_LIKE_MODULES:
           TranspilationPasses.addEs6ModuleToCjsPass(passes);
@@ -267,6 +271,8 @@ public final class DefaultPassConfig extends PassConfig {
       checks.add(convertEs6TypedToEs6);
     }
 
+    checks.add(gatherModuleMetadataPass);
+
     if (options.enables(DiagnosticGroups.LINT_CHECKS)) {
       checks.add(lintChecks);
     }
@@ -283,7 +289,8 @@ public final class DefaultPassConfig extends PassConfig {
 
     if (options.getLanguageIn().toFeatureSet().has(FeatureSet.Feature.MODULES)) {
       checks.add(rewriteGoogJsImports);
-      TranspilationPasses.addEs6ModulePass(checks, preprocessorSymbolTableFactory);
+      TranspilationPasses.addEs6ModulePass(
+          checks, moduleMetadataMapSupplier, preprocessorSymbolTableFactory);
     }
 
     checks.add(checkVariableReferences);
@@ -3451,6 +3458,25 @@ public final class DefaultPassConfig extends PassConfig {
           return new Es6RewriteScriptsToModules(compiler);
         }
 
+        @Override
+        protected FeatureSet featureSet() {
+          return ES_NEXT;
+        }
+      };
+
+  private GatherModuleMetadata gatherModuleMetadata;
+  private final Supplier<ModuleMetadataMap> moduleMetadataMapSupplier =
+      () -> gatherModuleMetadata.get();
+
+  private final PassFactory gatherModuleMetadataPass =
+      new PassFactory(PassNames.GATHER_MODULE_METADATA, /* isOneTimePass= */ true) {
+        @Override
+        protected CompilerPass create(AbstractCompiler compiler) {
+          return gatherModuleMetadata =
+              new GatherModuleMetadata(
+                  compiler, options.processCommonJSModules, options.moduleResolutionMode);
+        }
+
         @Override
         protected FeatureSet featureSet() {
           return ES_NEXT;
diff --git a/src/com/google/javascript/jscomp/Es6RewriteModules.java b/src/com/google/javascript/jscomp/Es6RewriteModules.java
index 112512ad5..99f5fc41e 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteModules.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteModules.java
@@ -16,6 +16,7 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.javascript.jscomp.ClosureCheckModule.MODULE_USES_GOOG_MODULE_GET;
 import static com.google.javascript.jscomp.ClosureRewriteModule.INVALID_GET_CALL_SCOPE;
@@ -30,10 +31,9 @@ import com.google.common.base.Splitter;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Multimap;
-import com.google.javascript.jscomp.ModuleMetadata.Module;
+import com.google.javascript.jscomp.ModuleMetadataMap.ModuleMetadata;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.jscomp.deps.ModuleLoader;
-import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
 import com.google.javascript.jscomp.parsing.parser.FeatureSet.Feature;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.JSDocInfo;
@@ -47,6 +47,7 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.function.Supplier;
 import javax.annotation.Nullable;
 
 /**
@@ -129,7 +130,7 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
 
   private Set<String> typedefs;
 
-  private final ModuleMetadata moduleMetadata;
+  private final ModuleMetadataMap moduleMetadataMap;
 
   /**
    * Creates a new Es6RewriteModules instance which can be used to rewrite ES6 modules to a
@@ -137,12 +138,23 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
    */
   public Es6RewriteModules(
       AbstractCompiler compiler,
-      @Nullable PreprocessorSymbolTable preprocessorSymbolTable,
-      boolean processCommonJsModules,
-      ResolutionMode moduleResolutionMode) {
+      Supplier<ModuleMetadataMap> moduleMetadataMapSupplier,
+      @Nullable PreprocessorSymbolTable preprocessorSymbolTable) {
+    this(compiler, moduleMetadataMapSupplier.get(), preprocessorSymbolTable);
+  }
+
+  /**
+   * Creates a new Es6RewriteModules instance which can be used to rewrite ES6 modules to a
+   * concatenable form.
+   */
+  public Es6RewriteModules(
+      AbstractCompiler compiler,
+      ModuleMetadataMap moduleMetadataMap,
+      @Nullable PreprocessorSymbolTable preprocessorSymbolTable) {
+    checkNotNull(moduleMetadataMap);
     this.compiler = compiler;
+    this.moduleMetadataMap = moduleMetadataMap;
     this.preprocessorSymbolTable = preprocessorSymbolTable;
-    moduleMetadata = new ModuleMetadata(compiler, processCommonJsModules, moduleResolutionMode);
   }
 
   /**
@@ -160,7 +172,6 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
   public void process(Node externs, Node root) {
     checkArgument(externs.isRoot(), externs);
     checkArgument(root.isRoot(), root);
-    moduleMetadata.process(externs, root);
     for (Node file : Iterables.concat(externs.children(), root.children())) {
       checkState(file.isScript(), file);
       hotSwapScript(file, null);
@@ -170,7 +181,6 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
 
   @Override
   public void hotSwapScript(Node scriptNode, Node originalRoot) {
-    moduleMetadata.hotSwapScript(scriptNode);
     if (isEs6ModuleRoot(scriptNode)) {
       processFile(scriptNode);
     } else {
@@ -221,7 +231,7 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
           }
 
           String name = n.getLastChild().getString();
-          Module data = moduleMetadata.getModulesByGoogNamespace().get(name);
+          ModuleMetadata data = moduleMetadataMap.getModulesByGoogNamespace().get(name);
 
           if (data == null || !data.isEs6Module()) {
             return;
@@ -310,7 +320,7 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
       //   import ... from 'goog:my.ns.Object'.
       String namespace = importName.substring("goog:".length());
       moduleName = namespace;
-      Module m = moduleMetadata.getModulesByGoogNamespace().get(namespace);
+      ModuleMetadata m = moduleMetadataMap.getModulesByGoogNamespace().get(namespace);
 
       if (m == null) {
         t.report(importDecl, MISSING_MODULE_OR_PROVIDE, namespace);
@@ -723,7 +733,7 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
       compiler.report(JSError.make(parent.getParent(), LHS_OF_GOOG_REQUIRE_MUST_BE_CONST));
     }
 
-    Module m = moduleMetadata.getModulesByGoogNamespace().get(namespace);
+    ModuleMetadata m = moduleMetadataMap.getModulesByGoogNamespace().get(namespace);
 
     if (m == null) {
       t.report(requireCall, MISSING_MODULE_OR_PROVIDE, namespace);
diff --git a/src/com/google/javascript/jscomp/ModuleMetadata.java b/src/com/google/javascript/jscomp/GatherModuleMetadata.java
similarity index 52%
rename from src/com/google/javascript/jscomp/ModuleMetadata.java
rename to src/com/google/javascript/jscomp/GatherModuleMetadata.java
index 0dcacc106..cf482012c 100644
--- a/src/com/google/javascript/jscomp/ModuleMetadata.java
+++ b/src/com/google/javascript/jscomp/GatherModuleMetadata.java
@@ -20,49 +20,24 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.javascript.jscomp.ClosureCheckModule.DECLARE_LEGACY_NAMESPACE_IN_NON_MODULE;
 
-import com.google.auto.value.AutoValue;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMultiset;
 import com.google.common.collect.LinkedHashMultiset;
+import com.google.javascript.jscomp.ModuleMetadataMap.ModuleMetadata;
+import com.google.javascript.jscomp.ModuleMetadataMap.ModuleType;
 import com.google.javascript.jscomp.NodeTraversal.Callback;
 import com.google.javascript.jscomp.deps.ModuleLoader.ModulePath;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.function.Supplier;
 import javax.annotation.Nullable;
 
 /**
- * Gathers metadata around modules that is useful for checking imports / requires.
- *
- * <p>TODO(johnplaisted): There's an opportunity for reuse here in ClosureRewriteModules, which
- * would involve putting this in some common location. Currently this is only used as a helper class
- * for Es6RewriteModules. CompilerInput already has some (not all) of this information but it is not
- * always populated. It may also be ideal to include CommonJS here too as ES6 modules can import
- * them. That would allow decoupling of how these modules are written; right now Es6RewriteModule
- * only checks this for goog.requires and goog: imports, not for ES6 path imports.
+ * Gathers metadata around modules that is useful for checking imports / requires and creates a
+ * {@link ModuleMetadataMap}.
  */
-public final class ModuleMetadata {
-  /** Various types of Javascript "modules" that can be found in the JS Compiler. */
-  public enum ModuleType {
-    ES6_MODULE("an ES6 module"),
-    GOOG_PROVIDE("a goog.provide'd file"),
-    /** A goog.module that does not declare a legacy namespace. */
-    GOOG_MODULE("a goog.module"),
-    /** A goog.module that declares a legacy namespace with goog.module.declareLegacyNamespace. */
-    LEGACY_GOOG_MODULE("a goog.module"),
-    COMMON_JS("a CommonJS module"),
-    SCRIPT("a script");
-
-    private final String description;
-
-    ModuleType(String description) {
-      this.description = description;
-    }
-  }
-
+public final class GatherModuleMetadata implements CompilerPass, Supplier<ModuleMetadataMap> {
   static final DiagnosticType MIXED_MODULE_TYPE =
       DiagnosticType.error("JSC_MIXED_MODULE_TYPE", "A file cannot be both {0} and {1}.");
 
@@ -106,26 +81,26 @@ public final class ModuleMetadata {
    * Map from module path to module. These modules represent files and thus will contain all goog
    * namespaces that are in the file. These are not the same modules in modulesByGoogNamespace.
    */
-  private final Map<String, Module> modulesByPath = new HashMap<>();
+  private final Map<String, ModuleMetadata> modulesByPath = new HashMap<>();
 
   /**
    * Map from Closure namespace to module. These modules represent just the single namespace and
-   * thus each module has only one goog namespace in its {@link Module#googNamespaces()}. These
-   * are not the same modules in modulesByPath.
+   * thus each module has only one goog namespace in its {@link ModuleMetadata#googNamespaces()}.
+   * These are not the same modules in modulesByPath.
    */
-  private final Map<String, Module> modulesByGoogNamespace = new HashMap<>();
+  private final Map<String, ModuleMetadata> modulesByGoogNamespace = new HashMap<>();
 
   /** Modules by AST node. */
-  private final Map<Node, Module> modulesByNode = new HashMap<>();
+  private final Map<Node, ModuleMetadata> modulesByNode = new HashMap<>();
 
   /** The current module being traversed. */
-  private Module.Builder currentModule;
+  private ModuleMetadataBuilder currentModule;
 
   /**
    * The module currentModule is nested under, if any. Modules are expected to be at most two deep
    * (a script and then a goog.loadModule call).
    */
-  private Module.Builder parentModule;
+  private ModuleMetadataBuilder parentModule;
 
   /** The call to goog.loadModule we are traversing. */
   private Node loadModuleCall;
@@ -134,191 +109,82 @@ public final class ModuleMetadata {
   private final boolean processCommonJsModules;
   private final ResolutionMode moduleResolutionMode;
   private Finder finder;
+  private ModuleMetadataMap metadataMap;
 
-  public ModuleMetadata(AbstractCompiler compiler) {
-    this(compiler, false, ResolutionMode.BROWSER);
-  }
-
-  public ModuleMetadata(
+  public GatherModuleMetadata(
       AbstractCompiler compiler,
       boolean processCommonJsModules,
       ResolutionMode moduleResolutionMode) {
     this.compiler = compiler;
     this.processCommonJsModules = processCommonJsModules;
     this.moduleResolutionMode = moduleResolutionMode;
-    this.finder = new Finder();
   }
 
-  /** Struct containing basic information about a module including its type and goog namespaces. */
-  @AutoValue
-  public abstract static class Module {
-    public abstract ModuleType moduleType();
-
-    public boolean isEs6Module() {
-      return moduleType() == ModuleType.ES6_MODULE;
-    }
-
-    public boolean isGoogModule() {
-      return isNonLegacyGoogModule() || isLegacyGoogModule();
+  private class ModuleMetadataBuilder {
+    private boolean ambiguous;
+    private Node declaresNamespace;
+    private Node declaresLegacyNamespace;
+    private final Node rootNode;
+    final ModuleMetadata.Builder metadataBuilder;
+    LinkedHashMultiset<String> googNamespaces = LinkedHashMultiset.create();
+
+    ModuleMetadataBuilder(Node rootNode, @Nullable ModulePath path) {
+      this.metadataBuilder = ModuleMetadata.builder();
+      this.rootNode = rootNode;
+      metadataBuilder.path(path).moduleType(ModuleType.SCRIPT).usesClosure(false).isTestOnly(false);
     }
 
-    public boolean isNonLegacyGoogModule() {
-      return moduleType() == ModuleType.GOOG_MODULE;
-    }
-
-    public boolean isLegacyGoogModule() {
-      return moduleType() == ModuleType.LEGACY_GOOG_MODULE;
-    }
+    void moduleType(ModuleType type, NodeTraversal t, Node n) {
+      checkNotNull(type);
 
-    public boolean isGoogProvide() {
-      return moduleType() == ModuleType.GOOG_PROVIDE;
-    }
+      if (metadataBuilder.moduleType() == type) {
+        return;
+      }
 
-    public boolean isCommonJs() {
-      return moduleType() == ModuleType.COMMON_JS;
-    }
+      if (metadataBuilder.moduleType() == ModuleType.SCRIPT) {
+        metadataBuilder.moduleType(type);
+        return;
+      }
 
-    public boolean isScript() {
-      return moduleType() == ModuleType.SCRIPT;
+      ambiguous = true;
+      t.report(n, MIXED_MODULE_TYPE, metadataBuilder.moduleType().description, type.description);
     }
 
-    /**
-     * Whether this file uses Closure Library at all. Note that a file could use Closure Library
-     * even without calling goog.provide/module/require - there are some primitives in base.js that
-     * can be used without being required like goog.isArray.
-     */
-    public abstract boolean usesClosure();
-
-    /** Whether goog.setTestOnly was called. */
-    public abstract boolean isTestOnly();
-
-    /**
-     * Closure namespaces that this file is associated with. Created by goog.provide, goog.module,
-     * and goog.module.declareNamespace.
-     */
-    public abstract ImmutableMultiset<String> googNamespaces();
-
-    /** Closure namespaces this file requires. e.g. all arguments to goog.require calls. */
-    public abstract ImmutableMultiset<String> requiredGoogNamespaces();
-
-    /**
-     * Closure namespaces this file has weak dependencies on. e.g. all arguments to goog.requireType
-     * calls.
-     */
-    public abstract ImmutableMultiset<String> requiredTypes();
-
-    /** Raw text of all ES6 import specifiers (includes "export from" as well). */
-    public abstract ImmutableMultiset<String> es6ImportSpecifiers();
-
-    abstract ImmutableList<Module> nestedModules();
-
-    @Nullable
-    public abstract ModulePath path();
-
-    /** @return the global, qualified name to rewrite any references to this module to */
-    public String getGlobalName() {
-      return getGlobalName(null);
+    void recordDeclareNamespace(Node declaresNamespace) {
+      this.declaresNamespace = declaresNamespace;
     }
 
-    /** @return the global, qualified name to rewrite any references to this module to */
-    public String getGlobalName(@Nullable String googNamespace) {
-      checkState(googNamespace == null || googNamespaces().contains(googNamespace));
-      switch (moduleType()) {
-        case GOOG_MODULE:
-          return ClosureRewriteModule.getBinaryModuleNamespace(googNamespace);
-        case GOOG_PROVIDE:
-        case LEGACY_GOOG_MODULE:
-          return googNamespace;
-        case ES6_MODULE:
-        case COMMON_JS:
-          return path().toModuleName();
-        case SCRIPT:
-          // fall through, throw an error
-      }
-      throw new IllegalStateException("Unexpected module type: " + moduleType());
+    void recordDeclareLegacyNamespace(Node declaresLegacyNamespace) {
+      this.declaresLegacyNamespace = declaresLegacyNamespace;
     }
 
-    private static Builder builder(
-        AbstractCompiler compiler, Node rootNode, @Nullable ModulePath path) {
-      Builder builder = new AutoValue_ModuleMetadata_Module.Builder();
-      builder.compiler = compiler;
-      builder.rootNode = rootNode;
-      return builder.path(path).moduleType(ModuleType.SCRIPT).usesClosure(false).isTestOnly(false);
+    boolean isScript() {
+      return metadataBuilder.moduleType() == ModuleType.SCRIPT;
     }
 
-    @AutoValue.Builder
-    abstract static class Builder {
-      private boolean ambiguous;
-      private Node declaresNamespace;
-      private Node declaresLegacyNamespace;
-      private Node rootNode;
-      private AbstractCompiler compiler;
-      LinkedHashMultiset<String> googNamespaces = LinkedHashMultiset.create();
-
-      abstract Module buildInternal();
-      abstract Builder googNamespaces(ImmutableMultiset<String> value);
-      abstract ImmutableMultiset.Builder<String> requiredGoogNamespacesBuilder();
-      abstract ImmutableMultiset.Builder<String> requiredTypesBuilder();
-      abstract ImmutableMultiset.Builder<String> es6ImportSpecifiersBuilder();
-      abstract ImmutableList.Builder<Module> nestedModulesBuilder();
-      abstract Builder path(@Nullable ModulePath value);
-      abstract Builder usesClosure(boolean value);
-      abstract Builder isTestOnly(boolean value);
-
-      abstract ModuleType moduleType();
-      abstract Builder moduleType(ModuleType value);
-      void moduleType(ModuleType type, NodeTraversal t, Node n) {
-        checkNotNull(type);
-
-        if (moduleType() == type) {
-          return;
+    ModuleMetadata build() {
+      metadataBuilder.googNamespacesBuilder().addAll(googNamespaces);
+      if (!ambiguous) {
+        if (declaresNamespace != null && metadataBuilder.moduleType() != ModuleType.ES6_MODULE) {
+          compiler.report(
+              JSError.make(declaresNamespace, DECLARE_MODULE_NAMESPACE_OUTSIDE_ES6_MODULE));
         }
 
-        if (moduleType() == ModuleType.SCRIPT) {
-          moduleType(type);
-          return;
-        }
-
-        ambiguous = true;
-        t.report(n, MIXED_MODULE_TYPE, moduleType().description, type.description);
-      }
-
-      void recordDeclareNamespace(Node declaresNamespace) {
-        this.declaresNamespace = declaresNamespace;
-      }
-
-      void recordDeclareLegacyNamespace(Node declaresLegacyNamespace) {
-        this.declaresLegacyNamespace = declaresLegacyNamespace;
-      }
-
-      boolean isScript() {
-        return moduleType() == ModuleType.SCRIPT;
-      }
-
-      Module build() {
-        googNamespaces(ImmutableMultiset.copyOf(googNamespaces));
-        if (!ambiguous) {
-          if (declaresNamespace != null && moduleType() != ModuleType.ES6_MODULE) {
+        if (declaresLegacyNamespace != null) {
+          if (metadataBuilder.moduleType() == ModuleType.GOOG_MODULE) {
+            metadataBuilder.moduleType(ModuleType.LEGACY_GOOG_MODULE);
+          } else {
             compiler.report(
-                JSError.make(declaresNamespace, DECLARE_MODULE_NAMESPACE_OUTSIDE_ES6_MODULE));
-          }
-
-          if (declaresLegacyNamespace != null) {
-            if (moduleType() == ModuleType.GOOG_MODULE) {
-              moduleType(ModuleType.LEGACY_GOOG_MODULE);
-            } else {
-              compiler.report(
-                  JSError.make(declaresLegacyNamespace, DECLARE_LEGACY_NAMESPACE_IN_NON_MODULE));
-            }
+                JSError.make(declaresLegacyNamespace, DECLARE_LEGACY_NAMESPACE_IN_NON_MODULE));
           }
         }
-
-        return buildInternal();
       }
+
+      return metadataBuilder.build();
     }
   }
 
-  /** Traverses the AST and build a sets of {@link Module}s. */
+  /** Traverses the AST and build a sets of {@link ModuleMetadata}s. */
   private final class Finder implements Callback {
     @Override
     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
@@ -349,12 +215,15 @@ public final class ModuleMetadata {
       if (importOrExport.isImport()
           // export from
           || (importOrExport.hasTwoChildren() && importOrExport.getLastChild().isString())) {
-        currentModule.es6ImportSpecifiersBuilder().add(importOrExport.getLastChild().getString());
+        currentModule
+            .metadataBuilder
+            .es6ImportSpecifiersBuilder()
+            .add(importOrExport.getLastChild().getString());
       }
     }
 
     private void enterModule(Node n, @Nullable ModulePath path) {
-      Module.Builder newModule = Module.builder(compiler, n, path);
+      ModuleMetadataBuilder newModule = new ModuleMetadataBuilder(n, path);
       if (currentModule != null) {
         checkState(parentModule == null, "Expected modules to be nested at most 2 deep.");
         parentModule = currentModule;
@@ -364,7 +233,7 @@ public final class ModuleMetadata {
 
     private void leaveModule() {
       checkNotNull(currentModule);
-      Module module = currentModule.build();
+      ModuleMetadata module = currentModule.build();
       modulesByNode.put(currentModule.rootNode, module);
       if (module.path() != null) {
         modulesByPath.put(module.path().toString(), module);
@@ -373,7 +242,7 @@ public final class ModuleMetadata {
         modulesByGoogNamespace.put(namespace, module);
       }
       if (parentModule != null) {
-        parentModule.nestedModulesBuilder().add(module);
+        parentModule.metadataBuilder.nestedModulesBuilder().add(module);
       }
       currentModule = parentModule;
       parentModule = null;
@@ -430,7 +299,7 @@ public final class ModuleMetadata {
         return;
       }
 
-      currentModule.usesClosure(true);
+      currentModule.metadataBuilder.usesClosure(true);
     }
 
     private void visitGoogCall(NodeTraversal t, Node n) {
@@ -453,11 +322,11 @@ public final class ModuleMetadata {
       }
 
       Var root = t.getScope().getVar("goog");
-      if (root != null && !isFromGoogImport(root)) {
+      if (root != null && root.input == t.getInput() && !isFromGoogImport(root)) {
         return;
       }
 
-      currentModule.usesClosure(true);
+      currentModule.metadataBuilder.usesClosure(true);
 
       if (getprop.matchesQualifiedName(GOOG_PROVIDE)) {
         currentModule.moduleType(ModuleType.GOOG_PROVIDE, t, n);
@@ -490,19 +359,22 @@ public final class ModuleMetadata {
         }
       } else if (getprop.matchesQualifiedName(GOOG_REQUIRE)) {
         if (n.hasTwoChildren() && n.getLastChild().isString()) {
-          currentModule.requiredGoogNamespacesBuilder().add(n.getLastChild().getString());
+          currentModule
+              .metadataBuilder
+              .requiredGoogNamespacesBuilder()
+              .add(n.getLastChild().getString());
         } else {
           t.report(n, ClosureRewriteModule.INVALID_REQUIRE_NAMESPACE);
         }
       } else if (getprop.matchesQualifiedName(GOOG_REQUIRE_TYPE)) {
         if (n.hasTwoChildren() && n.getLastChild().isString()) {
-          currentModule.requiredTypesBuilder().add(n.getLastChild().getString());
+          currentModule.metadataBuilder.requiredTypesBuilder().add(n.getLastChild().getString());
         } else {
           t.report(n, INVALID_REQUIRE_TYPE);
         }
       } else if (getprop.matchesQualifiedName(GOOG_SET_TEST_ONLY)) {
         if (n.hasOneChild() || (n.hasTwoChildren() && n.getLastChild().isString())) {
-          currentModule.isTestOnly(true);
+          currentModule.metadataBuilder.isTestOnly(true);
         } else {
           t.report(n, INVALID_SET_TEST_ONLY);
         }
@@ -513,12 +385,13 @@ public final class ModuleMetadata {
      * Adds the namespaces to the module and checks if the given Closure namespace is a duplicate or
      * not.
      */
-    private void addNamespace(Module.Builder module, String namespace, NodeTraversal t, Node n) {
+    private void addNamespace(
+        ModuleMetadataBuilder module, String namespace, NodeTraversal t, Node n) {
       ModuleType existingType = null;
       if (module.googNamespaces.contains(namespace)) {
-        existingType = module.moduleType();
+        existingType = module.metadataBuilder.moduleType();
       } else {
-        Module existingModule = modulesByGoogNamespace.get(namespace);
+        ModuleMetadata existingModule = modulesByGoogNamespace.get(namespace);
         if (existingModule != null) {
           existingType = existingModule.moduleType();
         }
@@ -543,65 +416,23 @@ public final class ModuleMetadata {
     }
   }
 
+  @Override
   public void process(Node externs, Node root) {
-    finder = new Finder();
-    NodeTraversal.traverse(compiler, externs, finder);
-    NodeTraversal.traverse(compiler, root, finder);
-  }
-
-  private void remove(Module module) {
-    if (module != null) {
-      for (String symbol : module.googNamespaces()) {
-        modulesByGoogNamespace.remove(symbol);
-      }
-      if (module.path() != null) {
-        modulesByPath.remove(module.path().toString());
-      }
-      for (Module nested : module.nestedModules()) {
-        remove(nested);
-      }
+    if (metadataMap != null) {
+      return;
     }
-  }
-
-  public void hotSwapScript(Node scriptRoot) {
-    Module existing =
-        modulesByPath.get(compiler.getInput(scriptRoot.getInputId()).getPath().toString());
-    remove(existing);
-    NodeTraversal.traverse(compiler, scriptRoot, finder);
-  }
 
-  /**
-   * @return map from module path to module. These modules represent files and thus {@link
-   *     Module#googNamespaces()} contains all Closure namespaces in the file. These are not the
-   *     same modules from {@link ModuleMetadata#getModulesByGoogNamespace()}. It is not valid to
-   *     call {@link Module#getGlobalName()} on {@link ModuleType#GOOG_PROVIDE} modules from this
-   *     map that have more than one Closure namespace as it is ambiguous.
-   */
-  public Map<String, Module> getModulesByPath() {
-    return Collections.unmodifiableMap(modulesByPath);
+    finder = new Finder();
+    NodeTraversal.traverse(compiler, root, finder);
+    metadataMap = new ModuleMetadataMap(modulesByPath, modulesByGoogNamespace);
   }
 
   /**
-   * @return map from Closure namespace to module. These modules represent the Closure namespace and
-   *     thus {@link Module#googNamespaces()} will have size 1. As a result, it is valid to call
-   *     {@link Module#getGlobalName()} on these modules. These are not the same modules from {@link
-   *     ModuleMetadata#getModulesByPath()}.
+   * Gets the module metadata map, which is only available after calling {@link #process(Node,
+   * Node)}.
    */
-  public Map<String, Module> getModulesByGoogNamespace() {
-    return Collections.unmodifiableMap(modulesByGoogNamespace);
-  }
-
-  /** @return the {@link Module} that contains the given AST node */
-  @Nullable
-  Module getContainingModule(Node n) {
-    if (finder == null) {
-      return null;
-    }
-    Module m = null;
-    while (m == null && n != null) {
-      m = modulesByNode.get(n);
-      n = n.getParent();
-    }
-    return m;
+  @Override
+  public ModuleMetadataMap get() {
+    return metadataMap;
   }
 }
diff --git a/src/com/google/javascript/jscomp/ModuleMetadataMap.java b/src/com/google/javascript/jscomp/ModuleMetadataMap.java
new file mode 100644
index 000000000..c027a56fe
--- /dev/null
+++ b/src/com/google/javascript/jscomp/ModuleMetadataMap.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright 2018 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import static com.google.common.base.Preconditions.checkState;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableMultiset;
+import com.google.javascript.jscomp.deps.ModuleLoader.ModulePath;
+import java.util.Map;
+import javax.annotation.Nullable;
+
+/**
+ * Contains metadata around modules that is useful for checking imports / requires.
+ *
+ * <p>TODO(johnplaisted): There's an opportunity for reuse here in ClosureRewriteModules, which
+ * would involve putting this in some common location. Currently this is only used as a helper class
+ * for Es6RewriteModules. CompilerInput already has some (not all) of this information but it is not
+ * always populated. It may also be ideal to include CommonJS here too as ES6 modules can import
+ * them. That would allow decoupling of how these modules are written; right now Es6RewriteModule
+ * only checks this for goog.requires and goog: imports, not for ES6 path imports.
+ */
+public final class ModuleMetadataMap {
+  /** Various types of Javascript "modules" that can be found in the JS Compiler. */
+  public enum ModuleType {
+    ES6_MODULE("an ES6 module"),
+    GOOG_PROVIDE("a goog.provide'd file"),
+    /** A goog.module that does not declare a legacy namespace. */
+    GOOG_MODULE("a goog.module"),
+    /** A goog.module that declares a legacy namespace with goog.module.declareLegacyNamespace. */
+    LEGACY_GOOG_MODULE("a goog.module"),
+    COMMON_JS("a CommonJS module"),
+    SCRIPT("a script");
+
+    public final String description;
+
+    ModuleType(String description) {
+      this.description = description;
+    }
+  }
+
+  /**
+   * Map from module path to module. These modules represent files and thus will contain all goog
+   * namespaces that are in the file. These are not the same modules in modulesByGoogNamespace.
+   */
+  private final ImmutableMap<String, ModuleMetadata> modulesByPath;
+
+  /**
+   * Map from Closure namespace to module. These modules represent just the single namespace and
+   * thus each module has only one goog namespace in its {@link ModuleMetadata#googNamespaces()}.
+   * These are not the same modules in modulesByPath.
+   */
+  private final ImmutableMap<String, ModuleMetadata> modulesByGoogNamespace;
+
+  public ModuleMetadataMap(
+      Map<String, ModuleMetadata> modulesByPath,
+      Map<String, ModuleMetadata> modulesByGoogNamespace) {
+    this.modulesByPath = ImmutableMap.copyOf(modulesByPath);
+    this.modulesByGoogNamespace = ImmutableMap.copyOf(modulesByGoogNamespace);
+  }
+
+  /** Struct containing basic information about a module including its type and goog namespaces. */
+  @AutoValue
+  public abstract static class ModuleMetadata {
+    public abstract ModuleType moduleType();
+
+    public boolean isEs6Module() {
+      return moduleType() == ModuleType.ES6_MODULE;
+    }
+
+    public boolean isGoogModule() {
+      return isNonLegacyGoogModule() || isLegacyGoogModule();
+    }
+
+    public boolean isNonLegacyGoogModule() {
+      return moduleType() == ModuleType.GOOG_MODULE;
+    }
+
+    public boolean isLegacyGoogModule() {
+      return moduleType() == ModuleType.LEGACY_GOOG_MODULE;
+    }
+
+    public boolean isGoogProvide() {
+      return moduleType() == ModuleType.GOOG_PROVIDE;
+    }
+
+    public boolean isCommonJs() {
+      return moduleType() == ModuleType.COMMON_JS;
+    }
+
+    public boolean isScript() {
+      return moduleType() == ModuleType.SCRIPT;
+    }
+
+    /**
+     * Whether this file uses Closure Library at all. Note that a file could use Closure Library
+     * even without calling goog.provide/module/require - there are some primitives in base.js that
+     * can be used without being required like goog.isArray.
+     */
+    public abstract boolean usesClosure();
+
+    /** Whether goog.setTestOnly was called. */
+    public abstract boolean isTestOnly();
+
+    /**
+     * Closure namespaces that this file is associated with. Created by goog.provide, goog.module,
+     * and goog.module.declareNamespace.
+     */
+    public abstract ImmutableMultiset<String> googNamespaces();
+
+    /** Closure namespaces this file requires. e.g. all arguments to goog.require calls. */
+    public abstract ImmutableMultiset<String> requiredGoogNamespaces();
+
+    /**
+     * Closure namespaces this file has weak dependencies on. e.g. all arguments to goog.requireType
+     * calls.
+     */
+    public abstract ImmutableMultiset<String> requiredTypes();
+
+    /** Raw text of all ES6 import specifiers (includes "export from" as well). */
+    public abstract ImmutableMultiset<String> es6ImportSpecifiers();
+
+    abstract ImmutableList<ModuleMetadata> nestedModules();
+
+    @Nullable
+    public abstract ModulePath path();
+
+    /** @return the global, qualified name to rewrite any references to this module to */
+    public String getGlobalName() {
+      return getGlobalName(null);
+    }
+
+    /** @return the global, qualified name to rewrite any references to this module to */
+    public String getGlobalName(@Nullable String googNamespace) {
+      checkState(googNamespace == null || googNamespaces().contains(googNamespace));
+      switch (moduleType()) {
+        case GOOG_MODULE:
+          return ClosureRewriteModule.getBinaryModuleNamespace(googNamespace);
+        case GOOG_PROVIDE:
+        case LEGACY_GOOG_MODULE:
+          return googNamespace;
+        case ES6_MODULE:
+        case COMMON_JS:
+          return path().toModuleName();
+        case SCRIPT:
+          // fall through, throw an error
+      }
+      throw new IllegalStateException("Unexpected module type: " + moduleType());
+    }
+
+    public static Builder builder() {
+      return new AutoValue_ModuleMetadataMap_ModuleMetadata.Builder();
+    }
+
+    @AutoValue.Builder
+    abstract static class Builder {
+      abstract ModuleMetadata build();
+
+      abstract ImmutableMultiset.Builder<String> googNamespacesBuilder();
+
+      abstract ImmutableMultiset.Builder<String> requiredGoogNamespacesBuilder();
+
+      abstract ImmutableMultiset.Builder<String> requiredTypesBuilder();
+
+      abstract ImmutableMultiset.Builder<String> es6ImportSpecifiersBuilder();
+
+      abstract ImmutableList.Builder<ModuleMetadata> nestedModulesBuilder();
+
+      abstract Builder path(@Nullable ModulePath value);
+
+      abstract Builder usesClosure(boolean value);
+
+      abstract Builder isTestOnly(boolean value);
+
+      abstract ModuleType moduleType();
+
+      abstract Builder moduleType(ModuleType value);
+    }
+  }
+
+  /**
+   * @return map from module path to module. These modules represent files and thus {@link
+   *     ModuleMetadata#googNamespaces()} contains all Closure namespaces in the file. These are not
+   *     the same modules from {@link ModuleMetadataMap#getModulesByGoogNamespace()}. It is not
+   *     valid to call {@link ModuleMetadata#getGlobalName()} on {@link ModuleType#GOOG_PROVIDE}
+   *     modules from this map that have more than one Closure namespace as it is ambiguous.
+   */
+  public ImmutableMap<String, ModuleMetadata> getModulesByPath() {
+    return modulesByPath;
+  }
+
+  /**
+   * @return map from Closure namespace to module. These modules represent the Closure namespace and
+   *     thus {@link ModuleMetadata#googNamespaces()} will have size 1. As a result, it is valid to
+   *     call {@link ModuleMetadata#getGlobalName()} on these modules. These are not the same
+   *     modules from {@link ModuleMetadataMap#getModulesByPath()}.
+   */
+  public ImmutableMap<String, ModuleMetadata> getModulesByGoogNamespace() {
+    return modulesByGoogNamespace;
+  }
+}
diff --git a/src/com/google/javascript/jscomp/PassNames.java b/src/com/google/javascript/jscomp/PassNames.java
index df8d21228..475d4b5b8 100644
--- a/src/com/google/javascript/jscomp/PassNames.java
+++ b/src/com/google/javascript/jscomp/PassNames.java
@@ -58,6 +58,7 @@ public final class PassNames {
   public static final String EXTRACT_PROTOTYPE_MEMBER_DECLARATIONS =
       "extractPrototypeMemberDeclarations";
   public static final String FLOW_SENSITIVE_INLINE_VARIABLES = "flowSensitiveInlineVariables";
+  public static final String GATHER_MODULE_METADATA = "gatherModuleMetadata";
   public static final String GATHER_RAW_EXPORTS = "gatherRawExports";
   public static final String GENERATE_EXPORTS = "generateExports";
   public static final String INFER_CONSTS = "inferConsts";
diff --git a/src/com/google/javascript/jscomp/TranspilationPasses.java b/src/com/google/javascript/jscomp/TranspilationPasses.java
index e54725888..479c50c15 100644
--- a/src/com/google/javascript/jscomp/TranspilationPasses.java
+++ b/src/com/google/javascript/jscomp/TranspilationPasses.java
@@ -31,6 +31,7 @@ import com.google.javascript.jscomp.parsing.parser.FeatureSet;
 import com.google.javascript.jscomp.parsing.parser.FeatureSet.Feature;
 import com.google.javascript.rhino.Node;
 import java.util.List;
+import java.util.function.Supplier;
 
 /**
  * Provides a single place to manage transpilation passes.
@@ -40,6 +41,7 @@ public class TranspilationPasses {
 
   public static void addEs6ModulePass(
       List<PassFactory> passes,
+      Supplier<ModuleMetadataMap> moduleMetadataMapSupplier,
       final PreprocessorSymbolTable.CachedInstanceFactory preprocessorTableFactory) {
     passes.add(
         new HotSwapPassFactory("es6RewriteModule") {
@@ -47,10 +49,7 @@ public class TranspilationPasses {
           protected HotSwapCompilerPass create(AbstractCompiler compiler) {
             preprocessorTableFactory.maybeInitialize(compiler);
             return new Es6RewriteModules(
-                compiler,
-                preprocessorTableFactory.getInstanceOrNull(),
-                compiler.getOptions().processCommonJSModules,
-                compiler.getOptions().moduleResolutionMode);
+                compiler, moduleMetadataMapSupplier, preprocessorTableFactory.getInstanceOrNull());
           }
 
           @Override
diff --git a/src/com/google/javascript/jscomp/gwt/client/JsfileParser.java b/src/com/google/javascript/jscomp/gwt/client/JsfileParser.java
index 05a4d104a..6fd8384f6 100644
--- a/src/com/google/javascript/jscomp/gwt/client/JsfileParser.java
+++ b/src/com/google/javascript/jscomp/gwt/client/JsfileParser.java
@@ -29,10 +29,11 @@ import com.google.javascript.jscomp.BasicErrorManager;
 import com.google.javascript.jscomp.CheckLevel;
 import com.google.javascript.jscomp.Compiler;
 import com.google.javascript.jscomp.CompilerOptions;
+import com.google.javascript.jscomp.GatherModuleMetadata;
 import com.google.javascript.jscomp.JSError;
-import com.google.javascript.jscomp.ModuleMetadata;
-import com.google.javascript.jscomp.ModuleMetadata.Module;
+import com.google.javascript.jscomp.ModuleMetadataMap.ModuleMetadata;
 import com.google.javascript.jscomp.SourceFile;
+import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
 import com.google.javascript.jscomp.gwt.client.Util.JsArray;
 import com.google.javascript.jscomp.gwt.client.Util.JsObject;
 import com.google.javascript.jscomp.gwt.client.Util.JsRegExp;
@@ -272,10 +273,13 @@ public class JsfileParser {
         parseComment(comment, info);
       }
     }
-    ModuleMetadata moduleMetadata = new ModuleMetadata(compiler);
-    moduleMetadata.hotSwapScript(parsed.ast);
+    GatherModuleMetadata gatherModuleMetadata =
+        new GatherModuleMetadata(
+            compiler, /* processCommonJsModules= */ false, ResolutionMode.BROWSER);
+    gatherModuleMetadata.process(/* externs= */ null, parsed.ast);
     compiler.generateReport();
-    Module module = Iterables.getOnlyElement(moduleMetadata.getModulesByPath().values());
+    ModuleMetadata module =
+        Iterables.getOnlyElement(gatherModuleMetadata.get().getModulesByPath().values());
     if (module.isEs6Module()) {
       info.loadFlags.add(JsArray.of("module", "es6"));
     } else if (module.isGoogModule()) {
diff --git a/test/com/google/javascript/jscomp/CompilerTestCase.java b/test/com/google/javascript/jscomp/CompilerTestCase.java
index 38a425866..27c76e3dd 100644
--- a/test/com/google/javascript/jscomp/CompilerTestCase.java
+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java
@@ -1800,7 +1800,9 @@ public abstract class CompilerTestCase extends TestCase {
   private static void transpileToEs5(AbstractCompiler compiler, Node externsRoot, Node codeRoot) {
     List<PassFactory> factories = new ArrayList<>();
     TranspilationPasses.addEs6ModulePass(
-        factories, new PreprocessorSymbolTable.CachedInstanceFactory());
+        factories,
+        () -> new ModuleMetadataMap(ImmutableMap.of(), ImmutableMap.of()),
+        new PreprocessorSymbolTable.CachedInstanceFactory());
     CompilerOptions options = compiler.getOptions();
     options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT);
     options.setLanguageOut(LanguageMode.ECMASCRIPT5);
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java
index 6effaa383..6588d8c18 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java
@@ -53,11 +53,14 @@ public final class Es6RewriteModulesTest extends CompilerTestCase {
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
-    return new Es6RewriteModules(
-        compiler,
-        /* preprocessorSymbolTable= */ null,
-        /* processCommonJsModules= */ false,
-        ResolutionMode.BROWSER);
+    return (externs, root) -> {
+      GatherModuleMetadata gatherModuleMetadata =
+          new GatherModuleMetadata(
+              compiler, /* processCommonJsModules= */ false, ResolutionMode.BROWSER);
+      gatherModuleMetadata.process(externs, root);
+      new Es6RewriteModules(compiler, gatherModuleMetadata, /* preprocessorSymbolTable= */ null)
+          .process(externs, root);
+    };
   }
 
   @Override
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
index 514b71ffa..bfb137f82 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
@@ -61,11 +61,14 @@ public final class Es6RewriteModulesWithGoogInteropTest extends CompilerTestCase
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
-    return new Es6RewriteModules(
-        compiler,
-        /* preprocessorSymbolTable= */ null,
-        /* processCommonJsModules= */ false,
-        ResolutionMode.BROWSER);
+    return (externs, root) -> {
+      GatherModuleMetadata gatherModuleMetadata =
+          new GatherModuleMetadata(
+              compiler, /* processCommonJsModules= */ false, ResolutionMode.BROWSER);
+      gatherModuleMetadata.process(externs, root);
+      new Es6RewriteModules(compiler, gatherModuleMetadata, /* preprocessorSymbolTable= */ null)
+          .process(externs, root);
+    };
   }
 
   @Override
diff --git a/test/com/google/javascript/jscomp/ModuleMetadataTest.java b/test/com/google/javascript/jscomp/GatherModuleMetadataTest.java
similarity index 64%
rename from test/com/google/javascript/jscomp/ModuleMetadataTest.java
rename to test/com/google/javascript/jscomp/GatherModuleMetadataTest.java
index 3c1d02f95..98b5697af 100644
--- a/test/com/google/javascript/jscomp/ModuleMetadataTest.java
+++ b/test/com/google/javascript/jscomp/GatherModuleMetadataTest.java
@@ -19,13 +19,12 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
-import com.google.javascript.jscomp.ModuleMetadata.Module;
+import com.google.javascript.jscomp.ModuleMetadataMap.ModuleMetadata;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
-import com.google.javascript.rhino.Node;
 
 
-public final class ModuleMetadataTest extends CompilerTestCase {
-  ModuleMetadata metadata;
+public final class GatherModuleMetadataTest extends CompilerTestCase {
+  GatherModuleMetadata gatherer;
 
   @Override
   protected void setUp() throws Exception {
@@ -37,42 +36,67 @@ public final class ModuleMetadataTest extends CompilerTestCase {
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
-    metadata =
-        new ModuleMetadata(compiler, /* processCommonJsModules */ true, ResolutionMode.BROWSER);
-    return (Node externs, Node root) -> metadata.process(externs, root);
+    return gatherer =
+        new GatherModuleMetadata(
+            compiler, /* processCommonJsModules= */ true, ResolutionMode.BROWSER);
+  }
+
+  private ModuleMetadataMap metadataMap() {
+    return gatherer.get();
   }
 
   public void testGoogProvide() {
     testSame("goog.provide('my.provide');");
-    assertThat(metadata.getModulesByGoogNamespace().keySet()).containsExactly("my.provide");
-    assertThat(metadata.getModulesByPath().keySet()).contains("testcode");
-    Module m = metadata.getModulesByGoogNamespace().get("my.provide");
+    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.provide");
+    assertThat(metadataMap().getModulesByPath().keySet()).contains("testcode");
+    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.provide");
+    assertThat(m.googNamespaces()).containsExactly("my.provide");
+    assertThat(m.isGoogProvide()).isTrue();
+  }
+
+  public void testGoogProvideWithGoogDeclaredInOtherFile() {
+    // Closure's base.js declare the global goog.
+    testSame(new String[] {"var goog;", "goog.provide('my.provide');"});
+    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.provide");
+    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.provide");
     assertThat(m.googNamespaces()).containsExactly("my.provide");
     assertThat(m.isGoogProvide()).isTrue();
   }
 
+  public void testSameFileGoogIsIgnored() {
+    testSame("var goog; goog.provide('my.provide');");
+    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).isEmpty();
+    assertThat(metadataMap().getModulesByPath().get("testcode").usesClosure()).isFalse();
+  }
+
+  public void testLocalGoogIsIgnored() {
+    testSame("function bar(goog) { goog.provide('my.provide'); }");
+    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).isEmpty();
+    assertThat(metadataMap().getModulesByPath().get("testcode").usesClosure()).isFalse();
+  }
+
   public void testMultipleGoogProvide() {
     testSame("goog.provide('my.first.provide'); goog.provide('my.second.provide');");
-    assertThat(metadata.getModulesByGoogNamespace().keySet())
+    assertThat(metadataMap().getModulesByGoogNamespace().keySet())
         .containsExactly("my.first.provide", "my.second.provide");
-    assertThat(metadata.getModulesByPath().keySet()).contains("testcode");
-    Module m = metadata.getModulesByGoogNamespace().get("my.first.provide");
+    assertThat(metadataMap().getModulesByPath().keySet()).contains("testcode");
+    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.first.provide");
     assertThat(m.googNamespaces()).containsExactly("my.first.provide", "my.second.provide");
     assertThat(m.isGoogProvide()).isTrue();
 
-    m = metadata.getModulesByGoogNamespace().get("my.second.provide");
+    m = metadataMap().getModulesByGoogNamespace().get("my.second.provide");
     assertThat(m.googNamespaces()).containsExactly("my.first.provide", "my.second.provide");
     assertThat(m.isGoogProvide()).isTrue();
 
-    m = metadata.getModulesByPath().get("testcode");
+    m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.googNamespaces()).containsExactly("my.first.provide", "my.second.provide");
     assertThat(m.isGoogProvide()).isTrue();
   }
 
   public void testGoogModule() {
     testSame("goog.module('my.module');");
-    assertThat(metadata.getModulesByGoogNamespace().keySet()).containsExactly("my.module");
-    Module m = metadata.getModulesByGoogNamespace().get("my.module");
+    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.module");
+    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.module");
     assertThat(m.googNamespaces()).containsExactly("my.module");
     assertThat(m.isGoogProvide()).isFalse();
     assertThat(m.isGoogModule()).isTrue();
@@ -83,8 +107,8 @@ public final class ModuleMetadataTest extends CompilerTestCase {
   public void testGoogModuleWithDefaultExport() {
     // exports = 0; on its own is CommonJS!
     testSame("goog.module('my.module'); exports = 0;");
-    assertThat(metadata.getModulesByGoogNamespace().keySet()).containsExactly("my.module");
-    Module m = metadata.getModulesByGoogNamespace().get("my.module");
+    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.module");
+    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.module");
     assertThat(m.googNamespaces()).containsExactly("my.module");
     assertThat(m.isGoogProvide()).isFalse();
     assertThat(m.isGoogModule()).isTrue();
@@ -94,8 +118,8 @@ public final class ModuleMetadataTest extends CompilerTestCase {
 
   public void testLegacyGoogModule() {
     testSame("goog.module('my.module'); goog.module.declareLegacyNamespace();");
-    assertThat(metadata.getModulesByGoogNamespace().keySet()).containsExactly("my.module");
-    Module m = metadata.getModulesByGoogNamespace().get("my.module");
+    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.module");
+    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.module");
     assertThat(m.googNamespaces()).containsExactly("my.module");
     assertThat(m.isGoogProvide()).isFalse();
     assertThat(m.isGoogModule()).isTrue();
@@ -105,31 +129,31 @@ public final class ModuleMetadataTest extends CompilerTestCase {
 
   public void testLoadModule() {
     testSame("goog.loadModule(function() { goog.module('my.module'); });");
-    assertThat(metadata.getModulesByGoogNamespace().keySet()).containsExactly("my.module");
+    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.module");
 
-    Module m = metadata.getModulesByGoogNamespace().get("my.module");
+    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.module");
     assertThat(m.googNamespaces()).containsExactly("my.module");
     assertThat(m.isNonLegacyGoogModule()).isTrue();
     assertThat(m.path()).isNull();
 
-    m = metadata.getModulesByPath().get("testcode");
+    m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.googNamespaces()).isEmpty();
     assertThat(m.isScript()).isTrue();
   }
 
   public void testEs6Module() {
     testSame("export var x;");
-    assertThat(metadata.getModulesByGoogNamespace().keySet()).isEmpty();
-    assertThat(metadata.getModulesByPath().keySet()).contains("testcode");
-    Module m = metadata.getModulesByPath().get("testcode");
+    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).isEmpty();
+    assertThat(metadataMap().getModulesByPath().keySet()).contains("testcode");
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.googNamespaces()).isEmpty();
     assertThat(m.isEs6Module()).isTrue();
   }
 
   public void testEs6ModuleDeclareNamespace() {
     testSame("export var x; goog.module.declareNamespace('my.module');");
-    assertThat(metadata.getModulesByGoogNamespace().keySet()).containsExactly("my.module");
-    Module m = metadata.getModulesByGoogNamespace().get("my.module");
+    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.module");
+    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.module");
     assertThat(m.googNamespaces()).containsExactly("my.module");
     assertThat(m.isEs6Module()).isTrue();
     assertThat(m.isGoogModule()).isFalse();
@@ -137,8 +161,8 @@ public final class ModuleMetadataTest extends CompilerTestCase {
 
   public void testCommonJsModule() {
     testSame("exports = 0;");
-    assertThat(metadata.getModulesByGoogNamespace()).isEmpty();
-    Module m = metadata.getModulesByPath().get("testcode");
+    assertThat(metadataMap().getModulesByGoogNamespace()).isEmpty();
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.isCommonJs()).isTrue();
   }
 
@@ -212,79 +236,79 @@ public final class ModuleMetadataTest extends CompilerTestCase {
 
   public void testUsesGlobalClosure() {
     testSame("goog.isArray(foo);");
-    Module m = metadata.getModulesByPath().get("testcode");
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.usesClosure()).isTrue();
   }
 
   public void testUsesGlobalClosureNoFunctionCall() {
     testSame("var b = goog.nullFunction;");
-    Module m = metadata.getModulesByPath().get("testcode");
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.usesClosure()).isTrue();
   }
 
   public void testLocalGoogIsNotClosure() {
     testSame("var goog; goog.isArray(foo);");
-    Module m = metadata.getModulesByPath().get("testcode");
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.usesClosure()).isFalse();
   }
 
   public void testImportedGoogIsClosure() {
     testSame("import * as goog from '/goog.js'; goog.isArray(foo);");
-    Module m = metadata.getModulesByPath().get("testcode");
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.usesClosure()).isTrue();
   }
 
   public void testRequireType() {
     testSame("goog.requireType('my.Type');");
-    Module m = metadata.getModulesByPath().get("testcode");
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.requiredTypes()).containsExactly("my.Type");
   }
 
   public void testRequiredClosureNamespaces() {
     testSame("goog.require('my.Type');");
-    Module m = metadata.getModulesByPath().get("testcode");
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.requiredGoogNamespaces()).containsExactly("my.Type");
   }
 
   public void testImport() {
     testSame("import '@spec!';");
-    Module m = metadata.getModulesByPath().get("testcode");
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.es6ImportSpecifiers()).containsExactly("@spec!");
   }
 
   public void testExport() {
     testSame("export { name } from '@spec!';");
-    Module m = metadata.getModulesByPath().get("testcode");
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.es6ImportSpecifiers()).containsExactly("@spec!");
   }
 
   public void testImportOrder() {
     testSame("import 'first'; export { name } from 'second'; import 'third';");
-    Module m = metadata.getModulesByPath().get("testcode");
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.es6ImportSpecifiers()).containsExactly("first", "second", "third");
   }
 
   public void testSetTestOnly() {
     testSame("goog.setTestOnly();");
-    Module m = metadata.getModulesByPath().get("testcode");
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.isTestOnly()).isTrue();
   }
 
   public void testSetTestOnlyWithStringArg() {
     testSame("goog.setTestOnly('string');");
-    Module m = metadata.getModulesByPath().get("testcode");
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.isTestOnly()).isTrue();
   }
 
   public void testSetTestOnlyWithExtraArg() {
-    testError("goog.setTestOnly('string', 'string');", ModuleMetadata.INVALID_SET_TEST_ONLY);
-    Module m = metadata.getModulesByPath().get("testcode");
+    testError("goog.setTestOnly('string', 'string');", GatherModuleMetadata.INVALID_SET_TEST_ONLY);
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.isTestOnly()).isFalse();
   }
 
   public void testSetTestOnlyWithInvalidArg() {
-    testError("goog.setTestOnly(0);", ModuleMetadata.INVALID_SET_TEST_ONLY);
-    Module m = metadata.getModulesByPath().get("testcode");
+    testError("goog.setTestOnly(0);", GatherModuleMetadata.INVALID_SET_TEST_ONLY);
+    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.isTestOnly()).isFalse();
   }
 }
