diff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java
index a05c376fb..cae6270e2 100644
--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java
+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java
@@ -69,7 +69,6 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.function.Supplier;
 import javax.annotation.Nullable;
 
 /**
@@ -154,14 +153,11 @@ public final class DefaultPassConfig extends PassConfig {
       passes.add(convertEs6TypedToEs6);
     }
 
-    passes.add(gatherModuleMetadataPass);
-
     if (options.getLanguageIn().toFeatureSet().has(FeatureSet.Feature.MODULES)) {
       passes.add(rewriteGoogJsImports);
       switch (options.getEs6ModuleTranspilation()) {
         case COMPILE:
-          TranspilationPasses.addEs6ModulePass(
-              passes, moduleMetadataMapSupplier, preprocessorSymbolTableFactory);
+          TranspilationPasses.addEs6ModulePass(passes, preprocessorSymbolTableFactory);
           break;
         case TO_COMMON_JS_LIKE_MODULES:
           TranspilationPasses.addEs6ModuleToCjsPass(passes);
@@ -271,8 +267,6 @@ public final class DefaultPassConfig extends PassConfig {
       checks.add(convertEs6TypedToEs6);
     }
 
-    checks.add(gatherModuleMetadataPass);
-
     if (options.enables(DiagnosticGroups.LINT_CHECKS)) {
       checks.add(lintChecks);
     }
@@ -289,8 +283,7 @@ public final class DefaultPassConfig extends PassConfig {
 
     if (options.getLanguageIn().toFeatureSet().has(FeatureSet.Feature.MODULES)) {
       checks.add(rewriteGoogJsImports);
-      TranspilationPasses.addEs6ModulePass(
-          checks, moduleMetadataMapSupplier, preprocessorSymbolTableFactory);
+      TranspilationPasses.addEs6ModulePass(checks, preprocessorSymbolTableFactory);
     }
 
     checks.add(checkVariableReferences);
@@ -3458,25 +3451,6 @@ public final class DefaultPassConfig extends PassConfig {
           return new Es6RewriteScriptsToModules(compiler);
         }
 
-        @Override
-        protected FeatureSet featureSet() {
-          return ES_NEXT;
-        }
-      };
-
-  private GatherModuleMetadata gatherModuleMetadata;
-  private final Supplier<ModuleMetadataMap> moduleMetadataMapSupplier =
-      () -> gatherModuleMetadata.get();
-
-  private final PassFactory gatherModuleMetadataPass =
-      new PassFactory(PassNames.GATHER_MODULE_METADATA, /* isOneTimePass= */ true) {
-        @Override
-        protected CompilerPass create(AbstractCompiler compiler) {
-          return gatherModuleMetadata =
-              new GatherModuleMetadata(
-                  compiler, options.processCommonJSModules, options.moduleResolutionMode);
-        }
-
         @Override
         protected FeatureSet featureSet() {
           return ES_NEXT;
diff --git a/src/com/google/javascript/jscomp/Es6RewriteModules.java b/src/com/google/javascript/jscomp/Es6RewriteModules.java
index 99f5fc41e..112512ad5 100644
--- a/src/com/google/javascript/jscomp/Es6RewriteModules.java
+++ b/src/com/google/javascript/jscomp/Es6RewriteModules.java
@@ -16,7 +16,6 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.javascript.jscomp.ClosureCheckModule.MODULE_USES_GOOG_MODULE_GET;
 import static com.google.javascript.jscomp.ClosureRewriteModule.INVALID_GET_CALL_SCOPE;
@@ -31,9 +30,10 @@ import com.google.common.base.Splitter;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Multimap;
-import com.google.javascript.jscomp.ModuleMetadataMap.ModuleMetadata;
+import com.google.javascript.jscomp.ModuleMetadata.Module;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.jscomp.deps.ModuleLoader;
+import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
 import com.google.javascript.jscomp.parsing.parser.FeatureSet.Feature;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.JSDocInfo;
@@ -47,7 +47,6 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.function.Supplier;
 import javax.annotation.Nullable;
 
 /**
@@ -130,7 +129,7 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
 
   private Set<String> typedefs;
 
-  private final ModuleMetadataMap moduleMetadataMap;
+  private final ModuleMetadata moduleMetadata;
 
   /**
    * Creates a new Es6RewriteModules instance which can be used to rewrite ES6 modules to a
@@ -138,23 +137,12 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
    */
   public Es6RewriteModules(
       AbstractCompiler compiler,
-      Supplier<ModuleMetadataMap> moduleMetadataMapSupplier,
-      @Nullable PreprocessorSymbolTable preprocessorSymbolTable) {
-    this(compiler, moduleMetadataMapSupplier.get(), preprocessorSymbolTable);
-  }
-
-  /**
-   * Creates a new Es6RewriteModules instance which can be used to rewrite ES6 modules to a
-   * concatenable form.
-   */
-  public Es6RewriteModules(
-      AbstractCompiler compiler,
-      ModuleMetadataMap moduleMetadataMap,
-      @Nullable PreprocessorSymbolTable preprocessorSymbolTable) {
-    checkNotNull(moduleMetadataMap);
+      @Nullable PreprocessorSymbolTable preprocessorSymbolTable,
+      boolean processCommonJsModules,
+      ResolutionMode moduleResolutionMode) {
     this.compiler = compiler;
-    this.moduleMetadataMap = moduleMetadataMap;
     this.preprocessorSymbolTable = preprocessorSymbolTable;
+    moduleMetadata = new ModuleMetadata(compiler, processCommonJsModules, moduleResolutionMode);
   }
 
   /**
@@ -172,6 +160,7 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
   public void process(Node externs, Node root) {
     checkArgument(externs.isRoot(), externs);
     checkArgument(root.isRoot(), root);
+    moduleMetadata.process(externs, root);
     for (Node file : Iterables.concat(externs.children(), root.children())) {
       checkState(file.isScript(), file);
       hotSwapScript(file, null);
@@ -181,6 +170,7 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
 
   @Override
   public void hotSwapScript(Node scriptNode, Node originalRoot) {
+    moduleMetadata.hotSwapScript(scriptNode);
     if (isEs6ModuleRoot(scriptNode)) {
       processFile(scriptNode);
     } else {
@@ -231,7 +221,7 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
           }
 
           String name = n.getLastChild().getString();
-          ModuleMetadata data = moduleMetadataMap.getModulesByGoogNamespace().get(name);
+          Module data = moduleMetadata.getModulesByGoogNamespace().get(name);
 
           if (data == null || !data.isEs6Module()) {
             return;
@@ -320,7 +310,7 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
       //   import ... from 'goog:my.ns.Object'.
       String namespace = importName.substring("goog:".length());
       moduleName = namespace;
-      ModuleMetadata m = moduleMetadataMap.getModulesByGoogNamespace().get(namespace);
+      Module m = moduleMetadata.getModulesByGoogNamespace().get(namespace);
 
       if (m == null) {
         t.report(importDecl, MISSING_MODULE_OR_PROVIDE, namespace);
@@ -733,7 +723,7 @@ public final class Es6RewriteModules extends AbstractPostOrderCallback
       compiler.report(JSError.make(parent.getParent(), LHS_OF_GOOG_REQUIRE_MUST_BE_CONST));
     }
 
-    ModuleMetadata m = moduleMetadataMap.getModulesByGoogNamespace().get(namespace);
+    Module m = moduleMetadata.getModulesByGoogNamespace().get(namespace);
 
     if (m == null) {
       t.report(requireCall, MISSING_MODULE_OR_PROVIDE, namespace);
diff --git a/src/com/google/javascript/jscomp/GatherModuleMetadata.java b/src/com/google/javascript/jscomp/ModuleMetadata.java
similarity index 52%
rename from src/com/google/javascript/jscomp/GatherModuleMetadata.java
rename to src/com/google/javascript/jscomp/ModuleMetadata.java
index cf482012c..0dcacc106 100644
--- a/src/com/google/javascript/jscomp/GatherModuleMetadata.java
+++ b/src/com/google/javascript/jscomp/ModuleMetadata.java
@@ -20,24 +20,49 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.javascript.jscomp.ClosureCheckModule.DECLARE_LEGACY_NAMESPACE_IN_NON_MODULE;
 
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMultiset;
 import com.google.common.collect.LinkedHashMultiset;
-import com.google.javascript.jscomp.ModuleMetadataMap.ModuleMetadata;
-import com.google.javascript.jscomp.ModuleMetadataMap.ModuleType;
 import com.google.javascript.jscomp.NodeTraversal.Callback;
 import com.google.javascript.jscomp.deps.ModuleLoader.ModulePath;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.function.Supplier;
 import javax.annotation.Nullable;
 
 /**
- * Gathers metadata around modules that is useful for checking imports / requires and creates a
- * {@link ModuleMetadataMap}.
+ * Gathers metadata around modules that is useful for checking imports / requires.
+ *
+ * <p>TODO(johnplaisted): There's an opportunity for reuse here in ClosureRewriteModules, which
+ * would involve putting this in some common location. Currently this is only used as a helper class
+ * for Es6RewriteModules. CompilerInput already has some (not all) of this information but it is not
+ * always populated. It may also be ideal to include CommonJS here too as ES6 modules can import
+ * them. That would allow decoupling of how these modules are written; right now Es6RewriteModule
+ * only checks this for goog.requires and goog: imports, not for ES6 path imports.
  */
-public final class GatherModuleMetadata implements CompilerPass, Supplier<ModuleMetadataMap> {
+public final class ModuleMetadata {
+  /** Various types of Javascript "modules" that can be found in the JS Compiler. */
+  public enum ModuleType {
+    ES6_MODULE("an ES6 module"),
+    GOOG_PROVIDE("a goog.provide'd file"),
+    /** A goog.module that does not declare a legacy namespace. */
+    GOOG_MODULE("a goog.module"),
+    /** A goog.module that declares a legacy namespace with goog.module.declareLegacyNamespace. */
+    LEGACY_GOOG_MODULE("a goog.module"),
+    COMMON_JS("a CommonJS module"),
+    SCRIPT("a script");
+
+    private final String description;
+
+    ModuleType(String description) {
+      this.description = description;
+    }
+  }
+
   static final DiagnosticType MIXED_MODULE_TYPE =
       DiagnosticType.error("JSC_MIXED_MODULE_TYPE", "A file cannot be both {0} and {1}.");
 
@@ -81,26 +106,26 @@ public final class GatherModuleMetadata implements CompilerPass, Supplier<Module
    * Map from module path to module. These modules represent files and thus will contain all goog
    * namespaces that are in the file. These are not the same modules in modulesByGoogNamespace.
    */
-  private final Map<String, ModuleMetadata> modulesByPath = new HashMap<>();
+  private final Map<String, Module> modulesByPath = new HashMap<>();
 
   /**
    * Map from Closure namespace to module. These modules represent just the single namespace and
-   * thus each module has only one goog namespace in its {@link ModuleMetadata#googNamespaces()}.
-   * These are not the same modules in modulesByPath.
+   * thus each module has only one goog namespace in its {@link Module#googNamespaces()}. These
+   * are not the same modules in modulesByPath.
    */
-  private final Map<String, ModuleMetadata> modulesByGoogNamespace = new HashMap<>();
+  private final Map<String, Module> modulesByGoogNamespace = new HashMap<>();
 
   /** Modules by AST node. */
-  private final Map<Node, ModuleMetadata> modulesByNode = new HashMap<>();
+  private final Map<Node, Module> modulesByNode = new HashMap<>();
 
   /** The current module being traversed. */
-  private ModuleMetadataBuilder currentModule;
+  private Module.Builder currentModule;
 
   /**
    * The module currentModule is nested under, if any. Modules are expected to be at most two deep
    * (a script and then a goog.loadModule call).
    */
-  private ModuleMetadataBuilder parentModule;
+  private Module.Builder parentModule;
 
   /** The call to goog.loadModule we are traversing. */
   private Node loadModuleCall;
@@ -109,82 +134,191 @@ public final class GatherModuleMetadata implements CompilerPass, Supplier<Module
   private final boolean processCommonJsModules;
   private final ResolutionMode moduleResolutionMode;
   private Finder finder;
-  private ModuleMetadataMap metadataMap;
 
-  public GatherModuleMetadata(
+  public ModuleMetadata(AbstractCompiler compiler) {
+    this(compiler, false, ResolutionMode.BROWSER);
+  }
+
+  public ModuleMetadata(
       AbstractCompiler compiler,
       boolean processCommonJsModules,
       ResolutionMode moduleResolutionMode) {
     this.compiler = compiler;
     this.processCommonJsModules = processCommonJsModules;
     this.moduleResolutionMode = moduleResolutionMode;
+    this.finder = new Finder();
   }
 
-  private class ModuleMetadataBuilder {
-    private boolean ambiguous;
-    private Node declaresNamespace;
-    private Node declaresLegacyNamespace;
-    private final Node rootNode;
-    final ModuleMetadata.Builder metadataBuilder;
-    LinkedHashMultiset<String> googNamespaces = LinkedHashMultiset.create();
-
-    ModuleMetadataBuilder(Node rootNode, @Nullable ModulePath path) {
-      this.metadataBuilder = ModuleMetadata.builder();
-      this.rootNode = rootNode;
-      metadataBuilder.path(path).moduleType(ModuleType.SCRIPT).usesClosure(false).isTestOnly(false);
+  /** Struct containing basic information about a module including its type and goog namespaces. */
+  @AutoValue
+  public abstract static class Module {
+    public abstract ModuleType moduleType();
+
+    public boolean isEs6Module() {
+      return moduleType() == ModuleType.ES6_MODULE;
     }
 
-    void moduleType(ModuleType type, NodeTraversal t, Node n) {
-      checkNotNull(type);
+    public boolean isGoogModule() {
+      return isNonLegacyGoogModule() || isLegacyGoogModule();
+    }
 
-      if (metadataBuilder.moduleType() == type) {
-        return;
-      }
+    public boolean isNonLegacyGoogModule() {
+      return moduleType() == ModuleType.GOOG_MODULE;
+    }
 
-      if (metadataBuilder.moduleType() == ModuleType.SCRIPT) {
-        metadataBuilder.moduleType(type);
-        return;
-      }
+    public boolean isLegacyGoogModule() {
+      return moduleType() == ModuleType.LEGACY_GOOG_MODULE;
+    }
+
+    public boolean isGoogProvide() {
+      return moduleType() == ModuleType.GOOG_PROVIDE;
+    }
+
+    public boolean isCommonJs() {
+      return moduleType() == ModuleType.COMMON_JS;
+    }
 
-      ambiguous = true;
-      t.report(n, MIXED_MODULE_TYPE, metadataBuilder.moduleType().description, type.description);
+    public boolean isScript() {
+      return moduleType() == ModuleType.SCRIPT;
     }
 
-    void recordDeclareNamespace(Node declaresNamespace) {
-      this.declaresNamespace = declaresNamespace;
+    /**
+     * Whether this file uses Closure Library at all. Note that a file could use Closure Library
+     * even without calling goog.provide/module/require - there are some primitives in base.js that
+     * can be used without being required like goog.isArray.
+     */
+    public abstract boolean usesClosure();
+
+    /** Whether goog.setTestOnly was called. */
+    public abstract boolean isTestOnly();
+
+    /**
+     * Closure namespaces that this file is associated with. Created by goog.provide, goog.module,
+     * and goog.module.declareNamespace.
+     */
+    public abstract ImmutableMultiset<String> googNamespaces();
+
+    /** Closure namespaces this file requires. e.g. all arguments to goog.require calls. */
+    public abstract ImmutableMultiset<String> requiredGoogNamespaces();
+
+    /**
+     * Closure namespaces this file has weak dependencies on. e.g. all arguments to goog.requireType
+     * calls.
+     */
+    public abstract ImmutableMultiset<String> requiredTypes();
+
+    /** Raw text of all ES6 import specifiers (includes "export from" as well). */
+    public abstract ImmutableMultiset<String> es6ImportSpecifiers();
+
+    abstract ImmutableList<Module> nestedModules();
+
+    @Nullable
+    public abstract ModulePath path();
+
+    /** @return the global, qualified name to rewrite any references to this module to */
+    public String getGlobalName() {
+      return getGlobalName(null);
     }
 
-    void recordDeclareLegacyNamespace(Node declaresLegacyNamespace) {
-      this.declaresLegacyNamespace = declaresLegacyNamespace;
+    /** @return the global, qualified name to rewrite any references to this module to */
+    public String getGlobalName(@Nullable String googNamespace) {
+      checkState(googNamespace == null || googNamespaces().contains(googNamespace));
+      switch (moduleType()) {
+        case GOOG_MODULE:
+          return ClosureRewriteModule.getBinaryModuleNamespace(googNamespace);
+        case GOOG_PROVIDE:
+        case LEGACY_GOOG_MODULE:
+          return googNamespace;
+        case ES6_MODULE:
+        case COMMON_JS:
+          return path().toModuleName();
+        case SCRIPT:
+          // fall through, throw an error
+      }
+      throw new IllegalStateException("Unexpected module type: " + moduleType());
     }
 
-    boolean isScript() {
-      return metadataBuilder.moduleType() == ModuleType.SCRIPT;
+    private static Builder builder(
+        AbstractCompiler compiler, Node rootNode, @Nullable ModulePath path) {
+      Builder builder = new AutoValue_ModuleMetadata_Module.Builder();
+      builder.compiler = compiler;
+      builder.rootNode = rootNode;
+      return builder.path(path).moduleType(ModuleType.SCRIPT).usesClosure(false).isTestOnly(false);
     }
 
-    ModuleMetadata build() {
-      metadataBuilder.googNamespacesBuilder().addAll(googNamespaces);
-      if (!ambiguous) {
-        if (declaresNamespace != null && metadataBuilder.moduleType() != ModuleType.ES6_MODULE) {
-          compiler.report(
-              JSError.make(declaresNamespace, DECLARE_MODULE_NAMESPACE_OUTSIDE_ES6_MODULE));
+    @AutoValue.Builder
+    abstract static class Builder {
+      private boolean ambiguous;
+      private Node declaresNamespace;
+      private Node declaresLegacyNamespace;
+      private Node rootNode;
+      private AbstractCompiler compiler;
+      LinkedHashMultiset<String> googNamespaces = LinkedHashMultiset.create();
+
+      abstract Module buildInternal();
+      abstract Builder googNamespaces(ImmutableMultiset<String> value);
+      abstract ImmutableMultiset.Builder<String> requiredGoogNamespacesBuilder();
+      abstract ImmutableMultiset.Builder<String> requiredTypesBuilder();
+      abstract ImmutableMultiset.Builder<String> es6ImportSpecifiersBuilder();
+      abstract ImmutableList.Builder<Module> nestedModulesBuilder();
+      abstract Builder path(@Nullable ModulePath value);
+      abstract Builder usesClosure(boolean value);
+      abstract Builder isTestOnly(boolean value);
+
+      abstract ModuleType moduleType();
+      abstract Builder moduleType(ModuleType value);
+      void moduleType(ModuleType type, NodeTraversal t, Node n) {
+        checkNotNull(type);
+
+        if (moduleType() == type) {
+          return;
         }
 
-        if (declaresLegacyNamespace != null) {
-          if (metadataBuilder.moduleType() == ModuleType.GOOG_MODULE) {
-            metadataBuilder.moduleType(ModuleType.LEGACY_GOOG_MODULE);
-          } else {
+        if (moduleType() == ModuleType.SCRIPT) {
+          moduleType(type);
+          return;
+        }
+
+        ambiguous = true;
+        t.report(n, MIXED_MODULE_TYPE, moduleType().description, type.description);
+      }
+
+      void recordDeclareNamespace(Node declaresNamespace) {
+        this.declaresNamespace = declaresNamespace;
+      }
+
+      void recordDeclareLegacyNamespace(Node declaresLegacyNamespace) {
+        this.declaresLegacyNamespace = declaresLegacyNamespace;
+      }
+
+      boolean isScript() {
+        return moduleType() == ModuleType.SCRIPT;
+      }
+
+      Module build() {
+        googNamespaces(ImmutableMultiset.copyOf(googNamespaces));
+        if (!ambiguous) {
+          if (declaresNamespace != null && moduleType() != ModuleType.ES6_MODULE) {
             compiler.report(
-                JSError.make(declaresLegacyNamespace, DECLARE_LEGACY_NAMESPACE_IN_NON_MODULE));
+                JSError.make(declaresNamespace, DECLARE_MODULE_NAMESPACE_OUTSIDE_ES6_MODULE));
+          }
+
+          if (declaresLegacyNamespace != null) {
+            if (moduleType() == ModuleType.GOOG_MODULE) {
+              moduleType(ModuleType.LEGACY_GOOG_MODULE);
+            } else {
+              compiler.report(
+                  JSError.make(declaresLegacyNamespace, DECLARE_LEGACY_NAMESPACE_IN_NON_MODULE));
+            }
           }
         }
-      }
 
-      return metadataBuilder.build();
+        return buildInternal();
+      }
     }
   }
 
-  /** Traverses the AST and build a sets of {@link ModuleMetadata}s. */
+  /** Traverses the AST and build a sets of {@link Module}s. */
   private final class Finder implements Callback {
     @Override
     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
@@ -215,15 +349,12 @@ public final class GatherModuleMetadata implements CompilerPass, Supplier<Module
       if (importOrExport.isImport()
           // export from
           || (importOrExport.hasTwoChildren() && importOrExport.getLastChild().isString())) {
-        currentModule
-            .metadataBuilder
-            .es6ImportSpecifiersBuilder()
-            .add(importOrExport.getLastChild().getString());
+        currentModule.es6ImportSpecifiersBuilder().add(importOrExport.getLastChild().getString());
       }
     }
 
     private void enterModule(Node n, @Nullable ModulePath path) {
-      ModuleMetadataBuilder newModule = new ModuleMetadataBuilder(n, path);
+      Module.Builder newModule = Module.builder(compiler, n, path);
       if (currentModule != null) {
         checkState(parentModule == null, "Expected modules to be nested at most 2 deep.");
         parentModule = currentModule;
@@ -233,7 +364,7 @@ public final class GatherModuleMetadata implements CompilerPass, Supplier<Module
 
     private void leaveModule() {
       checkNotNull(currentModule);
-      ModuleMetadata module = currentModule.build();
+      Module module = currentModule.build();
       modulesByNode.put(currentModule.rootNode, module);
       if (module.path() != null) {
         modulesByPath.put(module.path().toString(), module);
@@ -242,7 +373,7 @@ public final class GatherModuleMetadata implements CompilerPass, Supplier<Module
         modulesByGoogNamespace.put(namespace, module);
       }
       if (parentModule != null) {
-        parentModule.metadataBuilder.nestedModulesBuilder().add(module);
+        parentModule.nestedModulesBuilder().add(module);
       }
       currentModule = parentModule;
       parentModule = null;
@@ -299,7 +430,7 @@ public final class GatherModuleMetadata implements CompilerPass, Supplier<Module
         return;
       }
 
-      currentModule.metadataBuilder.usesClosure(true);
+      currentModule.usesClosure(true);
     }
 
     private void visitGoogCall(NodeTraversal t, Node n) {
@@ -322,11 +453,11 @@ public final class GatherModuleMetadata implements CompilerPass, Supplier<Module
       }
 
       Var root = t.getScope().getVar("goog");
-      if (root != null && root.input == t.getInput() && !isFromGoogImport(root)) {
+      if (root != null && !isFromGoogImport(root)) {
         return;
       }
 
-      currentModule.metadataBuilder.usesClosure(true);
+      currentModule.usesClosure(true);
 
       if (getprop.matchesQualifiedName(GOOG_PROVIDE)) {
         currentModule.moduleType(ModuleType.GOOG_PROVIDE, t, n);
@@ -359,22 +490,19 @@ public final class GatherModuleMetadata implements CompilerPass, Supplier<Module
         }
       } else if (getprop.matchesQualifiedName(GOOG_REQUIRE)) {
         if (n.hasTwoChildren() && n.getLastChild().isString()) {
-          currentModule
-              .metadataBuilder
-              .requiredGoogNamespacesBuilder()
-              .add(n.getLastChild().getString());
+          currentModule.requiredGoogNamespacesBuilder().add(n.getLastChild().getString());
         } else {
           t.report(n, ClosureRewriteModule.INVALID_REQUIRE_NAMESPACE);
         }
       } else if (getprop.matchesQualifiedName(GOOG_REQUIRE_TYPE)) {
         if (n.hasTwoChildren() && n.getLastChild().isString()) {
-          currentModule.metadataBuilder.requiredTypesBuilder().add(n.getLastChild().getString());
+          currentModule.requiredTypesBuilder().add(n.getLastChild().getString());
         } else {
           t.report(n, INVALID_REQUIRE_TYPE);
         }
       } else if (getprop.matchesQualifiedName(GOOG_SET_TEST_ONLY)) {
         if (n.hasOneChild() || (n.hasTwoChildren() && n.getLastChild().isString())) {
-          currentModule.metadataBuilder.isTestOnly(true);
+          currentModule.isTestOnly(true);
         } else {
           t.report(n, INVALID_SET_TEST_ONLY);
         }
@@ -385,13 +513,12 @@ public final class GatherModuleMetadata implements CompilerPass, Supplier<Module
      * Adds the namespaces to the module and checks if the given Closure namespace is a duplicate or
      * not.
      */
-    private void addNamespace(
-        ModuleMetadataBuilder module, String namespace, NodeTraversal t, Node n) {
+    private void addNamespace(Module.Builder module, String namespace, NodeTraversal t, Node n) {
       ModuleType existingType = null;
       if (module.googNamespaces.contains(namespace)) {
-        existingType = module.metadataBuilder.moduleType();
+        existingType = module.moduleType();
       } else {
-        ModuleMetadata existingModule = modulesByGoogNamespace.get(namespace);
+        Module existingModule = modulesByGoogNamespace.get(namespace);
         if (existingModule != null) {
           existingType = existingModule.moduleType();
         }
@@ -416,23 +543,65 @@ public final class GatherModuleMetadata implements CompilerPass, Supplier<Module
     }
   }
 
-  @Override
   public void process(Node externs, Node root) {
-    if (metadataMap != null) {
-      return;
-    }
-
     finder = new Finder();
+    NodeTraversal.traverse(compiler, externs, finder);
     NodeTraversal.traverse(compiler, root, finder);
-    metadataMap = new ModuleMetadataMap(modulesByPath, modulesByGoogNamespace);
+  }
+
+  private void remove(Module module) {
+    if (module != null) {
+      for (String symbol : module.googNamespaces()) {
+        modulesByGoogNamespace.remove(symbol);
+      }
+      if (module.path() != null) {
+        modulesByPath.remove(module.path().toString());
+      }
+      for (Module nested : module.nestedModules()) {
+        remove(nested);
+      }
+    }
+  }
+
+  public void hotSwapScript(Node scriptRoot) {
+    Module existing =
+        modulesByPath.get(compiler.getInput(scriptRoot.getInputId()).getPath().toString());
+    remove(existing);
+    NodeTraversal.traverse(compiler, scriptRoot, finder);
   }
 
   /**
-   * Gets the module metadata map, which is only available after calling {@link #process(Node,
-   * Node)}.
+   * @return map from module path to module. These modules represent files and thus {@link
+   *     Module#googNamespaces()} contains all Closure namespaces in the file. These are not the
+   *     same modules from {@link ModuleMetadata#getModulesByGoogNamespace()}. It is not valid to
+   *     call {@link Module#getGlobalName()} on {@link ModuleType#GOOG_PROVIDE} modules from this
+   *     map that have more than one Closure namespace as it is ambiguous.
    */
-  @Override
-  public ModuleMetadataMap get() {
-    return metadataMap;
+  public Map<String, Module> getModulesByPath() {
+    return Collections.unmodifiableMap(modulesByPath);
+  }
+
+  /**
+   * @return map from Closure namespace to module. These modules represent the Closure namespace and
+   *     thus {@link Module#googNamespaces()} will have size 1. As a result, it is valid to call
+   *     {@link Module#getGlobalName()} on these modules. These are not the same modules from {@link
+   *     ModuleMetadata#getModulesByPath()}.
+   */
+  public Map<String, Module> getModulesByGoogNamespace() {
+    return Collections.unmodifiableMap(modulesByGoogNamespace);
+  }
+
+  /** @return the {@link Module} that contains the given AST node */
+  @Nullable
+  Module getContainingModule(Node n) {
+    if (finder == null) {
+      return null;
+    }
+    Module m = null;
+    while (m == null && n != null) {
+      m = modulesByNode.get(n);
+      n = n.getParent();
+    }
+    return m;
   }
 }
diff --git a/src/com/google/javascript/jscomp/ModuleMetadataMap.java b/src/com/google/javascript/jscomp/ModuleMetadataMap.java
deleted file mode 100644
index c027a56fe..000000000
--- a/src/com/google/javascript/jscomp/ModuleMetadataMap.java
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * Copyright 2018 The Closure Compiler Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.javascript.jscomp;
-
-import static com.google.common.base.Preconditions.checkState;
-
-import com.google.auto.value.AutoValue;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableMultiset;
-import com.google.javascript.jscomp.deps.ModuleLoader.ModulePath;
-import java.util.Map;
-import javax.annotation.Nullable;
-
-/**
- * Contains metadata around modules that is useful for checking imports / requires.
- *
- * <p>TODO(johnplaisted): There's an opportunity for reuse here in ClosureRewriteModules, which
- * would involve putting this in some common location. Currently this is only used as a helper class
- * for Es6RewriteModules. CompilerInput already has some (not all) of this information but it is not
- * always populated. It may also be ideal to include CommonJS here too as ES6 modules can import
- * them. That would allow decoupling of how these modules are written; right now Es6RewriteModule
- * only checks this for goog.requires and goog: imports, not for ES6 path imports.
- */
-public final class ModuleMetadataMap {
-  /** Various types of Javascript "modules" that can be found in the JS Compiler. */
-  public enum ModuleType {
-    ES6_MODULE("an ES6 module"),
-    GOOG_PROVIDE("a goog.provide'd file"),
-    /** A goog.module that does not declare a legacy namespace. */
-    GOOG_MODULE("a goog.module"),
-    /** A goog.module that declares a legacy namespace with goog.module.declareLegacyNamespace. */
-    LEGACY_GOOG_MODULE("a goog.module"),
-    COMMON_JS("a CommonJS module"),
-    SCRIPT("a script");
-
-    public final String description;
-
-    ModuleType(String description) {
-      this.description = description;
-    }
-  }
-
-  /**
-   * Map from module path to module. These modules represent files and thus will contain all goog
-   * namespaces that are in the file. These are not the same modules in modulesByGoogNamespace.
-   */
-  private final ImmutableMap<String, ModuleMetadata> modulesByPath;
-
-  /**
-   * Map from Closure namespace to module. These modules represent just the single namespace and
-   * thus each module has only one goog namespace in its {@link ModuleMetadata#googNamespaces()}.
-   * These are not the same modules in modulesByPath.
-   */
-  private final ImmutableMap<String, ModuleMetadata> modulesByGoogNamespace;
-
-  public ModuleMetadataMap(
-      Map<String, ModuleMetadata> modulesByPath,
-      Map<String, ModuleMetadata> modulesByGoogNamespace) {
-    this.modulesByPath = ImmutableMap.copyOf(modulesByPath);
-    this.modulesByGoogNamespace = ImmutableMap.copyOf(modulesByGoogNamespace);
-  }
-
-  /** Struct containing basic information about a module including its type and goog namespaces. */
-  @AutoValue
-  public abstract static class ModuleMetadata {
-    public abstract ModuleType moduleType();
-
-    public boolean isEs6Module() {
-      return moduleType() == ModuleType.ES6_MODULE;
-    }
-
-    public boolean isGoogModule() {
-      return isNonLegacyGoogModule() || isLegacyGoogModule();
-    }
-
-    public boolean isNonLegacyGoogModule() {
-      return moduleType() == ModuleType.GOOG_MODULE;
-    }
-
-    public boolean isLegacyGoogModule() {
-      return moduleType() == ModuleType.LEGACY_GOOG_MODULE;
-    }
-
-    public boolean isGoogProvide() {
-      return moduleType() == ModuleType.GOOG_PROVIDE;
-    }
-
-    public boolean isCommonJs() {
-      return moduleType() == ModuleType.COMMON_JS;
-    }
-
-    public boolean isScript() {
-      return moduleType() == ModuleType.SCRIPT;
-    }
-
-    /**
-     * Whether this file uses Closure Library at all. Note that a file could use Closure Library
-     * even without calling goog.provide/module/require - there are some primitives in base.js that
-     * can be used without being required like goog.isArray.
-     */
-    public abstract boolean usesClosure();
-
-    /** Whether goog.setTestOnly was called. */
-    public abstract boolean isTestOnly();
-
-    /**
-     * Closure namespaces that this file is associated with. Created by goog.provide, goog.module,
-     * and goog.module.declareNamespace.
-     */
-    public abstract ImmutableMultiset<String> googNamespaces();
-
-    /** Closure namespaces this file requires. e.g. all arguments to goog.require calls. */
-    public abstract ImmutableMultiset<String> requiredGoogNamespaces();
-
-    /**
-     * Closure namespaces this file has weak dependencies on. e.g. all arguments to goog.requireType
-     * calls.
-     */
-    public abstract ImmutableMultiset<String> requiredTypes();
-
-    /** Raw text of all ES6 import specifiers (includes "export from" as well). */
-    public abstract ImmutableMultiset<String> es6ImportSpecifiers();
-
-    abstract ImmutableList<ModuleMetadata> nestedModules();
-
-    @Nullable
-    public abstract ModulePath path();
-
-    /** @return the global, qualified name to rewrite any references to this module to */
-    public String getGlobalName() {
-      return getGlobalName(null);
-    }
-
-    /** @return the global, qualified name to rewrite any references to this module to */
-    public String getGlobalName(@Nullable String googNamespace) {
-      checkState(googNamespace == null || googNamespaces().contains(googNamespace));
-      switch (moduleType()) {
-        case GOOG_MODULE:
-          return ClosureRewriteModule.getBinaryModuleNamespace(googNamespace);
-        case GOOG_PROVIDE:
-        case LEGACY_GOOG_MODULE:
-          return googNamespace;
-        case ES6_MODULE:
-        case COMMON_JS:
-          return path().toModuleName();
-        case SCRIPT:
-          // fall through, throw an error
-      }
-      throw new IllegalStateException("Unexpected module type: " + moduleType());
-    }
-
-    public static Builder builder() {
-      return new AutoValue_ModuleMetadataMap_ModuleMetadata.Builder();
-    }
-
-    @AutoValue.Builder
-    abstract static class Builder {
-      abstract ModuleMetadata build();
-
-      abstract ImmutableMultiset.Builder<String> googNamespacesBuilder();
-
-      abstract ImmutableMultiset.Builder<String> requiredGoogNamespacesBuilder();
-
-      abstract ImmutableMultiset.Builder<String> requiredTypesBuilder();
-
-      abstract ImmutableMultiset.Builder<String> es6ImportSpecifiersBuilder();
-
-      abstract ImmutableList.Builder<ModuleMetadata> nestedModulesBuilder();
-
-      abstract Builder path(@Nullable ModulePath value);
-
-      abstract Builder usesClosure(boolean value);
-
-      abstract Builder isTestOnly(boolean value);
-
-      abstract ModuleType moduleType();
-
-      abstract Builder moduleType(ModuleType value);
-    }
-  }
-
-  /**
-   * @return map from module path to module. These modules represent files and thus {@link
-   *     ModuleMetadata#googNamespaces()} contains all Closure namespaces in the file. These are not
-   *     the same modules from {@link ModuleMetadataMap#getModulesByGoogNamespace()}. It is not
-   *     valid to call {@link ModuleMetadata#getGlobalName()} on {@link ModuleType#GOOG_PROVIDE}
-   *     modules from this map that have more than one Closure namespace as it is ambiguous.
-   */
-  public ImmutableMap<String, ModuleMetadata> getModulesByPath() {
-    return modulesByPath;
-  }
-
-  /**
-   * @return map from Closure namespace to module. These modules represent the Closure namespace and
-   *     thus {@link ModuleMetadata#googNamespaces()} will have size 1. As a result, it is valid to
-   *     call {@link ModuleMetadata#getGlobalName()} on these modules. These are not the same
-   *     modules from {@link ModuleMetadataMap#getModulesByPath()}.
-   */
-  public ImmutableMap<String, ModuleMetadata> getModulesByGoogNamespace() {
-    return modulesByGoogNamespace;
-  }
-}
diff --git a/src/com/google/javascript/jscomp/PassNames.java b/src/com/google/javascript/jscomp/PassNames.java
index 475d4b5b8..df8d21228 100644
--- a/src/com/google/javascript/jscomp/PassNames.java
+++ b/src/com/google/javascript/jscomp/PassNames.java
@@ -58,7 +58,6 @@ public final class PassNames {
   public static final String EXTRACT_PROTOTYPE_MEMBER_DECLARATIONS =
       "extractPrototypeMemberDeclarations";
   public static final String FLOW_SENSITIVE_INLINE_VARIABLES = "flowSensitiveInlineVariables";
-  public static final String GATHER_MODULE_METADATA = "gatherModuleMetadata";
   public static final String GATHER_RAW_EXPORTS = "gatherRawExports";
   public static final String GENERATE_EXPORTS = "generateExports";
   public static final String INFER_CONSTS = "inferConsts";
diff --git a/src/com/google/javascript/jscomp/TranspilationPasses.java b/src/com/google/javascript/jscomp/TranspilationPasses.java
index 479c50c15..e54725888 100644
--- a/src/com/google/javascript/jscomp/TranspilationPasses.java
+++ b/src/com/google/javascript/jscomp/TranspilationPasses.java
@@ -31,7 +31,6 @@ import com.google.javascript.jscomp.parsing.parser.FeatureSet;
 import com.google.javascript.jscomp.parsing.parser.FeatureSet.Feature;
 import com.google.javascript.rhino.Node;
 import java.util.List;
-import java.util.function.Supplier;
 
 /**
  * Provides a single place to manage transpilation passes.
@@ -41,7 +40,6 @@ public class TranspilationPasses {
 
   public static void addEs6ModulePass(
       List<PassFactory> passes,
-      Supplier<ModuleMetadataMap> moduleMetadataMapSupplier,
       final PreprocessorSymbolTable.CachedInstanceFactory preprocessorTableFactory) {
     passes.add(
         new HotSwapPassFactory("es6RewriteModule") {
@@ -49,7 +47,10 @@ public class TranspilationPasses {
           protected HotSwapCompilerPass create(AbstractCompiler compiler) {
             preprocessorTableFactory.maybeInitialize(compiler);
             return new Es6RewriteModules(
-                compiler, moduleMetadataMapSupplier, preprocessorTableFactory.getInstanceOrNull());
+                compiler,
+                preprocessorTableFactory.getInstanceOrNull(),
+                compiler.getOptions().processCommonJSModules,
+                compiler.getOptions().moduleResolutionMode);
           }
 
           @Override
diff --git a/src/com/google/javascript/jscomp/gwt/client/JsfileParser.java b/src/com/google/javascript/jscomp/gwt/client/JsfileParser.java
index 6fd8384f6..05a4d104a 100644
--- a/src/com/google/javascript/jscomp/gwt/client/JsfileParser.java
+++ b/src/com/google/javascript/jscomp/gwt/client/JsfileParser.java
@@ -29,11 +29,10 @@ import com.google.javascript.jscomp.BasicErrorManager;
 import com.google.javascript.jscomp.CheckLevel;
 import com.google.javascript.jscomp.Compiler;
 import com.google.javascript.jscomp.CompilerOptions;
-import com.google.javascript.jscomp.GatherModuleMetadata;
 import com.google.javascript.jscomp.JSError;
-import com.google.javascript.jscomp.ModuleMetadataMap.ModuleMetadata;
+import com.google.javascript.jscomp.ModuleMetadata;
+import com.google.javascript.jscomp.ModuleMetadata.Module;
 import com.google.javascript.jscomp.SourceFile;
-import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
 import com.google.javascript.jscomp.gwt.client.Util.JsArray;
 import com.google.javascript.jscomp.gwt.client.Util.JsObject;
 import com.google.javascript.jscomp.gwt.client.Util.JsRegExp;
@@ -273,13 +272,10 @@ public class JsfileParser {
         parseComment(comment, info);
       }
     }
-    GatherModuleMetadata gatherModuleMetadata =
-        new GatherModuleMetadata(
-            compiler, /* processCommonJsModules= */ false, ResolutionMode.BROWSER);
-    gatherModuleMetadata.process(/* externs= */ null, parsed.ast);
+    ModuleMetadata moduleMetadata = new ModuleMetadata(compiler);
+    moduleMetadata.hotSwapScript(parsed.ast);
     compiler.generateReport();
-    ModuleMetadata module =
-        Iterables.getOnlyElement(gatherModuleMetadata.get().getModulesByPath().values());
+    Module module = Iterables.getOnlyElement(moduleMetadata.getModulesByPath().values());
     if (module.isEs6Module()) {
       info.loadFlags.add(JsArray.of("module", "es6"));
     } else if (module.isGoogModule()) {
diff --git a/test/com/google/javascript/jscomp/CompilerTestCase.java b/test/com/google/javascript/jscomp/CompilerTestCase.java
index 27c76e3dd..38a425866 100644
--- a/test/com/google/javascript/jscomp/CompilerTestCase.java
+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java
@@ -1800,9 +1800,7 @@ public abstract class CompilerTestCase extends TestCase {
   private static void transpileToEs5(AbstractCompiler compiler, Node externsRoot, Node codeRoot) {
     List<PassFactory> factories = new ArrayList<>();
     TranspilationPasses.addEs6ModulePass(
-        factories,
-        () -> new ModuleMetadataMap(ImmutableMap.of(), ImmutableMap.of()),
-        new PreprocessorSymbolTable.CachedInstanceFactory());
+        factories, new PreprocessorSymbolTable.CachedInstanceFactory());
     CompilerOptions options = compiler.getOptions();
     options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT);
     options.setLanguageOut(LanguageMode.ECMASCRIPT5);
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java
index 6588d8c18..6effaa383 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java
@@ -53,14 +53,11 @@ public final class Es6RewriteModulesTest extends CompilerTestCase {
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
-    return (externs, root) -> {
-      GatherModuleMetadata gatherModuleMetadata =
-          new GatherModuleMetadata(
-              compiler, /* processCommonJsModules= */ false, ResolutionMode.BROWSER);
-      gatherModuleMetadata.process(externs, root);
-      new Es6RewriteModules(compiler, gatherModuleMetadata, /* preprocessorSymbolTable= */ null)
-          .process(externs, root);
-    };
+    return new Es6RewriteModules(
+        compiler,
+        /* preprocessorSymbolTable= */ null,
+        /* processCommonJsModules= */ false,
+        ResolutionMode.BROWSER);
   }
 
   @Override
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
index bfb137f82..514b71ffa 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
@@ -61,14 +61,11 @@ public final class Es6RewriteModulesWithGoogInteropTest extends CompilerTestCase
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
-    return (externs, root) -> {
-      GatherModuleMetadata gatherModuleMetadata =
-          new GatherModuleMetadata(
-              compiler, /* processCommonJsModules= */ false, ResolutionMode.BROWSER);
-      gatherModuleMetadata.process(externs, root);
-      new Es6RewriteModules(compiler, gatherModuleMetadata, /* preprocessorSymbolTable= */ null)
-          .process(externs, root);
-    };
+    return new Es6RewriteModules(
+        compiler,
+        /* preprocessorSymbolTable= */ null,
+        /* processCommonJsModules= */ false,
+        ResolutionMode.BROWSER);
   }
 
   @Override
diff --git a/test/com/google/javascript/jscomp/GatherModuleMetadataTest.java b/test/com/google/javascript/jscomp/ModuleMetadataTest.java
similarity index 64%
rename from test/com/google/javascript/jscomp/GatherModuleMetadataTest.java
rename to test/com/google/javascript/jscomp/ModuleMetadataTest.java
index 98b5697af..3c1d02f95 100644
--- a/test/com/google/javascript/jscomp/GatherModuleMetadataTest.java
+++ b/test/com/google/javascript/jscomp/ModuleMetadataTest.java
@@ -19,12 +19,13 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
-import com.google.javascript.jscomp.ModuleMetadataMap.ModuleMetadata;
+import com.google.javascript.jscomp.ModuleMetadata.Module;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
+import com.google.javascript.rhino.Node;
 
 
-public final class GatherModuleMetadataTest extends CompilerTestCase {
-  GatherModuleMetadata gatherer;
+public final class ModuleMetadataTest extends CompilerTestCase {
+  ModuleMetadata metadata;
 
   @Override
   protected void setUp() throws Exception {
@@ -36,67 +37,42 @@ public final class GatherModuleMetadataTest extends CompilerTestCase {
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
-    return gatherer =
-        new GatherModuleMetadata(
-            compiler, /* processCommonJsModules= */ true, ResolutionMode.BROWSER);
-  }
-
-  private ModuleMetadataMap metadataMap() {
-    return gatherer.get();
+    metadata =
+        new ModuleMetadata(compiler, /* processCommonJsModules */ true, ResolutionMode.BROWSER);
+    return (Node externs, Node root) -> metadata.process(externs, root);
   }
 
   public void testGoogProvide() {
     testSame("goog.provide('my.provide');");
-    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.provide");
-    assertThat(metadataMap().getModulesByPath().keySet()).contains("testcode");
-    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.provide");
-    assertThat(m.googNamespaces()).containsExactly("my.provide");
-    assertThat(m.isGoogProvide()).isTrue();
-  }
-
-  public void testGoogProvideWithGoogDeclaredInOtherFile() {
-    // Closure's base.js declare the global goog.
-    testSame(new String[] {"var goog;", "goog.provide('my.provide');"});
-    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.provide");
-    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.provide");
+    assertThat(metadata.getModulesByGoogNamespace().keySet()).containsExactly("my.provide");
+    assertThat(metadata.getModulesByPath().keySet()).contains("testcode");
+    Module m = metadata.getModulesByGoogNamespace().get("my.provide");
     assertThat(m.googNamespaces()).containsExactly("my.provide");
     assertThat(m.isGoogProvide()).isTrue();
   }
 
-  public void testSameFileGoogIsIgnored() {
-    testSame("var goog; goog.provide('my.provide');");
-    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).isEmpty();
-    assertThat(metadataMap().getModulesByPath().get("testcode").usesClosure()).isFalse();
-  }
-
-  public void testLocalGoogIsIgnored() {
-    testSame("function bar(goog) { goog.provide('my.provide'); }");
-    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).isEmpty();
-    assertThat(metadataMap().getModulesByPath().get("testcode").usesClosure()).isFalse();
-  }
-
   public void testMultipleGoogProvide() {
     testSame("goog.provide('my.first.provide'); goog.provide('my.second.provide');");
-    assertThat(metadataMap().getModulesByGoogNamespace().keySet())
+    assertThat(metadata.getModulesByGoogNamespace().keySet())
         .containsExactly("my.first.provide", "my.second.provide");
-    assertThat(metadataMap().getModulesByPath().keySet()).contains("testcode");
-    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.first.provide");
+    assertThat(metadata.getModulesByPath().keySet()).contains("testcode");
+    Module m = metadata.getModulesByGoogNamespace().get("my.first.provide");
     assertThat(m.googNamespaces()).containsExactly("my.first.provide", "my.second.provide");
     assertThat(m.isGoogProvide()).isTrue();
 
-    m = metadataMap().getModulesByGoogNamespace().get("my.second.provide");
+    m = metadata.getModulesByGoogNamespace().get("my.second.provide");
     assertThat(m.googNamespaces()).containsExactly("my.first.provide", "my.second.provide");
     assertThat(m.isGoogProvide()).isTrue();
 
-    m = metadataMap().getModulesByPath().get("testcode");
+    m = metadata.getModulesByPath().get("testcode");
     assertThat(m.googNamespaces()).containsExactly("my.first.provide", "my.second.provide");
     assertThat(m.isGoogProvide()).isTrue();
   }
 
   public void testGoogModule() {
     testSame("goog.module('my.module');");
-    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.module");
-    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.module");
+    assertThat(metadata.getModulesByGoogNamespace().keySet()).containsExactly("my.module");
+    Module m = metadata.getModulesByGoogNamespace().get("my.module");
     assertThat(m.googNamespaces()).containsExactly("my.module");
     assertThat(m.isGoogProvide()).isFalse();
     assertThat(m.isGoogModule()).isTrue();
@@ -107,8 +83,8 @@ public final class GatherModuleMetadataTest extends CompilerTestCase {
   public void testGoogModuleWithDefaultExport() {
     // exports = 0; on its own is CommonJS!
     testSame("goog.module('my.module'); exports = 0;");
-    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.module");
-    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.module");
+    assertThat(metadata.getModulesByGoogNamespace().keySet()).containsExactly("my.module");
+    Module m = metadata.getModulesByGoogNamespace().get("my.module");
     assertThat(m.googNamespaces()).containsExactly("my.module");
     assertThat(m.isGoogProvide()).isFalse();
     assertThat(m.isGoogModule()).isTrue();
@@ -118,8 +94,8 @@ public final class GatherModuleMetadataTest extends CompilerTestCase {
 
   public void testLegacyGoogModule() {
     testSame("goog.module('my.module'); goog.module.declareLegacyNamespace();");
-    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.module");
-    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.module");
+    assertThat(metadata.getModulesByGoogNamespace().keySet()).containsExactly("my.module");
+    Module m = metadata.getModulesByGoogNamespace().get("my.module");
     assertThat(m.googNamespaces()).containsExactly("my.module");
     assertThat(m.isGoogProvide()).isFalse();
     assertThat(m.isGoogModule()).isTrue();
@@ -129,31 +105,31 @@ public final class GatherModuleMetadataTest extends CompilerTestCase {
 
   public void testLoadModule() {
     testSame("goog.loadModule(function() { goog.module('my.module'); });");
-    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.module");
+    assertThat(metadata.getModulesByGoogNamespace().keySet()).containsExactly("my.module");
 
-    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.module");
+    Module m = metadata.getModulesByGoogNamespace().get("my.module");
     assertThat(m.googNamespaces()).containsExactly("my.module");
     assertThat(m.isNonLegacyGoogModule()).isTrue();
     assertThat(m.path()).isNull();
 
-    m = metadataMap().getModulesByPath().get("testcode");
+    m = metadata.getModulesByPath().get("testcode");
     assertThat(m.googNamespaces()).isEmpty();
     assertThat(m.isScript()).isTrue();
   }
 
   public void testEs6Module() {
     testSame("export var x;");
-    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).isEmpty();
-    assertThat(metadataMap().getModulesByPath().keySet()).contains("testcode");
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    assertThat(metadata.getModulesByGoogNamespace().keySet()).isEmpty();
+    assertThat(metadata.getModulesByPath().keySet()).contains("testcode");
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.googNamespaces()).isEmpty();
     assertThat(m.isEs6Module()).isTrue();
   }
 
   public void testEs6ModuleDeclareNamespace() {
     testSame("export var x; goog.module.declareNamespace('my.module');");
-    assertThat(metadataMap().getModulesByGoogNamespace().keySet()).containsExactly("my.module");
-    ModuleMetadata m = metadataMap().getModulesByGoogNamespace().get("my.module");
+    assertThat(metadata.getModulesByGoogNamespace().keySet()).containsExactly("my.module");
+    Module m = metadata.getModulesByGoogNamespace().get("my.module");
     assertThat(m.googNamespaces()).containsExactly("my.module");
     assertThat(m.isEs6Module()).isTrue();
     assertThat(m.isGoogModule()).isFalse();
@@ -161,8 +137,8 @@ public final class GatherModuleMetadataTest extends CompilerTestCase {
 
   public void testCommonJsModule() {
     testSame("exports = 0;");
-    assertThat(metadataMap().getModulesByGoogNamespace()).isEmpty();
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    assertThat(metadata.getModulesByGoogNamespace()).isEmpty();
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.isCommonJs()).isTrue();
   }
 
@@ -236,79 +212,79 @@ public final class GatherModuleMetadataTest extends CompilerTestCase {
 
   public void testUsesGlobalClosure() {
     testSame("goog.isArray(foo);");
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.usesClosure()).isTrue();
   }
 
   public void testUsesGlobalClosureNoFunctionCall() {
     testSame("var b = goog.nullFunction;");
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.usesClosure()).isTrue();
   }
 
   public void testLocalGoogIsNotClosure() {
     testSame("var goog; goog.isArray(foo);");
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.usesClosure()).isFalse();
   }
 
   public void testImportedGoogIsClosure() {
     testSame("import * as goog from '/goog.js'; goog.isArray(foo);");
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.usesClosure()).isTrue();
   }
 
   public void testRequireType() {
     testSame("goog.requireType('my.Type');");
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.requiredTypes()).containsExactly("my.Type");
   }
 
   public void testRequiredClosureNamespaces() {
     testSame("goog.require('my.Type');");
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.requiredGoogNamespaces()).containsExactly("my.Type");
   }
 
   public void testImport() {
     testSame("import '@spec!';");
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.es6ImportSpecifiers()).containsExactly("@spec!");
   }
 
   public void testExport() {
     testSame("export { name } from '@spec!';");
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.es6ImportSpecifiers()).containsExactly("@spec!");
   }
 
   public void testImportOrder() {
     testSame("import 'first'; export { name } from 'second'; import 'third';");
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.es6ImportSpecifiers()).containsExactly("first", "second", "third");
   }
 
   public void testSetTestOnly() {
     testSame("goog.setTestOnly();");
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.isTestOnly()).isTrue();
   }
 
   public void testSetTestOnlyWithStringArg() {
     testSame("goog.setTestOnly('string');");
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.isTestOnly()).isTrue();
   }
 
   public void testSetTestOnlyWithExtraArg() {
-    testError("goog.setTestOnly('string', 'string');", GatherModuleMetadata.INVALID_SET_TEST_ONLY);
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    testError("goog.setTestOnly('string', 'string');", ModuleMetadata.INVALID_SET_TEST_ONLY);
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.isTestOnly()).isFalse();
   }
 
   public void testSetTestOnlyWithInvalidArg() {
-    testError("goog.setTestOnly(0);", GatherModuleMetadata.INVALID_SET_TEST_ONLY);
-    ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
+    testError("goog.setTestOnly(0);", ModuleMetadata.INVALID_SET_TEST_ONLY);
+    Module m = metadata.getModulesByPath().get("testcode");
     assertThat(m.isTestOnly()).isFalse();
   }
 }
