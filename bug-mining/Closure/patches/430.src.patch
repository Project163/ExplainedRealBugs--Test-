diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java
index 38ae91f49..80c14e99e 100644
--- a/src/com/google/javascript/jscomp/NameAnalyzer.java
+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java
@@ -313,11 +313,13 @@ final class NameAnalyzer implements CompilerPass {
 
     @Override
     public void remove() {
-      // Setters have VAR, FUNCTION, or ASSIGN parent nodes. CALL parent
+      // Setters have VAR, LET, CONST, FUNCTION, or ASSIGN parent nodes. CALL parent
       // nodes are global refs, and are handled later in this function.
       Node containingNode = parent.getParent();
       switch (parent.getToken()) {
         case VAR:
+        case LET:
+        case CONST:
           checkState(parent.hasOneChild());
           replaceWithRhs(containingNode, parent);
           break;
@@ -470,7 +472,7 @@ final class NameAnalyzer implements CompilerPass {
     @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
       NameInformation ns = null;
-      if (NodeUtil.isVarDeclaration(n)) {
+      if (n.isName() && NodeUtil.isNameDeclaration(parent)) {
         ns = createNameInformation(t, n);
       } else if (NodeUtil.isFunctionDeclaration(n)) {
         ns = createNameInformation(t, n.getFirstChild());
@@ -516,7 +518,8 @@ final class NameAnalyzer implements CompilerPass {
         if (!NodeUtil.isImmutableResult(n.getLastChild())) {
           recordConsumers(t, n, n);
         }
-      } else if (NodeUtil.isVarDeclaration(n)) {
+      } else if (NodeUtil.isVarDeclaration(n)
+          || (t.inGlobalScope() && n.isName() && NodeUtil.isNameDeclaration(parent))) {
         NameInformation ns = createNameInformation(t, n);
         checkNotNull(ns, "createNameInformation returned null for: %s", n);
         recordDepScope(n, ns);
@@ -650,7 +653,8 @@ final class NameAnalyzer implements CompilerPass {
 
       // Record global variable and function declarations
       if (t.inGlobalHoistScope()) {
-        if (NodeUtil.isVarDeclaration(n)) {
+        if (NodeUtil.isVarDeclaration(n)
+            || (t.inGlobalScope() && n.isName() && NodeUtil.isNameDeclaration(parent))) {
           NameInformation ns = createNameInformation(t, n);
           checkNotNull(ns, "createNameInformation returned null for: %s", n);
           recordSet(ns.name, n);
@@ -714,15 +718,13 @@ final class NameAnalyzer implements CompilerPass {
     }
 
     /**
-     * Records the assignment to a prototype property of a global name,
-     * if possible.
+     * Records the assignment to a prototype property of a global name, if possible.
      *
      * @param className The name of the class.
      * @param prototypeProperty The name of the prototype property.
      * @param node The top node representing the name (GETPROP)
      */
-    private void recordPrototypeSet(String className, String prototypeProperty,
-        Node node) {
+    private void recordPrototypeSet(String className, String prototypeProperty, Node node) {
       JsName name = getName(className, true);
       name.prototypeNames.add(prototypeProperty);
       refNodes.add(new PrototypeSetNode(name, node));
@@ -1560,10 +1562,10 @@ final class NameAnalyzer implements CompilerPass {
       case NAME:
         // Check whether this is an assignment to a prototype property
         // of an object defined in the global scope.
-        if (!bNameWasShortened &&
-            n.isGetProp() &&
-            parent.isAssign() &&
-            "prototype".equals(n.getLastChild().getString())) {
+        if (!bNameWasShortened
+            && n.isGetProp()
+            && parent.isAssign()
+            && "prototype".equals(n.getLastChild().getString())) {
           if (createNameInformation(t, n.getFirstChild()) != null) {
             name = rootNameNode.getString() + name;
             name = name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);
@@ -1573,8 +1575,7 @@ final class NameAnalyzer implements CompilerPass {
             return null;
           }
         }
-        return createNameInformation(
-            rootNameNode.getString() + name, t.getScope(), rootNameNode);
+        return createNameInformation(rootNameNode.getString() + name, t.getScope(), rootNameNode);
       case THIS:
         if (t.inGlobalHoistScope()) {
           NameInformation nameInfo = new NameInformation(
@@ -1850,6 +1851,8 @@ final class NameAnalyzer implements CompilerPass {
       case EXPR_RESULT:
       case FUNCTION:
       case VAR:
+      case LET:
+      case CONST:
         break;
       case ASSIGN:
         checkArgument(
@@ -1984,6 +1987,8 @@ final class NameAnalyzer implements CompilerPass {
           return ImmutableList.of(lhs, rhs);
         }
       case VAR:
+      case LET:
+      case CONST:
         {
           // recurse on all children
           ImmutableList.Builder<Node> nodes = ImmutableList.builder();
diff --git a/src/com/google/javascript/jscomp/Reference.java b/src/com/google/javascript/jscomp/Reference.java
index cfabbb6e9..650b7e72c 100644
--- a/src/com/google/javascript/jscomp/Reference.java
+++ b/src/com/google/javascript/jscomp/Reference.java
@@ -174,8 +174,7 @@ public final class Reference implements StaticRef {
   }
 
   Node getGrandparent() {
-    Node parent = getParent();
-    return parent == null ? null : parent.getParent();
+    return getNode().getGrandparent();
   }
 
   private static boolean isLhsOfEnhancedForExpression(Node n) {
diff --git a/test/com/google/javascript/jscomp/NameAnalyzerTest.java b/test/com/google/javascript/jscomp/NameAnalyzerTest.java
index d4bbb6997..c9a74ed10 100644
--- a/test/com/google/javascript/jscomp/NameAnalyzerTest.java
+++ b/test/com/google/javascript/jscomp/NameAnalyzerTest.java
@@ -23,7 +23,7 @@ import com.google.javascript.rhino.Node;
  *
  */
 
-public final class NameAnalyzerTest extends CompilerTestCase {
+public final class NameAnalyzerTest extends Es6CompilerTestCase {
 
   private static String kExterns =
       "var window, top;" +
@@ -80,6 +80,93 @@ public final class NameAnalyzerTest extends CompilerTestCase {
     test("var a;var b = 0, c = a = b = 1", "");
   }
 
+  public void testRemoveLetDeclaration1() {
+    testEs6("let foo = 3;", "");
+  }
+
+  public void testRemoveLetDeclaration2() {
+    testEs6("let foo = 3, bar = 4; externfoo = foo;",
+         "let foo = 3; externfoo = foo;");
+  }
+
+  public void testRemoveLetDeclaration3() {
+    testEs6("let a = f(), b = 1, c = 2; b; c", "f();let b = 1, c = 2; b; c");
+  }
+
+  public void testRemoveLetDeclaration4() {
+    testEs6("let a = 0, b = f(), c = 2; a; c", "let a = 0;f();let c = 2; a; c");
+  }
+
+  public void testRemoveLetDeclaration5() {
+    testEs6("let a = 0, b = 1, c = f(); a; b", "let a = 0, b = 1; f(); a; b");
+  }
+
+  public void testRemoveLetDeclaration6() {
+    testEs6("let a = 0, b = a = 1; a", "let a = 0; a = 1; a");
+  }
+
+  public void testRemoveLetDeclaration7() {
+    testEs6("let a = 0, b = a = 1", "");
+  }
+
+  public void testRemoveLetDeclaration8() {
+    testEs6("let a;let b = 0, c = a = b = 1", "");
+  }
+
+  public void testRemoveLetDeclaration9() {
+    // The variable inside the block doesn't get removed (but does get renamed by Normalize).
+    testEs6(
+        "let x = 1; if (true) { let x = 2; x; }",
+        "if (true) { let x$jscomp$1 = 2; x$jscomp$1; }");
+  }
+
+  // Let/const defined variables in blocks are not global so NameAnalyzer doesn't remove them.
+  public void testDontRemoveLetInBlock1() {
+    testSameEs6(
+        LINE_JOINER.join(
+            "if (true) {",
+            "  let x = 1; alert(x);",
+            "}"));
+
+    testSameEs6(
+        LINE_JOINER.join(
+            "if (true) {",
+            "  let x = 1;",
+            "}"));
+  }
+
+  public void testDontRemoveLetInBlock2() {
+    testSameEs6(
+        LINE_JOINER.join(
+            "if (true) {",
+            "  let x = 1; alert(x);",
+            "} else {",
+            "  let x = 1; alert(x);",
+            "}"));
+
+    testSameEs6(
+        LINE_JOINER.join(
+            "if (true) {",
+            "  let x = 1;",
+            "} else {",
+            "  let x = 1;",
+            "}"));
+  }
+
+  public void testRemoveConstDeclaration1() {
+    testEs6("const a = 4;", "");
+  }
+
+  public void testRemoveConstDeclaration2() {
+    testSameEs6("const a = 4; window.x = a;");
+  }
+
+  public void testRemoveConstDeclaration3() {
+    // The variable inside the block doesn't get removed (but does get renamed by Normalize).
+    testEs6(
+        "const x = 1; if (true) { const x = 2; x; }",
+        "if (true) { const x$jscomp$1 = 2; x$jscomp$1; }");
+  }
 
   public void testRemoveDeclaration1() {
     test("var a;var b = 0, c = a = b = 1", "");
