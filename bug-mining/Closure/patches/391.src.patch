diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java
index fe8a4d6a4..b64144887 100644
--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java
+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java
@@ -1407,6 +1407,14 @@ class IRFactory {
       Node node = newNode(Token.OBJECTLIT);
       boolean maybeWarn = false;
       for (ParseTree el : objTree.propertyNameAndValues) {
+        if (el.type == ParseTreeType.DEFAULT_PARAMETER) {
+          // (e.g. var o = { x=4 };) This is only parsed for compatibility with object patterns.
+          errorReporter.error(
+              "Default value cannot appear at top level of an object literal.",
+              sourceName,
+              lineno(el), 0);
+          continue;
+        }
         if (config.languageMode == LanguageMode.ECMASCRIPT3) {
           if (el.type == ParseTreeType.GET_ACCESSOR) {
             reportGetter(el);
diff --git a/src/com/google/javascript/jscomp/parsing/parser/Parser.java b/src/com/google/javascript/jscomp/parsing/parser/Parser.java
index b2131fb36..f70d8f2a8 100644
--- a/src/com/google/javascript/jscomp/parsing/parser/Parser.java
+++ b/src/com/google/javascript/jscomp/parsing/parser/Parser.java
@@ -16,8 +16,6 @@
 
 package com.google.javascript.jscomp.parsing.parser;
 
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.javascript.jscomp.parsing.parser.trees.AmbientDeclarationTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ArgumentListTree;
@@ -1073,7 +1071,7 @@ public class Parser {
 
   private boolean peekArrowFunctionWithParenthesizedParameterList(ParamContext context) {
     if (peek(TokenType.OPEN_PAREN) || peek(TokenType.OPEN_ANGLE)) {
-      // TODO(johnlenz): determine if we can parse this without the
+      // TODO(blickly): determine if we can parse this without the
       // overhead of forking the parser.
       Parser p = createLookaheadParser();
       try {
@@ -1728,17 +1726,10 @@ public class Parser {
       return parseForStatement(start, null);
     }
 
-    Predicate<Token> followPred = new Predicate<Token>() {
-      @Override
-      public boolean apply(Token t) {
-        return EnumSet.of(TokenType.IN, TokenType.EQUAL).contains(t.type)
-            || (t.type == TokenType.IDENTIFIER
-                && t.asIdentifier().value.equals(PredefinedName.OF));
-      }
-    };
-    ParseTree initializer = peekPattern(PatternKind.ANY, followPred)
-        ? parsePattern(PatternKind.ANY)
-        : parseExpressionNoIn();
+    ParseTree initializer = parseExpressionNoIn();
+    if (peek(TokenType.IN) || peek(TokenType.EQUAL) || peekPredefinedString(PredefinedName.OF)) {
+      initializer = transformLeftHandSideExpression(initializer);
+    }
 
     if (peek(TokenType.IN) || peekPredefinedString(PredefinedName.OF)) {
       if (initializer.type != ParseTreeType.BINARY_OPERATOR
@@ -2434,6 +2425,12 @@ public class Parser {
       } else if (Keywords.isKeyword(name.asIdentifier().value)
           && !Keywords.isTypeScriptSpecificKeyword(name.asIdentifier().value)) {
         reportError(name, "Cannot use keyword in short object literal");
+      } else if (peek(TokenType.EQUAL)) {
+        IdentifierExpressionTree idTree = new IdentifierExpressionTree(
+            getTreeLocation(start), (IdentifierToken) name);
+        eat(TokenType.EQUAL);
+        ParseTree defaultValue = parseAssignmentExpression();
+        return new DefaultParameterTree(getTreeLocation(start), idTree, defaultValue);
       }
     }
     ParseTree value = colon == null ? null : parseAssignmentExpression();
@@ -2585,11 +2582,10 @@ public class Parser {
     }
 
     SourcePosition start = getTreeStartLocation();
-    ParseTree left = peekParenPatternAssignment()
-        ? parseParenPattern()
-        : parseConditional(expressionIn);
+    ParseTree left = parseConditional(expressionIn);
 
     if (peekAssignmentOperator()) {
+      left = transformLeftHandSideExpression(left);
       if (!left.isValidAssignmentTarget()) {
         reportError("invalid assignment target");
       }
@@ -2600,6 +2596,32 @@ public class Parser {
     return left;
   }
 
+  /**
+   * Transforms a LeftHandSideExpression into a LeftHandSidePattern if possible.
+   * This returns the transformed tree if it parses as a LeftHandSidePattern,
+   * otherwise it returns the original tree.
+   */
+  private ParseTree transformLeftHandSideExpression(ParseTree tree) {
+    switch (tree.type) {
+      case ARRAY_LITERAL_EXPRESSION:
+      case OBJECT_LITERAL_EXPRESSION:
+        resetScanner(tree);
+        // If we fail to parse as an LeftHandSidePattern then
+        // parseLeftHandSidePattern will take care reporting errors.
+        return parseLeftHandSidePattern();
+      default:
+        return tree;
+    }
+  }
+
+  private ParseTree parseLeftHandSidePattern() {
+    return parsePattern(PatternKind.ANY);
+  }
+
+  private void resetScanner(ParseTree tree) {
+    scanner.setOffset(tree.location.start.offset);
+  }
+
   private boolean peekAssignmentOperator() {
     switch (peekType()) {
     case EQUAL:
@@ -3047,70 +3069,8 @@ public class Parser {
     ANY,
   }
 
-  private boolean peekParenPatternAssignment() {
-    return peekParenPattern(PatternKind.ANY, assignmentFollowSet);
-  }
-
-  private boolean peekParenPatternStart() {
-    int index = 0;
-    while (peek(index, TokenType.OPEN_PAREN)) {
-      index++;
-    }
-    return peekPatternStart(index);
-  }
-
   private boolean peekPatternStart() {
-    return peekPatternStart(0);
-  }
-
-  private boolean peekPatternStart(int index) {
-    return peek(index, TokenType.OPEN_SQUARE) || peek(index, TokenType.OPEN_CURLY);
-  }
-
-  private ParseTree parseParenPattern() {
-    return parseParenPattern(PatternKind.ANY);
-  }
-
-  private ParseTree parseParenPattern(PatternKind kind) {
-    if (peek(TokenType.OPEN_PAREN)) {
-      SourcePosition start = getTreeStartLocation();
-      eat(TokenType.OPEN_PAREN);
-      ParseTree result = parseParenPattern(kind);
-      eat(TokenType.CLOSE_PAREN);
-      return new ParenExpressionTree(this.getTreeLocation(start), result);
-    } else {
-      return parsePattern(kind);
-    }
-  }
-
-  private boolean peekPattern(PatternKind kind) {
-    return peekPattern(kind, Predicates.<Token>alwaysTrue());
-  }
-
-  private boolean peekPattern(PatternKind kind, Predicate<Token> follow) {
-    if (!peekPatternStart()) {
-      return false;
-    }
-    Parser p = createLookaheadParser();
-    try {
-      p.parsePattern(kind);
-      return follow.apply(p.peekToken());
-    } catch (ParseException e) {
-      return false;
-    }
-  }
-
-  private boolean peekParenPattern(PatternKind kind, EnumSet<TokenType> follow) {
-    if (!peekParenPatternStart()) {
-      return false;
-    }
-    Parser p = createLookaheadParser();
-    try {
-      p.parseParenPattern(kind);
-      return follow.contains(p.peekType());
-    } catch (ParseException e) {
-      return false;
-    }
+    return peek(TokenType.OPEN_SQUARE) || peek(TokenType.OPEN_CURLY);
   }
 
   private ParseTree parsePattern(PatternKind kind) {
@@ -3127,9 +3087,6 @@ public class Parser {
     return peekExpression() || peek(TokenType.SPREAD);
   }
 
-  private static final EnumSet<TokenType> assignmentFollowSet =
-      EnumSet.of(TokenType.EQUAL);
-
   // Element ::= Pattern | LValue | ... LValue
   private ParseTree parseArrayPatternElement(PatternKind kind) {
     SourcePosition start = getTreeStartLocation();
@@ -3137,8 +3094,8 @@ public class Parser {
     boolean rest = false;
 
     // [ or { are preferably the start of a sub-pattern
-    if (peekParenPatternStart()) {
-      lvalue = parseParenPattern(kind);
+    if (peekPatternStart()) {
+      lvalue = parsePattern(kind);
     } else {
       // An element that's not a sub-pattern
 
@@ -3268,7 +3225,7 @@ public class Parser {
   private ParseTree parseObjectPatternFieldTail(PatternKind kind) {
     SourcePosition start = getTreeStartLocation();
     ParseTree value;
-    if (peekPattern(kind)) {
+    if (peekPatternStart()) {
       value = parsePattern(kind);
     } else {
       value = (kind == PatternKind.ANY)
diff --git a/src/com/google/javascript/jscomp/parsing/parser/Scanner.java b/src/com/google/javascript/jscomp/parsing/parser/Scanner.java
index 1f5149163..b7501ebbc 100644
--- a/src/com/google/javascript/jscomp/parsing/parser/Scanner.java
+++ b/src/com/google/javascript/jscomp/parsing/parser/Scanner.java
@@ -70,6 +70,11 @@ public class Scanner {
         : peekToken().location.start.offset;
   }
 
+  public void setOffset(int index) {
+    currentTokens.clear();
+    this.index = index;
+  }
+
   public SourcePosition getPosition() {
     return getPosition(getOffset());
   }
diff --git a/test/com/google/javascript/jscomp/Es6RewriteDestructuringTest.java b/test/com/google/javascript/jscomp/Es6RewriteDestructuringTest.java
index 6ee282bf7..264da33fa 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteDestructuringTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteDestructuringTest.java
@@ -60,7 +60,7 @@ public class Es6RewriteDestructuringTest extends CompilerTestCase {
             "var b = $jscomp$destructuring$var0.b;"));
 
     test(
-        "var x; ({a: x}) = foo();",
+        "var x; ({a: x} = foo());",
         LINE_JOINER.join(
             "var x;",
             "var $jscomp$destructuring$var0 = foo();",
@@ -100,7 +100,7 @@ public class Es6RewriteDestructuringTest extends CompilerTestCase {
         "var $jscomp$destructuring$var0 = foo(); var b = $jscomp$destructuring$var0[a];");
 
     test(
-        "({[a]: b}) = foo();",
+        "({[a]: b} = foo());",
         "var $jscomp$destructuring$var0 = foo(); b = $jscomp$destructuring$var0[a];");
 
     test(
diff --git a/test/com/google/javascript/jscomp/Es6VariableReferenceCheckTest.java b/test/com/google/javascript/jscomp/Es6VariableReferenceCheckTest.java
index b708fd01d..063cd95dd 100644
--- a/test/com/google/javascript/jscomp/Es6VariableReferenceCheckTest.java
+++ b/test/com/google/javascript/jscomp/Es6VariableReferenceCheckTest.java
@@ -294,7 +294,7 @@ public final class Es6VariableReferenceCheckTest extends CompilerTestCase {
     assertEarlyReference("alert(b); var {a: b} = {a: 1};");
     assertEarlyReference("alert(a); var {a} = {a: 1};");
 
-    assertEarlyReference("({a: b}) = {}; var a, b;");
+    assertEarlyReference("({a: b} = {}); var a, b;");
   }
 
   public void testObjectPattern_defaultValue() {
diff --git a/test/com/google/javascript/jscomp/InferConstsTest.java b/test/com/google/javascript/jscomp/InferConstsTest.java
index 4e45dbc86..2957ee630 100644
--- a/test/com/google/javascript/jscomp/InferConstsTest.java
+++ b/test/com/google/javascript/jscomp/InferConstsTest.java
@@ -124,7 +124,7 @@ public final class InferConstsTest extends TestCase {
         + "[{a: x} = {a: 'x'}] = {};", "x");
     testNotConsts(""
         + "let fg = '', bg = '';"
-        + "({fg, bg}) = pal[val - 1];", "fg", "bg");
+        + "({fg, bg} = pal[val - 1]);", "fg", "bg");
   }
 
   public void testDefaultValue() {
diff --git a/test/com/google/javascript/jscomp/parsing/NewParserTest.java b/test/com/google/javascript/jscomp/parsing/NewParserTest.java
index 98e4f10e8..3eb8afe2f 100644
--- a/test/com/google/javascript/jscomp/parsing/NewParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/NewParserTest.java
@@ -1307,31 +1307,23 @@ public final class NewParserTest extends BaseJSTypeTestCase {
 
   public void testObjectDestructuringAssign() {
     mode = LanguageMode.ECMASCRIPT6;
-    parse("({x, y}) = foo();");
+    parseError("({x, y}) = foo();", "invalid assignment target");
     parse("({x, y} = foo());");
-    parse("({x: x, y: y}) = foo();");
     parse("({x: x, y: y} = foo());");
-    parse("({x: {y, z}}) = foo();");
     parse("({x: {y, z}} = foo());");
-    parse("({k1: {k2 : x} = bar(), k3: y}) = foo();");
     parse("({k1: {k2 : x} = bar(), k3: y} = foo());");
 
     // Useless, but legal.
-    parse("({}) = foo();");
     parse("({} = foo());");
   }
 
   public void testObjectDestructuringAssignWithInitializer() {
     mode = LanguageMode.ECMASCRIPT6;
-    parse("({x = 1}) = foo();");
+    parseError("({x = 1}) = foo();", "invalid assignment target");
     parse("({x = 1} = foo());");
-    parse("({x: {y = 1}}) = foo();");
     parse("({x: {y = 1}} = foo());");
-    parse("({x: y = 1}) = foo();");
     parse("({x: y = 1} = foo());");
-    parse("({x: v1 = 5, y: v2 = 'str'}) = foo();");
     parse("({x: v1 = 5, y: v2 = 'str'} = foo());");
-    parse("({k1: {k2 : x} = bar(), k3: y}) = foo();");
     parse("({k1: {k2 : x} = bar(), k3: y} = foo());");
   }
 
@@ -1394,16 +1386,22 @@ public final class NewParserTest extends BaseJSTypeTestCase {
 
   public void testObjectDestructuringExtraParens() {
     mode = LanguageMode.ECMASCRIPT6;
-    parse("({x}) = y;");
-    parse("(({x})) = y;");
-    parse("((({x}))) = y;");
+    parse("({x: y} = z);");
+    parse("({x: (y)} = z);");
+    parse("({x: ((y))} = z);");
 
-    parse("([x]) = y;");
+    parse("([x] = y);");
+    parse("[(x), y] = z;");
     parse("[x, (y)] = z;");
     parse("[x, ([y])] = z;");
     parse("[x, (([y]))] = z;");
   }
 
+  public void testObjectLiteralCannotUseDestructuring() {
+    mode = LanguageMode.ECMASCRIPT6;
+    parseError("var o = {x = 5}", "Default value cannot appear at top level of an object literal.");
+  }
+
   public void testMixedDestructuring() {
     mode = LanguageMode.ECMASCRIPT6;
     parse("var {x: [y, z]} = foo();");
@@ -2584,8 +2582,8 @@ public final class NewParserTest extends BaseJSTypeTestCase {
     mode = LanguageMode.ECMASCRIPT6;
 
     // {x: 5} and {x: 'str'} are valid object literals but not valid patterns.
-    parseError("for ({x: 5} in foo()) {}", "Invalid LHS for a for-in loop");
-    parseError("for ({x: 'str'} in foo()) {}", "Invalid LHS for a for-in loop");
+    parseError("for ({x: 5} in foo()) {}", "invalid assignment target");
+    parseError("for ({x: 'str'} in foo()) {}", "invalid assignment target");
     parseError("var {x: 5} = foo();", "'identifier' expected");
     parseError("var {x: 'str'} = foo();", "'identifier' expected");
     parseError("({x: 5} = foo());", "invalid assignment target");
