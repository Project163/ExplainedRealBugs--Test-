diff --git a/src/com/google/javascript/jscomp/AbstractCompiler.java b/src/com/google/javascript/jscomp/AbstractCompiler.java
index 48581f3df..7cf06e59b 100644
--- a/src/com/google/javascript/jscomp/AbstractCompiler.java
+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java
@@ -324,4 +324,9 @@ public abstract class AbstractCompiler implements SourceExcerptProvider {
    */
   abstract GlobalVarReferenceMap getGlobalVarReferences();
 
+  /**
+   * @return a CompilerInput that can be modified to add addition extern
+   * definitions;
+   */
+  abstract CompilerInput getSynthesizedExternsInput();
 }
diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java
index 196bf4020..6aca72eff 100644
--- a/src/com/google/javascript/jscomp/CheckSideEffects.java
+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java
@@ -16,11 +16,16 @@
 
 package com.google.javascript.jscomp;
 
+import com.google.common.collect.Lists;
 import com.google.javascript.jscomp.CheckLevel;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
+import com.google.javascript.rhino.IR;
+import com.google.javascript.rhino.JSDocInfoBuilder;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
+import java.util.List;
+
 /**
  * Checks for non side effecting statements such as
  * <pre>
@@ -32,16 +37,47 @@ import com.google.javascript.rhino.Token;
  * and generates warnings.
  *
  */
-final class CheckSideEffects extends AbstractPostOrderCallback {
+final class CheckSideEffects extends AbstractPostOrderCallback
+    implements HotSwapCompilerPass {
 
   static final DiagnosticType USELESS_CODE_ERROR = DiagnosticType.warning(
       "JSC_USELESS_CODE",
       "Suspicious code. {0}");
 
+  static final String PROTECTOR_FN = "JSCOMPILER_PRESERVE";
+
   private final CheckLevel level;
 
-  CheckSideEffects(CheckLevel level) {
+  private final List<Node> problemNodes = Lists.newArrayList();
+
+  private final AbstractCompiler compiler;
+
+  private final boolean protectSideEffectFreeCode;
+
+  CheckSideEffects(AbstractCompiler compiler, CheckLevel level,
+      boolean protectSideEffectFreeCode) {
+    this.compiler = compiler;
     this.level = level;
+    this.protectSideEffectFreeCode = protectSideEffectFreeCode;
+  }
+
+  @Override
+  public void process(Node externs, Node root) {
+    NodeTraversal.traverse(compiler, root, this);
+
+    // Code with hidden side-effect code is common, for example
+    // accessing "el.offsetWidth" forces a reflow in browsers, to allow this
+    // will still allowing local dead code removal in general,
+    // protect the "side-effect free" code in the source.
+    //
+    if (protectSideEffectFreeCode) {
+      protectSideEffects();
+    }
+  }
+
+  @Override
+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {
+    NodeTraversal.traverse(compiler, scriptRoot, this);
   }
 
   @Override
@@ -55,8 +91,9 @@ final class CheckSideEffects extends AbstractPostOrderCallback {
       return;
     }
 
-    if (parent == null)
+    if (parent == null) {
       return;
+    }
 
     int pt = parent.getType();
     if (pt == Token.COMMA) {
@@ -120,6 +157,75 @@ final class CheckSideEffects extends AbstractPostOrderCallback {
 
       t.getCompiler().report(
           t.makeError(n, level, USELESS_CODE_ERROR, msg));
+      // TODO(johnlenz): determine if it is necessary to
+      // try to protect side-effect free statements as well.
+      if (!NodeUtil.isStatement(n)) {
+        problemNodes.add(n);
+      }
+    }
+  }
+
+  /**
+   * Protect side-effect free nodes by making them parameters
+   * to a extern function call.  This call will be removed
+   * after all the optimizations passes have run.
+   */
+  private void protectSideEffects() {
+    if (!problemNodes.isEmpty()) {
+      addExtern();
+      for (Node n : problemNodes) {
+        Node name = IR.name(PROTECTOR_FN).srcref(n);
+        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);
+        Node replacement = IR.call(name).srcref(n);
+        replacement.putBooleanProp(Node.FREE_CALL, true);
+        n.getParent().replaceChild(n, replacement);
+        replacement.addChildToBack(n);
+      }
+      compiler.reportCodeChange();
+    }
+  }
+
+  private void addExtern() {
+    Node name = IR.name(PROTECTOR_FN);
+    name.putBooleanProp(Node.IS_CONSTANT_NAME, true);
+    Node var = IR.var(name);
+    // Add "@noalias" so we can strip the method when AliasExternals is enabled.
+    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);
+    builder.recordNoAlias();
+    var.setJSDocInfo(builder.build(var));
+    CompilerInput input = compiler.getSynthesizedExternsInput();
+    input.getAstRoot(compiler).addChildrenToBack(var);
+    compiler.reportCodeChange();
+  }
+
+  /**
+   * Remove side-effect sync functions.
+   */
+  static class StripProtection extends AbstractPostOrderCallback implements CompilerPass {
+
+    private final AbstractCompiler compiler;
+
+    StripProtection(AbstractCompiler compiler) {
+      this.compiler = compiler;
+    }
+
+    @Override
+    public void process(Node externs, Node root) {
+      NodeTraversal.traverse(compiler, root, this);
+    }
+
+    @Override
+    public void visit(NodeTraversal t, Node n, Node parent) {
+      if (n.isCall()) {
+        Node target = n.getFirstChild();
+        // TODO(johnlenz): add this to the coding convention
+        // so we can remove goog.reflect.sinkValue as well.
+        if (target.isName() && target.getString().equals(PROTECTOR_FN)) {
+          Node expr = n.getLastChild();
+          n.detachChildren();
+          parent.replaceChild(n, expr);
+        }
+      }
     }
   }
 }
diff --git a/src/com/google/javascript/jscomp/CompilationLevel.java b/src/com/google/javascript/jscomp/CompilationLevel.java
index 4c36ef914..3ca5c87a8 100644
--- a/src/com/google/javascript/jscomp/CompilationLevel.java
+++ b/src/com/google/javascript/jscomp/CompilationLevel.java
@@ -116,6 +116,7 @@ public enum CompilationLevel {
     options.optimizeArgumentsArray = true;
     options.setRemoveUnusedVariables(Reach.LOCAL_ONLY);
     options.collapseObjectLiterals = true;
+    options.protectHiddenSideEffects = true;
 
     // Allows annotations that are not standard.
     options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,
@@ -144,6 +145,7 @@ public enum CompilationLevel {
     options.removeDeadCode = true;
     options.optimizeArgumentsArray = true;
     options.collapseObjectLiterals = true;
+    options.protectHiddenSideEffects = true;
 
     // All the advance optimizations.
     options.removeClosureAsserts = true;
diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java
index f6e4c87a6..d16c12e80 100644
--- a/src/com/google/javascript/jscomp/Compiler.java
+++ b/src/com/google/javascript/jscomp/Compiler.java
@@ -1821,6 +1821,11 @@ public class Compiler extends AbstractCompiler {
   private final List<CodeChangeHandler> codeChangeHandlers =
       Lists.<CodeChangeHandler>newArrayList();
 
+  /** Name of the synthetic input that holds synthesized externs. */
+  static final String SYNTHETIC_EXTERNS = "{SyntheticVarsDeclar}";
+
+  private CompilerInput synthesizedExternsInput = null;
+
   @Override
   void addChangeHandler(CodeChangeHandler handler) {
     codeChangeHandlers.add(handler);
@@ -2215,4 +2220,12 @@ public class Compiler extends AbstractCompiler {
     return globalRefMap;
   }
 
+  @Override
+  CompilerInput getSynthesizedExternsInput() {
+    if (synthesizedExternsInput == null) {
+      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);
+    }
+    return synthesizedExternsInput;
+  }
+
 }
diff --git a/src/com/google/javascript/jscomp/CompilerOptions.java b/src/com/google/javascript/jscomp/CompilerOptions.java
index 75280476c..4fecfbed3 100644
--- a/src/com/google/javascript/jscomp/CompilerOptions.java
+++ b/src/com/google/javascript/jscomp/CompilerOptions.java
@@ -736,6 +736,18 @@ public class CompilerOptions implements Serializable, Cloneable {
    */
   boolean looseTypes;
 
+  /**
+   * When set, assume that apparently side-effect free code is meaningful.
+   */
+  boolean protectHiddenSideEffects;
+
+  /**
+   * When enabled, assume that apparently side-effect free code is meaningful.
+   */
+  public void setProtectHiddenSideEffects(boolean enable) {
+    this.protectHiddenSideEffects = enable;
+  }
+
   /**
    * Data holder Alias Transformation information accumulated during a compile.
    */
diff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java
index 5e8621cfd..360d6dd61 100644
--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java
+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java
@@ -205,6 +205,8 @@ public class DefaultPassConfig extends PassConfig {
       return checks;
     }
 
+    checks.add(checkSideEffects);
+
     if (options.checkSuspiciousCode ||
         options.enables(DiagnosticGroups.GLOBAL_THIS) ||
         options.enables(DiagnosticGroups.DEBUGGER_STATEMENT_PRESENT)) {
@@ -661,6 +663,8 @@ public class DefaultPassConfig extends PassConfig {
       passes.add(rescopeGlobalSymbols);
     }
 
+    passes.add(stripSideEffectProtection);
+
     // Safety checks
     passes.add(sanityCheckAst);
     passes.add(sanityCheckVars);
@@ -732,6 +736,39 @@ public class DefaultPassConfig extends PassConfig {
     return passes;
   }
 
+  /**
+   * Checks for code that is probably wrong (such as stray expressions).
+   */
+  final HotSwapPassFactory checkSideEffects =
+      new HotSwapPassFactory("checkSideEffects", true) {
+
+    @Override
+    protected HotSwapCompilerPass createInternal(final AbstractCompiler
+        compiler) {
+      // The current approach to protecting "hidden" side-effects is to
+      // wrap them in a function call that is stripped later, this shouldn't
+      // be done in IDE mode where AST changes may be unexpected.
+      boolean protectHiddenSideEffects =
+          options.protectHiddenSideEffects && !options.ideMode;
+      return new CheckSideEffects(compiler,
+          options.checkSuspiciousCode ? CheckLevel.WARNING : CheckLevel.OFF,
+              protectHiddenSideEffects);
+    }
+  };
+
+  /**
+   * Checks for code that is probably wrong (such as stray expressions).
+   */
+  final PassFactory stripSideEffectProtection =
+      new PassFactory("stripSideEffectProtection", true) {
+
+    @Override
+    protected CompilerPass createInternal(final AbstractCompiler
+        compiler) {
+      return new CheckSideEffects.StripProtection(compiler);
+    }
+  };
+
   /**
    * Checks for code that is probably wrong (such as stray expressions).
    */
@@ -745,7 +782,6 @@ public class DefaultPassConfig extends PassConfig {
       List<Callback> sharedCallbacks = Lists.newArrayList();
       if (options.checkSuspiciousCode) {
         sharedCallbacks.add(new CheckAccidentalSemicolon(CheckLevel.WARNING));
-        sharedCallbacks.add(new CheckSideEffects(CheckLevel.WARNING));
       }
 
       if (options.enables(DiagnosticGroups.GLOBAL_THIS)) {
diff --git a/src/com/google/javascript/jscomp/SymbolTable.java b/src/com/google/javascript/jscomp/SymbolTable.java
index 261b25eb2..05ad8dce1 100644
--- a/src/com/google/javascript/jscomp/SymbolTable.java
+++ b/src/com/google/javascript/jscomp/SymbolTable.java
@@ -612,7 +612,7 @@ public final class SymbolTable
   private boolean isGoodRefToAdd(@Nullable StaticReference<JSType> ref) {
     return ref != null && ref.getNode() != null
         && ref.getNode().getStaticSourceFile() != null
-        && !VarCheck.SYNTHETIC_VARS_DECLAR.equals(
+        && !Compiler.SYNTHETIC_EXTERNS.equals(
             ref.getNode().getStaticSourceFile().getName());
   }
 
diff --git a/src/com/google/javascript/jscomp/VarCheck.java b/src/com/google/javascript/jscomp/VarCheck.java
index cdd8dcec8..b94cc6444 100644
--- a/src/com/google/javascript/jscomp/VarCheck.java
+++ b/src/com/google/javascript/jscomp/VarCheck.java
@@ -34,8 +34,6 @@ import java.util.Set;
  */
 class VarCheck extends AbstractPostOrderCallback implements
     HotSwapCompilerPass {
-  /** Name of the synthetic script that holds undefined variables. */
-  static final String SYNTHETIC_VARS_DECLAR = "{SyntheticVarsDeclar}";
 
   static final DiagnosticType UNDEFINED_VAR_ERROR = DiagnosticType.error(
       "JSC_UNDEFINED_VARIABLE",
@@ -66,7 +64,6 @@ class VarCheck extends AbstractPostOrderCallback implements
       "JSC_UNDEFINED_EXTERN_VAR_ERROR",
       "name {0} is not undefined in the externs.");
 
-  private CompilerInput synthesizedExternsInput = null;
   private Node synthesizedExternsRoot = null;
 
   // Vars that still need to be declared in externs. These will be declared
@@ -267,11 +264,7 @@ class VarCheck extends AbstractPostOrderCallback implements
 
   /** Lazily create a "new" externs input for undeclared variables. */
   private CompilerInput getSynthesizedExternsInput() {
-    if (synthesizedExternsInput == null) {
-      synthesizedExternsInput =
-          compiler.newExternInput(SYNTHETIC_VARS_DECLAR);
-    }
-    return synthesizedExternsInput;
+    return compiler.getSynthesizedExternsInput();
   }
 
   /** Lazily create a "new" externs root for undeclared variables. */
diff --git a/test/com/google/javascript/jscomp/CheckSideEffectsTest.java b/test/com/google/javascript/jscomp/CheckSideEffectsTest.java
index 9040b6bb3..ba93a7480 100644
--- a/test/com/google/javascript/jscomp/CheckSideEffectsTest.java
+++ b/test/com/google/javascript/jscomp/CheckSideEffectsTest.java
@@ -21,16 +21,26 @@ import com.google.javascript.jscomp.CheckLevel;
 public class CheckSideEffectsTest extends CompilerTestCase {
   public CheckSideEffectsTest() {
     this.parseTypeInfo = true;
+    allowExternsChanges(true);
+  }
+
+  @Override
+  protected int getNumRepetitions() {
+    return 1;
   }
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
-    return new CombinedCompilerPass(compiler,
-        new CheckSideEffects(CheckLevel.ERROR));
+    return new CheckSideEffects(compiler, CheckLevel.WARNING, true);
+  }
+
+  @Override
+  public void test(String js, String expected, DiagnosticType warning) {
+    test(js, expected, null, warning);
   }
 
-  public void test(String js, DiagnosticType error) {
-    test(js, error == null ? js : null, error);
+  public void test(String js, DiagnosticType warning) {
+    test(js, js, null, warning);
   }
 
   final DiagnosticType e = CheckSideEffects.USELESS_CODE_ERROR;
@@ -38,34 +48,41 @@ public class CheckSideEffectsTest extends CompilerTestCase {
 
   public void testUselessCode() {
     test("function f(x) { if(x) return; }", ok);
-    test("function f(x) { if(x); }", e);
+    test("function f(x) { if(x); }", "function f(x) { if(x); }", e);
 
     test("if(x) x = y;", ok);
-    test("if(x) x == bar();", e);
+    test("if(x) x == bar();", "if(x) JSCOMPILER_PRESERVE(x == bar());", e);
 
     test("x = 3;", ok);
-    test("x == 3;", e);
+    test("x == 3;", "JSCOMPILER_PRESERVE(x == 3);", e);
 
     test("var x = 'test'", ok);
-    test("var x = 'test'\n'str'", e);
+    test("var x = 'test'\n'str'",
+         "var x = 'test'\nJSCOMPILER_PRESERVE('str')", e);
 
     test("", ok);
     test("foo();;;;bar();;;;", ok);
 
     test("var a, b; a = 5, b = 6", ok);
-    test("var a, b; a = 5, b == 6", e);
-    test("var a, b; a = (5, 6)", e);      // the 5 has no side-effects
+    test("var a, b; a = 5, b == 6",
+         "var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)", e);
+    test("var a, b; a = (5, 6)",
+         "var a, b; a = (JSCOMPILER_PRESERVE(5), 6)", e);
     test("var a, b; a = (b = 7, 6)", ok);
     test("function x(){}\nfunction f(a, b){}\nf(1,(x(), 2));", ok);
-    test("function x(){}\nfunction f(a, b){}\nf(1,(2, 3));", e);
+    test("function x(){}\nfunction f(a, b){}\nf(1,(2, 3));",
+         "function x(){}\nfunction f(a, b){}\n" +
+         "f(1,(JSCOMPILER_PRESERVE(2), 3));", e);
   }
 
   public void testUselessCodeInFor() {
     test("for(var x = 0; x < 100; x++) { foo(x) }", ok);
     test("for(; true; ) { bar() }", ok);
     test("for(foo(); true; foo()) { bar() }", ok);
-    test("for(void 0; true; foo()) { bar() }", e);
-    test("for(foo(); true; void 0) { bar() }", e);
+    test("for(void 0; true; foo()) { bar() }",
+         "for(JSCOMPILER_PRESERVE(void 0); true; foo()) { bar() }", e);
+    test("for(foo(); true; void 0) { bar() }",
+         "for(foo(); true; JSCOMPILER_PRESERVE(void 0)) { bar() }", e);
 
     test("for(foo in bar) { foo() }", ok);
     test("for (i = 0; el = el.previousSibling; i++) {}", ok);
@@ -73,29 +90,30 @@ public class CheckSideEffectsTest extends CompilerTestCase {
   }
 
   public void testTypeAnnotations() {
-    test("x;", e);
-    test("a.b.c.d;", e);
+    test("x;", "JSCOMPILER_PRESERVE(x);", e);
+    test("a.b.c.d;", "JSCOMPILER_PRESERVE(a.b.c.d);", e);
     test("/** @type Number */ a.b.c.d;", ok);
     test("if (true) { /** @type Number */ a.b.c.d; }", ok);
 
-    test("function A() { this.foo; }", e);
+    test("function A() { this.foo; }",
+         "function A() { JSCOMPILER_PRESERVE(this.foo); }", e);
     test("function A() { /** @type Number */ this.foo; }", ok);
   }
 
   public void testJSDocComments() {
     test("function A() { /** This is a jsdoc comment */ this.foo; }", ok);
-    test("function A() { /* This is a normal comment */ this.foo; }", e);
+    test("function A() { /* This is a normal comment */ this.foo; }",
+         "function A() { " +
+         " /* This is a normal comment */ JSCOMPILER_PRESERVE(this.foo); }", e);
   }
 
   public void testIssue80() {
     test("(0, eval)('alert');", ok);
-    test("(0, foo)('alert');", e);
+    test("(0, foo)('alert');", "(JSCOMPILER_PRESERVE(0), foo)('alert');", e);
   }
 
   public void testIsue504() {
-    test("void f();", e);
-    assertEquals(
-        "Suspicious code. The result of the 'void' operator is not being used.",
-        getLastCompiler().getErrorManager().getErrors()[0].description);
+    test("void f();", "JSCOMPILER_PRESERVE(void f());", null, e,
+        "Suspicious code. The result of the 'void' operator is not being used.");
   }
 }
diff --git a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
index 25735ad20..42f9de8a3 100644
--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
@@ -97,6 +97,8 @@ public class CommandLineRunnerTest extends TestCase {
         + "/** @constructor */ function Window() {}\n"
         + "/** @type {string} */ Window.prototype.name;\n"
         + "/** @type {Window} */ var window;"
+        + "/** @constructor */ function Element() {}"
+        + "Element.prototype.offsetWidth;"
         + "/** @nosideeffects */ function noSideEffects() {}")
   );
 
@@ -384,10 +386,16 @@ public class CommandLineRunnerTest extends TestCase {
          "}");
   }
 
+  public void testHiddenSideEffect() {
+    args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
+    test("element.offsetWidth;",
+         "element.offsetWidth", CheckSideEffects.USELESS_CODE_ERROR);
+  }
+
   public void testIssue504() {
     args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
     test("void function() { alert('hi'); }();",
-         "alert('hi');", CheckSideEffects.USELESS_CODE_ERROR);
+         "alert('hi');void 0", CheckSideEffects.USELESS_CODE_ERROR);
   }
 
   public void testIssue601() {
