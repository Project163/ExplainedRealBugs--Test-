diff --git a/lib/google_common_deploy.jar b/lib/google_common_deploy.jar
index 99dd0e3e4..41a2c233c 100755
Binary files a/lib/google_common_deploy.jar and b/lib/google_common_deploy.jar differ
diff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java
index bca6ff3ee..cc2c6d93e 100644
--- a/src/com/google/javascript/jscomp/Normalize.java
+++ b/src/com/google/javascript/jscomp/Normalize.java
@@ -64,6 +64,13 @@ class Normalize implements CompilerPass {
   private static final boolean CONVERT_WHILE_TO_FOR = true;
   static final boolean MAKE_LOCAL_NAMES_UNIQUE = true;
 
+  public static final DiagnosticType CATCH_BLOCK_VAR_ERROR =
+    DiagnosticType.error(
+        "JSC_CATCH_BLOCK_VAR_ERROR",
+        "The use of scope variable {0} is not allowed within a catch block " +
+        "with a catch exception of the same name.");
+
+
   Normalize(AbstractCompiler compiler, boolean assertOnChange) {
     this.compiler = compiler;
     this.assertOnChange = assertOnChange;
@@ -546,9 +553,29 @@ class Normalize implements CompilerPass {
       Preconditions.checkState(n.getType() == Token.NAME);
       Var v = s.getVar(name);
       // If name is "arguments", Var maybe null.
-      Preconditions.checkState(
-          v == null || v.getParentNode().getType() != Token.CATCH);
-      if (v != null && parent.getType() == Token.FUNCTION) {
+      if (v != null && v.getParentNode().getType() == Token.CATCH) {
+        // Redeclaration of a catch expression variable is hard to model
+        // without support for "with" expressions.
+        // The EcmaScript spec (section 12.14), declares that a catch
+        // "catch (e) {}" is handled like "with ({'e': e}) {}" so that
+        // "var e" would refer to the scope variable, but any following
+        // reference would still refer to "e" of the catch expression.
+        // Until we have support for this disallow it.
+        // Currently the Scope object adds the catch expression to the
+        // function scope, which is technically not true but a good
+        // approximation for most uses.
+
+        // TODO(johnlenz): Consider improving how scope handles catch
+        // expression.
+
+        // Use the name of the var before it was made unique.
+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(
+            name);
+        compiler.report(
+            JSError.make(
+                NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,
+                CATCH_BLOCK_VAR_ERROR, name));
+      } else if (v != null && parent.getType() == Token.FUNCTION) {
         if (v.getParentNode().getType() == Token.VAR) {
           s.undeclare(v);
           s.declare(name, n, n.getJSType(), v.input);
diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java
index ad24c726c..32dcb2b44 100644
--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java
+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java
@@ -123,7 +123,7 @@ class RemoveUnusedVars implements CompilerPass {
       case Token.FUNCTION:
         // If it's an exported function, or an function expression, assume
         // that it'll be called.
-        if (NodeUtil.isFunctionExpression(n) || isExportedFunction(n, scope)) {
+        if (traverseFunctionWhenFirstSeen(n, scope)) {
           traverseFunction(n, scope);
         }
         return;
@@ -144,6 +144,14 @@ class RemoveUnusedVars implements CompilerPass {
     }
   }
 
+  /**
+   * @param n The function node.
+   * @return Whether to traverse the function immediately.
+   */
+  private boolean traverseFunctionWhenFirstSeen(Node n, Scope scope) {
+    return NodeUtil.isFunctionExpression(n) || isExportedFunction(n, scope);
+  }
+
   /**
    * @param n The function node.
    * @return Whether the function is exported.
@@ -152,7 +160,7 @@ class RemoveUnusedVars implements CompilerPass {
     Preconditions.checkState(NodeUtil.isFunctionDeclaration(n));
     // If we aren't removing global names, assume that all global functions
     // are exported.
-    return (!removeGlobals && scope.isGlobal()) || 
+    return (!removeGlobals && scope.isGlobal()) ||
         compiler_.getCodingConvention().isExported(
            n.getFirstChild().getString());
   }
@@ -218,13 +226,12 @@ class RemoveUnusedVars implements CompilerPass {
     referenced.add(var);
 
     Node parent = var.getParentNode();
-    if (parent.getType() == Token.FUNCTION &&
-        var.getInitialValue() != var.scope.getRootNode()) {
-      // Now that the function has been referenced, traverse it.
-      // Unless it's a bleeding function, in which case we're already
-      // traversing it.
-
-      traverseFunction(parent, var.scope);
+    if (parent.getType() == Token.FUNCTION) {
+      // Now that the function has been referenced traverse it if it won't be
+      // traversed otherwise.
+      if (!traverseFunctionWhenFirstSeen(parent, var.getScope())) {
+        traverseFunction(parent, var.scope);
+      }
     }
   }
 
diff --git a/test/com/google/javascript/jscomp/NormalizeTest.java b/test/com/google/javascript/jscomp/NormalizeTest.java
index 4ab4f6c65..6299b3e4b 100644
--- a/test/com/google/javascript/jscomp/NormalizeTest.java
+++ b/test/com/google/javascript/jscomp/NormalizeTest.java
@@ -298,6 +298,54 @@ public class NormalizeTest extends CompilerTestCase {
          "var b = EXTERN; var c = ext.FOO", null, null);
   }
 
+  public void testIssue166a() {
+    test("try { throw 1 } catch(e) { /** @suppress {duplicate} */ var e=2 }",
+         "try { throw 1 } catch(e) { var e=2 }",
+         Normalize.CATCH_BLOCK_VAR_ERROR);
+  }
+
+  public void testIssue166b() {
+    test("function a() {" +
+         "try { throw 1 } catch(e) { /** @suppress {duplicate} */ var e=2 }" +
+         "};",
+         "function a() {" +
+         "try { throw 1 } catch(e) { var e=2 }" +
+         "}",
+         Normalize.CATCH_BLOCK_VAR_ERROR);
+  }
+
+  public void testIssue166c() {
+    test("var e = 0; try { throw 1 } catch(e) {" +
+             "/** @suppress {duplicate} */ var e=2 }",
+         "var e = 0; try { throw 1 } catch(e) { var e=2 }",
+         Normalize.CATCH_BLOCK_VAR_ERROR);
+  }
+
+  public void testIssue166d() {
+    test("function a() {" +
+         "var e = 0; try { throw 1 } catch(e) {" +
+             "/** @suppress {duplicate} */ var e=2 }" +
+         "};",
+         "function a() {" +
+         "var e = 0; try { throw 1 } catch(e) { var e=2 }" +
+         "}",
+         Normalize.CATCH_BLOCK_VAR_ERROR);
+  }
+
+  public void testIssue166e() {
+    test("var e = 2; try { throw 1 } catch(e) {}",
+         "var e = 2; try { throw 1 } catch(e$$1) {}");
+  }
+
+  public void testIssue166f() {
+    test("function a() {" +
+         "var e = 2; try { throw 1 } catch(e) {}" +
+         "}",
+         "function a() {" +
+         "var e = 2; try { throw 1 } catch(e$$1) {}" +
+         "}");
+  }
+
   public void testRenamingConstantProperties() {
     // In order to detecte that foo.BAR is a constant, we need collapse
     // properties to run first so that we can tell if the initial value is
diff --git a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java
index 3864475f6..8d8ab5300 100644
--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java
+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java
@@ -224,18 +224,42 @@ public class RemoveUnusedVarsTest extends CompilerTestCase {
     testSame("var x=1");
     test("function y(x){var z;}", "function y(){}");
   }
-  
+
   public void testRemoveGlobal3() {
     removeGlobal = false;
     testSame("var x=1");
-    test("function x(){function y(x){var z;}y()}", 
+    test("function x(){function y(x){var z;}y()}",
          "function x(){function y(){}y()}");
   }
-  
+
   public void testRemoveGlobal4() {
     removeGlobal = false;
     testSame("var x=1");
-    test("function x(){function y(x){var z;}}", 
+    test("function x(){function y(x){var z;}}",
          "function x(){}");
-  }   
+  }
+
+  public void testIssue168a() {
+    test("function _a(){" +
+         "  (function(x){ _b(); })(1);" +
+         "}" +
+         "function _b(){" +
+         "  _a();" +
+         "}",
+         "function _a(){(function(){_b()})(1)}" +
+         "function _b(){_a()}");
+  }
+
+  public void testIssue168b() {
+    removeGlobal = false;
+    test("function a(){" +
+         "  (function(x){ b(); })(1);" +
+         "}" +
+         "function b(){" +
+         "  a();" +
+         "}",
+         "function a(){(function(){b()})(1)}" +
+         "function b(){a()}");
+  }
+
 }
