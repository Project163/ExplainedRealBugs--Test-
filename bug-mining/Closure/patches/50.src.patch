diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java
index 3c7a95ef6..4eeeb1010 100644
--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java
+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java
@@ -832,7 +832,7 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback
      */
     private Node makeVarDeclNode(String namespace, Node sourceNode) {
       Node name = Node.newString(Token.NAME, namespace);
-      name.addChildToFront(new Node(Token.OBJECTLIT));
+      name.addChildToFront(createNamespaceLiteral());
 
       Node decl = new Node(Token.VAR, name);
       decl.putBooleanProp(Node.IS_NAMESPACE, true);
@@ -847,6 +847,18 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback
       return decl;
     }
 
+    /**
+     * There are some special cases where clients of the compiler
+     * do not run TypedScopeCreator after running this pass.
+     * So always give the namespace literal a type.
+     */
+    private Node createNamespaceLiteral() {
+      Node objlit = new Node(Token.OBJECTLIT);
+      objlit.setJSType(
+          compiler.getTypeRegistry().createAnonymousObjectType());
+      return objlit;
+    }
+
     /**
      * Creates a dotted namespace assignment expression
      * (e.g. <code>foo.bar = {};</code>).
@@ -857,8 +869,8 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback
     private Node makeAssignmentExprNode(String namespace, Node node) {
       Node decl = new Node(Token.EXPR_RESULT,
           new Node(Token.ASSIGN,
-            NodeUtil.newQualifiedNameNode(namespace, node, namespace),
-              new Node(Token.OBJECTLIT)));
+              NodeUtil.newQualifiedNameNode(namespace, node, namespace),
+              createNamespaceLiteral()));
       decl.putBooleanProp(Node.IS_NAMESPACE, true);
       Preconditions.checkState(isNamespacePlaceholder(decl));
       decl.copyInformationFromForTree(node);
diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java
index 2af6a806b..2b3cc071a 100644
--- a/src/com/google/javascript/jscomp/TypeInference.java
+++ b/src/com/google/javascript/jscomp/TypeInference.java
@@ -657,12 +657,7 @@ class TypeInference
 
   private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {
     ObjectType objectType = (ObjectType) n.getJSType();
-
-    if (objectType == null) {
-      // This will only happen if someone didn't run typed scope creation
-      // properly.
-      return scope;
-    }
+    Preconditions.checkNotNull(objectType);
 
     // Object literals can be reflected on other types.
     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.
diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java
index f37a64b40..28d9d3776 100644
--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java
+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java
@@ -333,7 +333,9 @@ final class TypedScopeCreator implements ScopeCreator {
         break;
 
       case Token.OBJECTLIT:
-        n.setJSType(typeRegistry.createAnonymousObjectType());
+        if (n.getJSType() == null) {
+          n.setJSType(typeRegistry.createAnonymousObjectType());
+        }
         break;
 
       // NOTE(nicksantos): If we ever support Array tuples,
