diff --git a/src/com/google/javascript/jscomp/CheckAccidentalSemicolon.java b/src/com/google/javascript/jscomp/CheckAccidentalSemicolon.java
new file mode 100644
index 000000000..06afa5cab
--- /dev/null
+++ b/src/com/google/javascript/jscomp/CheckAccidentalSemicolon.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2006 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import com.google.javascript.jscomp.CheckLevel;
+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
+import com.google.javascript.rhino.Node;
+import com.google.javascript.rhino.Token;
+
+/**
+ * Checks for misplaced semicolons, such as
+ * <pre>
+ * if (foo()); act_now();
+ * </pre>
+ * and generates warnings.
+ *
+ */
+final class CheckAccidentalSemicolon extends AbstractPostOrderCallback {
+
+  static final DiagnosticType SUSPICIOUS_SEMICOLON = DiagnosticType.warning(
+      "JSC_SUSPICIOUS_SEMICOLON",
+      "If this if/for/while really shouldn't have a body, use {}");
+
+  private final CheckLevel level;
+
+  CheckAccidentalSemicolon(CheckLevel level) {
+    this.level = level;
+  }
+
+  @Override
+  public void visit(NodeTraversal t, Node n, Node parent) {
+    Node child;
+    switch (n.getType()) {
+      case Token.IF:
+        child = n.getFirstChild().getNext();  // skip the condition child
+        break;
+
+      case Token.WHILE:
+      case Token.FOR:
+        child = NodeUtil.getLoopCodeBlock(n);
+        break;
+
+      default:
+        return;  // don't check other types
+    }
+
+    // semicolons cause VOID children. Empty blocks are allowed because
+    // that's usually intentional, especially with loops.
+    for (; child != null; child = child.getNext()) {
+      if ((child.isBlock()) && (!child.hasChildren())) {
+        // Only warn on empty blocks that replaced EMPTY nodes.  BLOCKs with no
+        // children are considered OK.
+        if (child.wasEmptyNode()) {
+          t.getCompiler().report(
+              t.makeError(n, level, SUSPICIOUS_SEMICOLON));
+        }
+      }
+    }
+  }
+}
diff --git a/src/com/google/javascript/jscomp/CheckSuspiciousCode.java b/src/com/google/javascript/jscomp/CheckSuspiciousCode.java
deleted file mode 100644
index 115ec12d9..000000000
--- a/src/com/google/javascript/jscomp/CheckSuspiciousCode.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright 2012 The Closure Compiler Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.javascript.jscomp;
-
-import com.google.common.base.Preconditions;
-import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
-import com.google.javascript.rhino.Node;
-import com.google.javascript.rhino.Token;
-
-/**
- * Checks for common errors, such as misplaced semicolons:
- * <pre>
- * if (x); act_now();
- * </pre>
- *  or comparison against NaN:
- * <pre>
- * if (x === NaN) act();
- * </pre>
- * and generates warnings.
- *
- * @author johnlenz@google.com (John Lenz)
- */
-final class CheckSuspiciousCode extends AbstractPostOrderCallback {
-
-  static final DiagnosticType SUSPICIOUS_SEMICOLON = DiagnosticType.warning(
-      "JSC_SUSPICIOUS_SEMICOLON",
-      "If this if/for/while really shouldn't have a body, use {}");
-
-  static final DiagnosticType SUSPICIOUS_COMPARISON_WITH_NAN =
-      DiagnosticType.warning(
-          "JSC_SUSPICIOUS_NAN",
-          "Comparison again NaN is always false. Did you mean isNaN()?");
-
-  CheckSuspiciousCode() {
-  }
-
-  @Override
-  public void visit(NodeTraversal t, Node n, Node parent) {
-    checkMissingSemicolon(t, n);
-    checkNaN(t, n);
-  }
-
-  private void checkMissingSemicolon(NodeTraversal t, Node n) {
-    switch (n.getType()) {
-      case Token.IF:
-        Node trueCase = n.getFirstChild().getNext();
-        reportIfWasEmpty(t, trueCase);
-        Node elseCase = trueCase.getNext();
-        if (elseCase != null) {
-          reportIfWasEmpty(t, elseCase);
-        }
-        break;
-
-      case Token.WHILE:
-      case Token.FOR:
-        reportIfWasEmpty(t, NodeUtil.getLoopCodeBlock(n));
-        break;
-    }
-  }
-
-  private void reportIfWasEmpty(NodeTraversal t, Node block) {
-    Preconditions.checkState(block.isBlock());
-
-    // A semicolon is distinguished from a block without children by
-    // annotating it with EMPTY_BLOCK.  Blocks without children are
-    // usually intentional, especially with loops.
-    if (!block.hasChildren() && block.wasEmptyNode()) {
-        t.getCompiler().report(
-            t.makeError(block, SUSPICIOUS_SEMICOLON));
-    }
-  }
-
-  private void checkNaN(NodeTraversal t, Node n) {
-    switch (n.getType()) {
-      case Token.EQ:
-      case Token.GE:
-      case Token.GT:
-      case Token.LE:
-      case Token.LT:
-      case Token.NE:
-      case Token.SHEQ:
-      case Token.SHNE:
-        reportIfNaN(t, n.getFirstChild());
-        reportIfNaN(t, n.getLastChild());
-    }
-  }
-
-  private void reportIfNaN(NodeTraversal t, Node n) {
-    if (NodeUtil.isNaN(n)) {
-      t.getCompiler().report(
-          t.makeError(n.getParent(), SUSPICIOUS_COMPARISON_WITH_NAN));
-    }
-  }
-}
diff --git a/src/com/google/javascript/jscomp/DefaultPassConfig.java b/src/com/google/javascript/jscomp/DefaultPassConfig.java
index 4d14f107f..d772443d0 100644
--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java
+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java
@@ -794,7 +794,7 @@ public class DefaultPassConfig extends PassConfig {
         compiler) {
       List<Callback> sharedCallbacks = Lists.newArrayList();
       if (options.checkSuspiciousCode) {
-        sharedCallbacks.add(new CheckSuspiciousCode());
+        sharedCallbacks.add(new CheckAccidentalSemicolon(CheckLevel.WARNING));
       }
 
       if (options.enables(DiagnosticGroups.GLOBAL_THIS)) {
diff --git a/src/com/google/javascript/jscomp/DiagnosticGroups.java b/src/com/google/javascript/jscomp/DiagnosticGroups.java
index a9eadb3f6..1ed2adb20 100644
--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java
+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java
@@ -82,8 +82,7 @@ public class DiagnosticGroups {
       "es5Strict, externsValidation, fileoverviewTags, globalThis, " +
       "internetExplorerChecks, invalidCasts, misplacedTypeAnnotation, " +
       "missingProperties, " +
-      "nonStandardJsDocs, suspiciousCode, strictModuleDepCheck, " +
-      "typeInvalidation, " +
+      "nonStandardJsDocs, strictModuleDepCheck, typeInvalidation, " +
       "undefinedNames, undefinedVars, unknownDefines, uselessCode, " +
       "visibility";
 
@@ -117,7 +116,7 @@ public class DiagnosticGroups {
       DiagnosticGroups.registerGroup("nonStandardJsDocs",
           RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
 
-  public static final DiagnosticGroup ACCESS_CONTROLS =
+  public static DiagnosticGroup ACCESS_CONTROLS =
       DiagnosticGroups.registerGroup("accessControls",
           DEPRECATED, VISIBILITY);
 
@@ -137,7 +136,7 @@ public class DiagnosticGroups {
       DiagnosticGroups.registerGroup("violatedModuleDep",
           VarCheck.VIOLATED_MODULE_DEP_ERROR);
 
-  public static final DiagnosticGroup EXTERNS_VALIDATION =
+  public static DiagnosticGroup EXTERNS_VALIDATION =
       DiagnosticGroups.registerGroup("externsValidation",
           VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR,
           VarCheck.UNDEFINED_EXTERN_VAR_ERROR);
@@ -160,6 +159,7 @@ public class DiagnosticGroups {
       DiagnosticGroups.registerGroup("missingProperties",
           TypeCheck.INEXISTENT_PROPERTY);
 
+  // TODO: add more IE specific checks here.
   public static final DiagnosticGroup INTERNET_EXPLORER_CHECKS =
       DiagnosticGroups.registerGroup("internetExplorerChecks",
           RhinoErrorReporter.TRAILING_COMMA);
@@ -238,11 +238,6 @@ public class DiagnosticGroups {
       DiagnosticGroups.registerGroup("cast",
           TypeValidator.INVALID_CAST);
 
-  public static final DiagnosticGroup SUSPICIOUS_CODE =
-      DiagnosticGroups.registerGroup("suspiciousCode",
-          CheckSuspiciousCode.SUSPICIOUS_SEMICOLON,
-          CheckSuspiciousCode.SUSPICIOUS_COMPARISON_WITH_NAN);
-
   /**
    * Adds warning levels by name.
    */
diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java
index 1c24d54e6..99fae8e05 100644
--- a/src/com/google/javascript/jscomp/NodeUtil.java
+++ b/src/com/google/javascript/jscomp/NodeUtil.java
@@ -118,7 +118,7 @@ public final class NodeUtil {
    * Gets the boolean value of a node that represents a literal. This method
    * effectively emulates the <code>Boolean()</code> JavaScript cast function
    * except it return UNKNOWN for known values with side-effects, use
-   * getImpureBooleanValue if you don't care about side-effects.
+   * getExpressionBooleanValue if you don't care about side-effects.
    */
   static TernaryValue getPureBooleanValue(Node n) {
     switch (n.getType()) {
@@ -3236,14 +3236,4 @@ public final class NodeUtil {
     }
     return result;
   }
-
-  static boolean isNaN(Node n) {
-    if ((n.isName() && n.getString().equals("NaN")) ||
-        (n.getType() == Token.DIV &&
-         n.getFirstChild().isNumber() && n.getFirstChild().getDouble() == 0 &&
-         n.getLastChild().isNumber() && n.getLastChild().getDouble() == 0)) {
-      return true;
-    }
-    return false;
-  }
 }
diff --git a/test/com/google/javascript/jscomp/CheckAccidentalSemicolonTest.java b/test/com/google/javascript/jscomp/CheckAccidentalSemicolonTest.java
new file mode 100644
index 000000000..911ee2f8e
--- /dev/null
+++ b/test/com/google/javascript/jscomp/CheckAccidentalSemicolonTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2006 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import com.google.javascript.jscomp.CheckLevel;
+
+public class CheckAccidentalSemicolonTest extends CompilerTestCase {
+  public CheckAccidentalSemicolonTest() {
+    this.parseTypeInfo = true;
+  }
+
+  @Override
+  protected CompilerPass getProcessor(Compiler compiler) {
+    return new CombinedCompilerPass(compiler,
+        new CheckAccidentalSemicolon(CheckLevel.ERROR));
+  }
+
+  public void test(String js, DiagnosticType error) {
+    test(js, error == null ? js : null, error);
+  }
+
+  public void testSuspiciousSemi() {
+    final DiagnosticType e = CheckAccidentalSemicolon.SUSPICIOUS_SEMICOLON;
+    final DiagnosticType ok = null;  //  code is 'ok', verify no warning
+
+    test("if(x()) x = y;", ok);
+    test("if(x()); x = y;", e);  // I've had this bug, damned ;
+    test("if(x()){} x = y;", ok);
+
+    test("if(x()) x = y; else y=z;", ok);
+    test("if(x()); else y=z;", e);
+    test("if(x()){} else y=z;", ok);
+    test("if(x()) x = y; else;", e);
+    test("if(x()) x = y; else {}", ok);
+
+    test("while(x()) x = y;", ok);
+    test("while(x()); x = y;", e);
+    test("while(x()){} x = y;", ok);
+    test("while(x()); {x = y}", e);
+    test("while(x()){} {x = y}", ok);
+
+    test("for(;;) x = y;", ok);
+    test("for(;;); x = y;", e);
+    test("for(;;){} x = y;", ok);
+    test("for(x in y) x = y;", ok);
+    test("for(x in y); x = y;", e);
+    test("for(x in y){} x = y;", ok);
+  }
+
+}
diff --git a/test/com/google/javascript/jscomp/CheckSuspiciousCodeTest.java b/test/com/google/javascript/jscomp/CheckSuspiciousCodeTest.java
deleted file mode 100644
index 419bc2938..000000000
--- a/test/com/google/javascript/jscomp/CheckSuspiciousCodeTest.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright 2012 The Closure Compiler Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.javascript.jscomp;
-
-/**
- * Tests for CheckSuspiciousCode
- */
-public class CheckSuspiciousCodeTest extends CompilerTestCase {
-  public CheckSuspiciousCodeTest() {
-    this.parseTypeInfo = true;
-  }
-
-  @Override
-  protected CompilerPass getProcessor(Compiler compiler) {
-    return new CombinedCompilerPass(compiler,
-        new CheckSuspiciousCode());
-  }
-
-  @Override
-  protected int getNumRepetitions() {
-    return 1;
-  }
-
-  public void test(String js, DiagnosticType error) {
-    test(js, js, null, error);
-  }
-
-  public void testSuspiciousSemi() {
-    final DiagnosticType e = CheckSuspiciousCode.SUSPICIOUS_SEMICOLON;
-    final DiagnosticType ok = null;  //  code is 'ok', verify no warning
-
-    test("if(x()) x = y;", ok);
-    test("if(x()); x = y;", e);  // I've had this bug, damned ;
-    test("if(x()){} x = y;", ok);
-
-    test("if(x()) x = y; else y=z;", ok);
-    test("if(x()); else y=z;", e);
-    test("if(x()){} else y=z;", ok);
-    test("if(x()) x = y; else;", e);
-    test("if(x()) x = y; else {}", ok);
-
-    test("while(x()) x = y;", ok);
-    test("while(x()); x = y;", e);
-    test("while(x()){} x = y;", ok);
-    test("while(x()); {x = y}", e);
-    test("while(x()){} {x = y}", ok);
-
-    test("for(;;) x = y;", ok);
-    test("for(;;); x = y;", e);
-    test("for(;;){} x = y;", ok);
-    test("for(x in y) x = y;", ok);
-    test("for(x in y); x = y;", e);
-    test("for(x in y){} x = y;", ok);
-  }
-
-  private void testReportNaN(String js) {
-    testSame(js, CheckSuspiciousCode.SUSPICIOUS_COMPARISON_WITH_NAN);
-  }
-
-  public void testComparison1() {
-    testReportNaN("x == NaN");
-    testReportNaN("x != NaN");
-    testReportNaN("x === NaN");
-    testReportNaN("x !== NaN");
-    testReportNaN("x < NaN");
-    testReportNaN("x <= NaN");
-    testReportNaN("x > NaN");
-    testReportNaN("x >= NaN");
-  }
-
-  public void testComparison2() {
-    testReportNaN("NaN == x");
-    testReportNaN("NaN != x");
-    testReportNaN("NaN === x");
-    testReportNaN("NaN !== x");
-    testReportNaN("NaN < x");
-    testReportNaN("NaN <= x");
-    testReportNaN("NaN > x");
-    testReportNaN("NaN >= x");
-  }
-
-  public void testComparison3() {
-    testReportNaN("x == 0/0");
-    testReportNaN("x != 0/0");
-    testReportNaN("x === 0/0");
-    testReportNaN("x !== 0/0");
-    testReportNaN("x < 0/0");
-    testReportNaN("x <= 0/0");
-    testReportNaN("x > 0/0");
-    testReportNaN("x >= 0/0");
-  }
-
-  public void testComparison4() {
-    testReportNaN("0/0 == x");
-    testReportNaN("0/0 != x");
-    testReportNaN("0/0 === x");
-    testReportNaN("0/0 !== x");
-    testReportNaN("0/0 < x");
-    testReportNaN("0/0 <= x");
-    testReportNaN("0/0 > x");
-    testReportNaN("0/0 >= x");
-  }
-}
diff --git a/test/com/google/javascript/jscomp/NodeUtilTest.java b/test/com/google/javascript/jscomp/NodeUtilTest.java
index 8790308e9..64e3c9dbf 100644
--- a/test/com/google/javascript/jscomp/NodeUtilTest.java
+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java
@@ -21,7 +21,6 @@ import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
-import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.TernaryValue;
@@ -31,9 +30,6 @@ import junit.framework.TestCase;
 import java.util.Collection;
 import java.util.Set;
 
-/**
- * Tests for NodeUtil
- */
 public class NodeUtilTest extends TestCase {
 
   private static Node parse(String js) {
@@ -331,10 +327,10 @@ public class NodeUtilTest extends TestCase {
     assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild()));
   }
 
-  private void assertSideEffect(boolean se, String js, boolean globalRegExp) {
+  private void assertSideEffect(boolean se, String js, boolean GlobalRegExp) {
     Node n = parse(js);
     Compiler compiler = new Compiler();
-    compiler.setHasRegExpGlobalReferences(globalRegExp);
+    compiler.setHasRegExpGlobalReferences(GlobalRegExp);
     assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild(), compiler));
   }
 
@@ -680,7 +676,7 @@ public class NodeUtilTest extends TestCase {
     assertNodeNames(Sets.newHashSet("foo"),
         NodeUtil.getVarsDeclaredInBranch(
             parse("var foo;")));
-    assertNodeNames(Sets.newHashSet("foo", "goo"),
+    assertNodeNames(Sets.newHashSet("foo","goo"),
         NodeUtil.getVarsDeclaredInBranch(
             parse("var foo,goo;")));
     assertNodeNames(Sets.<String>newHashSet(),
@@ -1269,7 +1265,7 @@ public class NodeUtilTest extends TestCase {
   }
 
   private boolean testValidDefineValue(String js) {
-    Node script = parse("var test = " + js + ";");
+    Node script = parse("var test = " + js +";");
     Node var = script.getFirstChild();
     Node name = var.getFirstChild();
     Node value = name.getFirstChild();
@@ -1599,16 +1595,6 @@ public class NodeUtilTest extends TestCase {
     assertEquals("x", getFunctionLValue("var x = (y, function() {});"));
   }
 
-  public void testIsNaN() {
-    assertEquals(true, NodeUtil.isNaN(getNode("NaN")));
-    assertEquals(false, NodeUtil.isNaN(getNode("Infinity")));
-    assertEquals(false, NodeUtil.isNaN(getNode("x")));
-    assertEquals(true, NodeUtil.isNaN(getNode("0/0")));
-    assertEquals(false, NodeUtil.isNaN(getNode("1/0")));
-    assertEquals(false, NodeUtil.isNaN(getNode("0/1")));
-    assertEquals(false, NodeUtil.isNaN(IR.number(0.0)));
-  }
-
   public void testIsExecutedExactlyOnce() {
     assertEquals(true, executedOnceTestCase("x;"));
 
