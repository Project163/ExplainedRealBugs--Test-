diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java
index 3e4a0a6f8..992c9285f 100644
--- a/src/com/google/javascript/jscomp/CodeGenerator.java
+++ b/src/com/google/javascript/jscomp/CodeGenerator.java
@@ -437,14 +437,20 @@ class CodeGenerator {
       }
 
       case Token.CALL:
-        // If the left hand side of the call is a direct reference to eval,
+        // We have two special cases here:
+        // 1) If the left hand side of the call is a direct reference to eval,
         // then it must have a DIRECT_EVAL annotation. If it does not, then
         // that means it was originally an indirect call to eval, and that
         // indirectness must be preserved.
-        if (first.getType() == Token.NAME &&
-            "eval".equals(first.getString()) &&
-            !first.getBooleanProp(Node.DIRECT_EVAL)) {
-          add("(0,eval)");
+        // 2) If the left hand side of the call is a property reference,
+        // then the call must not a FREE_CALL annotation. If it does, then
+        // that means it was originally an call without an explicit this and
+        // that must be preserved.
+        if (isIndirectEval(first)
+            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
+          add("(0,");
+          addExpr(first, NodeUtil.precedence(Token.COMMA));
+          add(")");
         } else {
           addLeftExpr(first, NodeUtil.precedence(type), context);
         }
@@ -641,6 +647,14 @@ class CodeGenerator {
     cc.endSourceMapping(n);
   }
 
+  /**
+   * @return Whether the name is an indirect eval.
+   */
+  private boolean isIndirectEval(Node n) {
+    return n.getType() == Token.NAME && "eval".equals(n.getString()) &&
+        !n.getBooleanProp(Node.DIRECT_EVAL);
+  }
+
   /**
    * Adds a block or expression, substituting a VOID with an empty statement.
    * This is used for "for (...);" and "if (...);" type statements.
diff --git a/src/com/google/javascript/jscomp/PrepareAst.java b/src/com/google/javascript/jscomp/PrepareAst.java
index c3e35ab3c..1738b9597 100644
--- a/src/com/google/javascript/jscomp/PrepareAst.java
+++ b/src/com/google/javascript/jscomp/PrepareAst.java
@@ -137,8 +137,65 @@ class PrepareAst implements CompilerPass {
       this.convention = compiler.getCodingConvention();
     }
 
+    public void visit(NodeTraversal t, Node n, Node parent) {
+      switch (n.getType()) {
+        case Token.CALL:
+          annotateCalls(n);
+          break;
+
+        case Token.FUNCTION:
+          annotateFunctions(n, parent);
+          annotateDispatchers(n, parent);
+          break;
+
+        case Token.NAME:
+        case Token.STRING:
+          annotateConstants(n, parent);
+          break;
+
+        case Token.OBJECTLIT:
+          normalizeObjectLitJsDocs(n);
+          break;
+      }
+    }
+
+    /**
+     * There are two types of calls we are interested in calls without explicit
+     * "this" values (what we are call "free" calls) and direct call to eval.
+     */
+    private void annotateCalls(Node n) {
+      Preconditions.checkState(n.getType() == Token.CALL);
+
+      // Keep track of of the "this" context of a call.  A call without an
+      // explicit "this" is a free call.
+      Node first = n.getFirstChild();
+      if (!NodeUtil.isGet(first)) {
+        n.putBooleanProp(Node.FREE_CALL, true);
+      }
+
+      // Keep track of the context in which eval is called. It is important
+      // to distinguish between "(0, eval)()" and "eval()".
+      if (first.getType() == Token.NAME &&
+          "eval".equals(first.getString())) {
+        first.putBooleanProp(Node.DIRECT_EVAL, true);
+      }
+    }
+
+    /**
+     * Translate dispatcher info into the property expected node.
+     */
+    private void annotateDispatchers(Node n, Node parent) {
+      Preconditions.checkState(n.getType() == Token.FUNCTION);
+      if (parent.getJSDocInfo() != null
+          && parent.getJSDocInfo().isJavaDispatch()) {
+        if (parent.getType() == Token.ASSIGN) {
+          Preconditions.checkState(parent.getLastChild() == n);
+          n.putBooleanProp(Node.IS_DISPATCHER, true);
+        }
+      }
+    }
+
     /**
-     *
      * In the AST that Rhino gives us, it needs to make a distinction
      * between jsdoc on the object literal node and jsdoc on the object literal
      * value. For example,
@@ -153,92 +210,74 @@ class PrepareAst implements CompilerPass {
      * But in few narrow cases (in particular, function literals), it's
      * a lot easier for us if the doc is attached to the value.
      */
-    @SuppressWarnings("fallthrough")
-    public void visit(NodeTraversal t, Node n, Node parent) {
-      int nType = n.getType();
-      switch (nType) {
-        case Token.STRING:
-          // There are only two cases where a string token
-          // may be a variable reference: The right side of a GETPROP
-          // or an OBJECTLIT key.
-          if (parent.getType() != Token.OBJECTLIT &&
-              parent.getType() != Token.GETPROP) {
-            break;
-          }
-          // fall-through
-
-        case Token.NAME:
-          String nString = n.getString();
-          if (nType == Token.NAME &&
-              n.getParent().getType() == Token.CALL &&
-              "eval".equals(nString)) {
-            n.putBooleanProp(Node.DIRECT_EVAL, true);
-          }
-          if (NodeUtil.isConstantByConvention(convention, n, parent)) {
-            n.putBooleanProp(Node.IS_CONSTANT_NAME, true);
-          }
-          break;
+    private void normalizeObjectLitJsDocs(Node n) {
+      Preconditions.checkState(n.getType() == Token.OBJECTLIT);
+      for (Node key = n.getFirstChild();
+           key != null; key = key.getNext().getNext()) {
+        Node value = key.getNext();
+        if (key.getJSDocInfo() != null &&
+            key.getNext().getType() == Token.FUNCTION) {
+          value.setJSDocInfo(key.getJSDocInfo());
+        }
+      }
+    }
 
-        case Token.FUNCTION:
-          JSDocInfo fnInfo = n.getJSDocInfo();
-          if (fnInfo == null) {
-            // Look for the info on other nodes.
-            if (parent.getType() == Token.ASSIGN) {
-              // on ASSIGNs
-              fnInfo = parent.getJSDocInfo();
-            } else if (parent.getType() == Token.NAME) {
-              // on var NAME = function() { ... };
-              fnInfo = parent.getParent().getJSDocInfo();
-            }
-          }
+    /**
+     * Mark names that are constants by convention.
+     */
+    private void annotateConstants(Node n, Node parent) {
+      Preconditions.checkState(
+          n.getType() == Token.NAME || n.getType() == Token.STRING);
 
-          // Compute which function parameters are optional and
-          // which are var_args.
-          Node args = n.getFirstChild().getNext();
-          for (Node arg = args.getFirstChild();
-               arg != null;
-               arg = arg.getNext()) {
-            String argName = arg.getString();
-            JSTypeExpression typeExpr = fnInfo == null ?
-                null : fnInfo.getParameterType(argName);
-
-            if (convention.isOptionalParameter(arg) ||
-                typeExpr != null && typeExpr.isOptionalArg()) {
-              arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);
-            }
-            if (convention.isVarArgsParameter(arg) ||
-                typeExpr != null && typeExpr.isVarArgs()) {
-              arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);
-            }
-          }
-          break;
+      // There are only two cases where a string token
+      // may be a variable reference: The right side of a GETPROP
+      // or an OBJECTLIT key.
+      if (n.getType() != Token.STRING
+          || parent.getType() == Token.OBJECTLIT
+          || parent.getType() == Token.GETPROP) {
+        if (NodeUtil.isConstantByConvention(convention, n, parent)) {
+          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);
+        }
+      }
+    }
 
-        case Token.OBJECTLIT:
-          if (n.getType() == Token.OBJECTLIT) {
-            for (Node key = n.getFirstChild();
-                 key != null; key = key.getNext().getNext()) {
-              Node value = key.getNext();
-              if (key.getJSDocInfo() != null &&
-                  key.getNext().getType() == Token.FUNCTION) {
-                value.setJSDocInfo(key.getJSDocInfo());
-              }
-            }
-          }
-          break;
+    /**
+     * Annotate optional and var_arg function parameters.
+     */
+    private void annotateFunctions(Node n, Node parent) {
+      Preconditions.checkState(n.getType() == Token.FUNCTION);
+      JSDocInfo fnInfo = n.getJSDocInfo();
+      if (fnInfo == null) {
+        // Look for the info on other nodes.
+        if (parent.getType() == Token.ASSIGN) {
+          // on ASSIGNs
+          fnInfo = parent.getJSDocInfo();
+        } else if (parent.getType() == Token.NAME) {
+          // on var NAME = function() { ... };
+          fnInfo = parent.getParent().getJSDocInfo();
+        }
       }
 
-      // TODO(johnlenz): Determine if it is possible to simply use the javadoc
-      // everywhere rather than use IS_DISPATCHER.
-      /*
-       * Translate dispatcher info into the property expected node.
-       */
-      if (n.getJSDocInfo() != null && n.getJSDocInfo().isJavaDispatch()) {
-        if (n.getType() == Token.ASSIGN) {
-          Node fnNode = n.getLastChild();
-          Preconditions.checkState(fnNode.getType() == Token.FUNCTION);
-          fnNode.putBooleanProp(Node.IS_DISPATCHER, true);
+      // Compute which function parameters are optional and
+      // which are var_args.
+      Node args = n.getFirstChild().getNext();
+      for (Node arg = args.getFirstChild();
+           arg != null;
+           arg = arg.getNext()) {
+        String argName = arg.getString();
+        JSTypeExpression typeExpr = fnInfo == null ?
+            null : fnInfo.getParameterType(argName);
+
+        if (convention.isOptionalParameter(arg) ||
+            typeExpr != null && typeExpr.isOptionalArg()) {
+          arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);
+        }
+        if (convention.isVarArgsParameter(arg) ||
+            typeExpr != null && typeExpr.isVarArgs()) {
+          arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);
         }
       }
     }
+
   }
 }
diff --git a/src/com/google/javascript/rhino/Node.java b/src/com/google/javascript/rhino/Node.java
index c6735ced0..c2a983214 100644
--- a/src/com/google/javascript/rhino/Node.java
+++ b/src/com/google/javascript/rhino/Node.java
@@ -153,7 +153,9 @@ public class Node implements Cloneable, Serializable {
       SUPPRESSIONS       = 50,    // Used by the compiler to associate
                                   // @suppress directly with functions
                                   // and scripts.
-      LAST_PROP          = 50;
+      FREE_CALL          = 51,    // A CALL without an explicit "this" value.
+                                  //
+      LAST_PROP          = 51;
 
   // values of ISNUMBER_PROP to specify
   // which of the children are Number types
@@ -235,6 +237,7 @@ public class Node implements Cloneable, Serializable {
         case IS_DISPATCHER:      return "is_dispatcher";
         case DIRECTIVES:         return "directives";
         case DIRECT_EVAL:        return "direct_eval";
+        case FREE_CALL:          return "free_call";
         default:
           Kit.codeBug();
       }
diff --git a/test/com/google/javascript/jscomp/CodePrinterTest.java b/test/com/google/javascript/jscomp/CodePrinterTest.java
index 8d0dbe0d7..e519bb95a 100644
--- a/test/com/google/javascript/jscomp/CodePrinterTest.java
+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java
@@ -930,7 +930,7 @@ public class CodePrinterTest extends TestCase {
 
     assertPrint("if(x)A:do{foo()}while(y);",
         "if(x){A:do foo();while(y)}");
-    
+
     assertPrint("var i = 0;a: do{b: do{i++;break b;} while(0);} while(0);",
         "var i=0;a:do{b:do{i++;break b}while(0)}while(0)");
   }
@@ -995,4 +995,27 @@ public class CodePrinterTest extends TestCase {
         Node.DIRECT_EVAL, false);
     assertPrintNode("(0,eval)(\"1\")", n);
   }
+
+  public void testFreeCall1() {
+    assertPrint("foo(a);", "foo(a)");
+    assertPrint("x.foo(a);", "x.foo(a)");
+  }
+
+  public void testFreeCall2() {
+    Node n = parse("foo(a);");
+    assertPrintNode("foo(a)", n);
+    Node call =  n.getFirstChild().getFirstChild();
+    assertTrue(call.getType() == Token.CALL);
+    call.putBooleanProp(Node.FREE_CALL, true);
+    assertPrintNode("foo(a)", n);
+  }
+
+  public void testFreeCall3() {
+    Node n = parse("x.foo(a);");
+    assertPrintNode("x.foo(a)", n);
+    Node call =  n.getFirstChild().getFirstChild();
+    assertTrue(call.getType() == Token.CALL);
+    call.putBooleanProp(Node.FREE_CALL, true);
+    assertPrintNode("(0,x.foo)(a)", n);
+  }
 }
diff --git a/test/com/google/javascript/jscomp/PrepareAstTest.java b/test/com/google/javascript/jscomp/PrepareAstTest.java
index 94e3e6220..146f67e63 100644
--- a/test/com/google/javascript/jscomp/PrepareAstTest.java
+++ b/test/com/google/javascript/jscomp/PrepareAstTest.java
@@ -16,6 +16,7 @@
 
 package com.google.javascript.jscomp;
 
+import com.google.common.base.Preconditions;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
@@ -53,4 +54,26 @@ public class PrepareAstTest extends CompilerTestCase {
     assertNull(secondKey.getJSDocInfo());
     assertNotNull(secondVal.getJSDocInfo());
   }
+
+  public void testFreeCall1() throws Exception {
+    Node root = parseExpectedJs("foo();");
+    Node script = root.getFirstChild();
+    Preconditions.checkState(script.getType() == Token.SCRIPT);
+    Node firstExpr = script.getFirstChild();
+    Node call = firstExpr.getFirstChild();
+    Preconditions.checkState(call.getType() == Token.CALL);
+
+    assertTrue(call.getBooleanProp(Node.FREE_CALL));
+  }
+
+  public void testFreeCall2() throws Exception {
+    Node root = parseExpectedJs("x.foo();");
+    Node script = root.getFirstChild();
+    Preconditions.checkState(script.getType() == Token.SCRIPT);
+    Node firstExpr = script.getFirstChild();
+    Node call = firstExpr.getFirstChild();
+    Preconditions.checkState(call.getType() == Token.CALL);
+
+    assertFalse(call.getBooleanProp(Node.FREE_CALL));
+  }
 }
