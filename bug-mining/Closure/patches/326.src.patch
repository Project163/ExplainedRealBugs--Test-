diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
index b60aa90c2..f85c97081 100644
--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
@@ -134,21 +134,22 @@ public final class JsDocInfoParser {
     this(stream,
         commentNode != null ? commentNode.getValue() : null,
         commentNode != null ? commentNode.getPosition() : 0,
-        associatedNode, config, errorReporter);
+        associatedNode,
+        associatedNode != null ? associatedNode.getStaticSourceFile() : null,
+        config, errorReporter);
   }
 
   JsDocInfoParser(JsDocTokenStream stream,
                   String comment,
                   int commentPosition,
                   Node associatedNode,
+                  StaticSourceFile sourceFile,
                   Config config,
                   ErrorReporter errorReporter) {
     this.stream = stream;
-    this.associatedNode = associatedNode;
 
-    // Sometimes this will be null in tests.
-    this.sourceFile = associatedNode == null
-        ? null : associatedNode.getStaticSourceFile();
+    this.associatedNode = associatedNode;
+    this.sourceFile = sourceFile;
 
     this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);
     if (comment != null) {
@@ -2405,9 +2406,7 @@ public final class JsDocInfoParser {
     // The Node type choice is arbitrary.
     Node templateNode = IR.script();
     templateNode.setStaticSourceFile(
-      this.associatedNode != null ?
-      this.associatedNode.getStaticSourceFile() :
-      null);
+      this.sourceFile);
     return templateNode;
   }
 
diff --git a/src/com/google/javascript/jscomp/parsing/NewIRFactory.java b/src/com/google/javascript/jscomp/parsing/NewIRFactory.java
index caec549ab..3659d8084 100644
--- a/src/com/google/javascript/jscomp/parsing/NewIRFactory.java
+++ b/src/com/google/javascript/jscomp/parsing/NewIRFactory.java
@@ -17,9 +17,11 @@
 package com.google.javascript.jscomp.parsing;
 
 import com.google.common.base.Preconditions;
-import com.google.common.collect.Lists;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
+import com.google.common.collect.UnmodifiableIterator;
 import com.google.javascript.jscomp.parsing.Config.LanguageMode;
 import com.google.javascript.jscomp.parsing.parser.IdentifierToken;
 import com.google.javascript.jscomp.parsing.parser.LiteralToken;
@@ -43,6 +45,7 @@ import com.google.javascript.jscomp.parsing.parser.trees.ExpressionStatementTree
 import com.google.javascript.jscomp.parsing.parser.trees.FinallyTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ForInStatementTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ForStatementTree;
+import com.google.javascript.jscomp.parsing.parser.trees.FormalParameterListTree;
 import com.google.javascript.jscomp.parsing.parser.trees.FunctionDeclarationTree;
 import com.google.javascript.jscomp.parsing.parser.trees.GetAccessorTree;
 import com.google.javascript.jscomp.parsing.parser.trees.IdentifierExpressionTree;
@@ -73,6 +76,8 @@ import com.google.javascript.jscomp.parsing.parser.trees.VariableDeclarationTree
 import com.google.javascript.jscomp.parsing.parser.trees.VariableStatementTree;
 import com.google.javascript.jscomp.parsing.parser.trees.WhileStatementTree;
 import com.google.javascript.jscomp.parsing.parser.trees.WithStatementTree;
+import com.google.javascript.jscomp.parsing.parser.util.SourcePosition;
+import com.google.javascript.jscomp.parsing.parser.util.SourceRange;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.JSDocInfo;
 import com.google.javascript.rhino.Node;
@@ -115,6 +120,9 @@ class NewIRFactory {
       "If you are targeting newer versions of JavaScript, " +
       "set the appropriate language_in option.";
 
+  static final String INVALID_ES5_STRICT_OCTAL =
+      "Octal integer literals are not supported in Ecmascript 5 strict mode.";
+
   private final String sourceString;
   private final List<Integer> newlines;
   private final StaticSourceFile sourceFile;
@@ -151,11 +159,18 @@ class NewIRFactory {
   // memory footprint associated with these.
   private final Node templateNode;
 
+  private final UnmodifiableIterator<Comment> nextCommentIter;
+
+  private Comment currentComment;
+
   private NewIRFactory(String sourceString,
                     StaticSourceFile sourceFile,
                     Config config,
-                    ErrorReporter errorReporter) {
+                    ErrorReporter errorReporter,
+                    ImmutableList<Comment> comments) {
     this.sourceString = sourceString;
+    this.nextCommentIter = comments.iterator();
+    this.currentComment = nextCommentIter.hasNext() ? nextCommentIter.next() : null;
     this.newlines = Lists.newArrayList();
     this.sourceFile = sourceFile;
 
@@ -202,20 +217,23 @@ class NewIRFactory {
     return templateNode;
   }
 
-  public static Node transformTree(ProgramTree node,
+  public static Node transformTree(ProgramTree tree,
                                    StaticSourceFile sourceFile,
                                    String sourceString,
                                    Config config,
                                    ErrorReporter errorReporter) {
     NewIRFactory irFactory = new NewIRFactory(sourceString, sourceFile,
-        config, errorReporter);
-    Node irNode = irFactory.transform(node);
+        config, errorReporter, tree.sourceComments);
+
+    // don't call transform as we don't want standard jsdoc handling.
+    Node irNode = irFactory.justTransform(tree);
+    irFactory.setSourceInfo(irNode, tree);
 
-    if (node.sourceComments != null) {
-      for (Comment comment : node.sourceComments) {
+    if (tree.sourceComments != null) {
+      for (Comment comment : tree.sourceComments) {
         if (comment.type == Comment.Type.JSDOC &&
             !irFactory.parsedComments.contains(comment)) {
-          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);
+          irFactory.handlePossibleFileOverviewJsDoc(comment);
         } else if (comment.type == Comment.Type.BLOCK) {
           irFactory.handleBlockComment(comment);
         }
@@ -255,9 +273,7 @@ class NewIRFactory {
         irNode.setWasEmptyNode(true);
       } else {
         Node newBlock = newNode(Token.BLOCK, irNode);
-        newBlock.setLineno(irNode.getLineno());
-        newBlock.setCharno(irNode.getCharno());
-        maybeSetLengthFrom(newBlock, node);
+        setSourceInfo(newBlock, irNode);
         irNode = newBlock;
       }
     }
@@ -289,34 +305,46 @@ class NewIRFactory {
     return false;
   }
 
-  private void handlePossibleFileOverviewJsDoc(Comment comment, Node irNode) {
-    JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);
+  private void handlePossibleFileOverviewJsDoc(Comment comment) {
+    JsDocInfoParser jsDocParser = createJsDocInfoParser(comment);
     parsedComments.add(comment);
     handlePossibleFileOverviewJsDoc(jsDocParser);
   }
 
-  private Comment getJsDocNode(ParseTree tree) {
-    Preconditions.checkNotNull(tree);
-    // TODO(johnlenz): enable associating comments with parse trees.
-    return null;
+  private Comment getJsDoc(SourceRange location) {
+    Comment closestPreviousComment = null;
+    while (currentComment != null &&
+        currentComment.location.end.offset <= location.start.offset) {
+      closestPreviousComment = currentComment;
+      if (this.nextCommentIter.hasNext()) {
+        currentComment = this.nextCommentIter.next();
+      } else {
+        currentComment = null;
+      }
+    }
+
+    return (closestPreviousComment != null
+        && closestPreviousComment.type == Comment.Type.JSDOC)
+        ? closestPreviousComment : null;
+  }
+
+  private Comment getJsDoc(ParseTree tree) {
+    return getJsDoc(tree.location);
   }
 
-  private Comment getJsDocNode(
+  private Comment getJsDoc(
       com.google.javascript.jscomp.parsing.parser.Token token) {
-    Preconditions.checkNotNull(token);
-    // TODO(johnlenz): enable associating comments with parse trees.
-    return null;
+    return getJsDoc(token.location);
   }
 
-  private JSDocInfo handleJsDoc(ParseTree node, Node irNode) {
-    Comment comment = getJsDocNode(node);
+  private JSDocInfo handleJsDoc(Comment comment) {
     if (comment != null) {
-      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);
+      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment);
       parsedComments.add(comment);
       if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {
         JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();
         if (info != null) {
-          validateTypeAnnotations(info, node);
+          // validateTypeAnnotations(info, node);
         }
         return info;
       }
@@ -324,22 +352,16 @@ class NewIRFactory {
     return null;
   }
 
-  private JSDocInfo handleJsDoc(
-      com.google.javascript.jscomp.parsing.parser.Token token, Node irNode) {
-    Comment comment = getJsDocNode(token);
-    if (comment != null) {
-      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);
-      parsedComments.add(comment);
-      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {
-        JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();
-        if (info != null) {
-          // Associate JSDoc with tokens?
-          // validateTypeAnnotations(info, token);
-        }
-        return info;
-      }
+  private JSDocInfo handleJsDoc(ParseTree node) {
+    if (node.type == ParseTreeType.EXPRESSION_STATEMENT) {
+      return null;
     }
-    return null;
+    return handleJsDoc(getJsDoc(node));
+  }
+
+  private JSDocInfo handleJsDoc(
+      com.google.javascript.jscomp.parsing.parser.Token token) {
+    return handleJsDoc(getJsDoc(token));
   }
 
   static final boolean ENABLE_TYPE_ANNOTATION_CHECKS = false;
@@ -436,15 +458,41 @@ class NewIRFactory {
         || node.type == ParseTreeType.MEMBER_LOOKUP_EXPRESSION;
   }
 
-  private Node transform(ParseTree node) {
-    Node irNode = justTransform(node);
-    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);
-    if (jsDocInfo != null) {
-      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);
-      irNode.setJSDocInfo(jsDocInfo);
+  private Node transform(ParseTree tree) {
+    JSDocInfo info = handleJsDoc(tree);
+    Node node = justTransform(tree);
+    if (info != null) {
+      validateTypeAnnotations(info, tree);
+      node = maybeInjectCastNode(tree, info, node);
+      attachJSDoc(info, node);
+    }
+    setSourceInfo(node, tree);
+    return node;
+  }
+
+  private void attachJSDoc(JSDocInfo info, Node n) {
+    switch (n.getType()) {
+      case Token.EXPR_RESULT:
+        attachJSDoc(info, n.getFirstChild());
+        break;
+      case Token.LABEL:
+        attachJSDoc(info, n.getLastChild());
+        break;
+      case Token.THROW:
+      case Token.RETURN:
+      case Token.IF:
+      case Token.DO:
+      case Token.FOR:
+      case Token.WHILE:
+      case Token.SWITCH:
+      case Token.CASE:
+      case Token.DEFAULT_CASE:
+        break;
+
+      default:
+        n.setJSDocInfo(info);
+        break;
     }
-    setSourceInfo(irNode, node);
-    return irNode;
   }
 
   private Node maybeInjectCastNode(ParseTree node, JSDocInfo info, Node irNode) {
@@ -465,24 +513,42 @@ class NewIRFactory {
    * @see <a href="http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs">
    *   Using Inline Doc Comments</a>
    */
-  private Node transformNodeWithInlineJsDoc(ParseTree node) {
+  private Node transformNodeWithInlineJsDoc(
+      ParseTree node, boolean optionalInline) {
+    JSDocInfo info = handleInlineJsDoc(node, optionalInline);
     Node irNode = justTransform(node);
-    Comment comment = getJsDocNode(node);
-    if (comment != null) {
-      JSDocInfo info = parseInlineTypeDoc(comment, irNode);
-      if (info != null) {
-        irNode.setJSDocInfo(info);
-      }
+    if (info != null) {
+      irNode.setJSDocInfo(info);
     }
     setSourceInfo(irNode, node);
     return irNode;
   }
 
+  private JSDocInfo handleInlineJsDoc(ParseTree node, boolean optional) {
+    return handleInlineJsDoc(node.location, optional);
+  }
+
+  private JSDocInfo handleInlineJsDoc(
+      com.google.javascript.jscomp.parsing.parser.Token token,
+      boolean optional) {
+    return handleInlineJsDoc(token.location, optional);
+  }
+
+  private JSDocInfo handleInlineJsDoc(
+      SourceRange location,
+      boolean optional) {
+    Comment comment = getJsDoc(location);
+    if (comment != null && (!optional || !comment.value.contains("@"))) {
+      return parseInlineTypeDoc(comment);
+    } else {
+      return handleJsDoc(comment);
+    }
+  }
+
   private Node transformNumberAsString(LiteralToken token) {
-    // TODO(johnlenz): parse number value correctly
-    double value = Double.valueOf(token.toString());
+    double value = normalizeNumber(token);
     Node irNode = newStringNode(getStringValue(value));
-    JSDocInfo jsDocInfo = handleJsDoc(token, irNode);
+    JSDocInfo jsDocInfo = handleJsDoc(token);
     if (jsDocInfo != null) {
       irNode.setJSDocInfo(jsDocInfo);
     }
@@ -503,51 +569,59 @@ class NewIRFactory {
 
   private int lineno(ParseTree node) {
     // location lines start at zero, our AST starts at 1.
-    return node.location.start.line + 1;
+    return lineno(node.location.start);
   }
 
   private int charno(ParseTree node) {
-    return node.location.start.column;
+    return charno(node.location.start);
   }
 
   private int lineno(com.google.javascript.jscomp.parsing.parser.Token token) {
     // location lines start at zero, our AST starts at 1.
-    return token.location.start.line + 1;
+    return lineno(token.location.start);
   }
 
   private int charno(com.google.javascript.jscomp.parsing.parser.Token token) {
-    return token.location.start.column;
+    return charno(token.location.start);
+  }
+
+  private int lineno(SourcePosition location) {
+    // location lines start at zero, our AST starts at 1.
+    return location.line + 1;
+  }
+
+  private int charno(SourcePosition location) {
+    return location.column;
+  }
+
+  private void setSourceInfo(Node node, Node ref) {
+    node.setLineno(ref.getLineno());
+    node.setCharno(ref.getCharno());
+    maybeSetLengthFrom(node, ref);
   }
 
   private void setSourceInfo(Node irNode, ParseTree node) {
     if (irNode.getLineno() == -1) {
-      // TODO(johnlenz): remove this check
-      if (node.location == null || node.location.start == null) {
-        return;
-      }
-
-      // If we didn't already set the line, then set it now. This avoids
-      // cases like ParenthesizedExpression where we just return a previous
-      // node, but don't want the new node to get its parent's line number.
-      int lineno = lineno(node);
-      irNode.setLineno(lineno);
-      int charno = charno(node);
-      irNode.setCharno(charno);
-      maybeSetLengthFrom(irNode, node);
+      setSourceInfo(irNode, node.location.start, node.location.end);
     }
   }
 
   private void setSourceInfo(
       Node irNode, com.google.javascript.jscomp.parsing.parser.Token token) {
-    if (irNode.getLineno() == -1) {
+    setSourceInfo(irNode, token.location.start, token.location.end);
+  }
+
+  private void setSourceInfo(
+      Node node, SourcePosition start, SourcePosition end) {
+    if (node.getLineno() == -1) {
       // If we didn't already set the line, then set it now. This avoids
       // cases like ParenthesizedExpression where we just return a previous
       // node, but don't want the new node to get its parent's line number.
-      int lineno = lineno(token);
-      irNode.setLineno(lineno);
-      int charno = charno(token);
-      irNode.setCharno(charno);
-      maybeSetLengthFrom(irNode, token);
+      int lineno = lineno(start);
+      node.setLineno(lineno);
+      int charno = charno(start);
+      node.setCharno(charno);
+      maybeSetLength(node, start, end);
     }
   }
 
@@ -562,7 +636,7 @@ class NewIRFactory {
    * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or
    *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).
    */
-  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {
+  private JsDocInfoParser createJsDocInfoParser(Comment node) {
     String comment = node.value;
     int lineno = node.location.start.line;
     int charno = node.location.start.column;
@@ -577,7 +651,8 @@ class NewIRFactory {
                                charno + numOpeningChars),
           comment,
           position,
-          irNode,
+          null,
+          sourceFile,
           config,
           errorReporter);
     jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);
@@ -589,7 +664,7 @@ class NewIRFactory {
   /**
    * Parses inline type info.
    */
-  private JSDocInfo parseInlineTypeDoc(Comment node, Node irNode) {
+  private JSDocInfo parseInlineTypeDoc(Comment node) {
     String comment = node.value;
     int lineno = node.location.start.line + 1;
     int charno = node.location.start.column;
@@ -603,23 +678,24 @@ class NewIRFactory {
                                charno + numOpeningChars),
           comment,
           node.location.start.offset,
-          irNode,
+          null,
+          sourceFile,
           config,
           errorReporter);
     return parser.parseInlineTypeDoc();
   }
 
   // Set the length on the node if we're in IDE mode.
-  private void maybeSetLengthFrom(Node node, ParseTree source) {
+  private void maybeSetLength(
+      Node node, SourcePosition start, SourcePosition end) {
     if (config.isIdeMode) {
-      node.setLength(source.location.end.offset - source.location.start.offset);
+      node.setLength(end.offset - start.offset);
     }
   }
 
-  private void maybeSetLengthFrom(Node node,
-      com.google.javascript.jscomp.parsing.parser.Token source) {
+  private void maybeSetLengthFrom(Node node, Node ref) {
     if (config.isIdeMode) {
-      node.setLength(source.location.end.offset - source.location.start.offset);
+      node.setLength(ref.getLength());
     }
   }
 
@@ -673,7 +749,8 @@ class NewIRFactory {
         ret = transformNumberAsString(token.asLiteral());
         ret.putBooleanProp(Node.QUOTED_PROP, true);
       } else {
-        ret = newStringNode(Token.STRING, token.asLiteral().toString());
+        ret = newStringNode(Token.STRING,
+            normalizeString(token.asLiteral().toString()));
         ret.putBooleanProp(Node.QUOTED_PROP, true);
       }
       Preconditions.checkState(ret.isString());
@@ -849,9 +926,7 @@ class NewIRFactory {
       Boolean isUnnamedFunction = false;
       Node newName;
       if (name != null) {
-        // TODO(johnlenz): handle inline jsdoc
-        // newName = transformNodeWithInlineJsDoc(name);
-        newName = processName(name);
+        newName = processNameWithInlineJSDoc(name);
       } else {
         /*
         int functionType = functionNode.getFunctionType();
@@ -887,16 +962,7 @@ class NewIRFactory {
       Node node = newNode(Token.FUNCTION);
 
       node.addChildToBack(newName);
-      Node lp = newNode(Token.PARAM_LIST);
-      // setSourceInfo(lp, functionNode.formalParameterList);
-
-      for (ParseTree param : functionNode.formalParameterList.parameters) {
-        Node paramNode = transformNodeWithInlineJsDoc(param);
-        // We only support simple names for the moment.
-        Preconditions.checkState(paramNode.isName());
-        lp.addChildToBack(paramNode);
-      }
-      node.addChildToBack(lp);
+      node.addChildToBack(transform(functionNode.formalParameterList));
 
       Node bodyNode = transform(functionNode.functionBody);
       if (!bodyNode.isBlock()) {
@@ -910,6 +976,18 @@ class NewIRFactory {
      return node;
     }
 
+    @Override
+    Node processFormalParameterList(FormalParameterListTree tree) {
+      Node params = newNode(Token.PARAM_LIST);
+      for (ParseTree param : tree.parameters) {
+        Node paramNode = transformNodeWithInlineJsDoc(param, false);
+        // We only support simple names for the moment.
+        Preconditions.checkState(paramNode.isName());
+        params.addChildToBack(paramNode);
+      }
+      return params;
+    }
+
     @Override
     Node processIfStatement(IfStatementTree statementNode) {
       Node node = newNode(Token.IF);
@@ -973,8 +1051,9 @@ class NewIRFactory {
 
     @Override
     Node processLabeledStatement(LabelledStatementTree labelTree) {
-      Node node = newNode(Token.LABEL);
-      node.addChildToBack(transformLabelName(labelTree.name));
+      Node node = newNode(Token.LABEL,
+          transformLabelName(labelTree.name),
+          transform(labelTree.statement));
       return node;
     }
 
@@ -996,6 +1075,7 @@ class NewIRFactory {
       if (asString) {
         node = newStringNode(Token.STRING, identifierToken.toString());
       } else {
+        JSDocInfo info = handleJsDoc(identifierToken);
         if (identifierToken == null ||
             isReservedKeyword(identifierToken.toString())) {
           errorReporter.error(
@@ -1004,6 +1084,29 @@ class NewIRFactory {
             identifierToken.location.start.line, "", 0);
         }
         node = newStringNode(Token.NAME, identifierToken.toString());
+        if (info != null) {
+          // validateTypeAnnotations(info, identifierToken);
+          attachJSDoc(info, node);
+        }
+      }
+      setSourceInfo(node, identifierToken);
+      return node;
+    }
+
+    Node processNameWithInlineJSDoc(IdentifierToken identifierToken) {
+      Node node;
+      JSDocInfo info = handleInlineJsDoc(identifierToken, true);
+      if (identifierToken == null ||
+          isReservedKeyword(identifierToken.toString())) {
+        errorReporter.error(
+          "identifier is a reserved word",
+          sourceName,
+          identifierToken.location.start.line, "", 0);
+      }
+      node = newStringNode(Token.NAME, identifierToken.toString());
+      if (info != null) {
+        // validateTypeAnnotations(info, identifierToken);
+        attachJSDoc(info, node);
       }
       setSourceInfo(node, identifierToken);
       return node;
@@ -1028,16 +1131,17 @@ class NewIRFactory {
       Node node = newNode(
           Token.NEW,
           transform(exprNode.operand));
-      for (ParseTree arg : exprNode.arguments.arguments) {
-        node.addChildToBack(transform(arg));
+      if (exprNode.arguments != null) {
+        for (ParseTree arg : exprNode.arguments.arguments) {
+          node.addChildToBack(transform(arg));
+        }
       }
       return node;
     }
 
     @Override
     Node processNumberLiteral(LiteralExpressionTree literalNode) {
-      // TODO(johnlenz): use the correct translation
-      double value = Double.valueOf(literalNode.literalToken.asLiteral().value);
+      double value = normalizeNumber(literalNode.literalToken.asLiteral());
       return newNumberNode(value);
     }
 
@@ -1055,52 +1159,56 @@ class NewIRFactory {
           }
         }
 
-
-        Node key;
-        Node value;
-        switch (el.type) {
-          case PROPERTY_NAME_ASSIGNMENT: {
-              PropertyNameAssignmentTree prop = el.asPropertyNameAssignment();
-              key = transformAsString(prop.name);
-              key.setType(Token.STRING_KEY);
-              value = transform(prop.value);
-            }
-            break;
-
-          case GET_ACCESSOR: {
-              GetAccessorTree prop = el.asGetAccessor();
-              key = transformAsString(prop.propertyName);
-              key.setType(Token.GETTER_DEF);
-              Node body = transform(prop.body);
-              value = IR.function(IR.name(""), IR.paramList(), body);
-            }
-            break;
-
-          case SET_ACCESSOR: {
-              SetAccessorTree prop = el.asSetAccessor();
-              key = transformAsString(prop.propertyName);
-              key.setType(Token.SETTER_DEF);
-              Node body = transform(prop.body);
-              value = IR.function(IR.name(""), IR.paramList(
-                  safeProcessName(prop.parameter)), body);
-            }
-            break;
-
-         default:
-           throw new IllegalStateException("Unexpected node type: " + el.type);
-        }
-
+        Node key = transform(el);
         if (!key.isQuotedString() && !isAllowedProp(key.getString())) {
           errorReporter.warning(INVALID_ES3_PROP_NAME, sourceName,
               key.getLineno(), "", key.getCharno());
         }
 
-        key.addChildToFront(value);
         node.addChildToBack(key);
       }
       return node;
     }
 
+    @Override
+    Node processGetAccessor(GetAccessorTree tree) {
+      Node key = transformAsString(tree.propertyName);
+      key.setType(Token.GETTER_DEF);
+      Node body = transform(tree.body);
+      Node dummyName = IR.name("");
+      setSourceInfo(dummyName, tree.body);
+      Node paramList = IR.paramList();
+      setSourceInfo(paramList, tree.body);
+      Node value = IR.function(dummyName, paramList, body);
+      setSourceInfo(value, tree.body);
+      key.addChildToFront(value);
+      return key;
+    }
+
+    @Override
+    Node processSetAccessor(SetAccessorTree tree) {
+      Node key = transformAsString(tree.propertyName);
+      key.setType(Token.SETTER_DEF);
+      Node body = transform(tree.body);
+      Node dummyName = IR.name("");
+      setSourceInfo(dummyName, tree.propertyName);
+      Node paramList = IR.paramList(
+          safeProcessName(tree.parameter));
+      setSourceInfo(paramList, tree.parameter);
+      Node value = IR.function(dummyName, paramList, body);
+      setSourceInfo(value, tree.body);
+      key.addChildToFront(value);
+      return key;
+    }
+
+    @Override
+    Node processPropertyNameAssignment(PropertyNameAssignmentTree tree) {
+      Node key = transformAsString(tree.name);
+      key.setType(Token.STRING_KEY);
+      key.addChildToFront(transform(tree.value));
+      return key;
+    }
+
     private Node safeProcessName(IdentifierToken identifierToken) {
       if (identifierToken == null) {
         return createMissingExpressionNode();
@@ -1144,7 +1252,7 @@ class NewIRFactory {
       String value = rawRegex.substring(1, lastSlash);
       String flags = "";
       if (lastSlash < rawRegex.length()) {
-        flags = rawRegex.substring(rawRegex.lastIndexOf('/'));
+        flags = rawRegex.substring(rawRegex.lastIndexOf('/') + 1);
       }
 
       Node literalStringNode = newStringNode(value);
@@ -1154,7 +1262,7 @@ class NewIRFactory {
       if (!flags.isEmpty()) {
         Node flagsNode = newStringNode(flags);
         // TODO(johnlenz): fix the source location.
-        setSourceInfo(literalStringNode, token);
+        setSourceInfo(flagsNode, token);
         node.addChildToBack(flagsNode);
       }
       return node;
@@ -1200,99 +1308,6 @@ class NewIRFactory {
       return n;
     }
 
-    private String normalizeString(String value) {
-      StringBuilder result = new StringBuilder();
-      int start = 1; // skip the leading quote
-      int cur = value.indexOf('\\');
-      if (cur == -1) {
-        // short circuit no escapes.
-        return value;
-      }
-      while (cur != -1) {
-        if (cur - start > 0) {
-          result.append(value.substring(start, cur));
-        }
-        cur += 1; // skip the escape char.
-        char c = value.charAt(cur);
-        switch (c) {
-          case '\'':
-          case '"':
-          case '\\':
-            result.append(c);
-            break;
-          case 'b':
-            result.append('\b');
-            break;
-          case 'f':
-            result.append('\f');
-            break;
-          case 'n':
-            result.append('\n');
-            break;
-          case 'r':
-            result.append('\r');
-            break;
-          case 't':
-            result.append('\t');
-            break;
-          case 'v':
-            result.append('\u000B');
-            break;
-          case '\n':
-            // line continuation, skip the line break
-            break;
-          case '0':
-            // TODO(johnlenz): support octal?
-            result.append('\0');
-            break;
-          case 'x':
-            result.append((char)(
-                hexdigit(value.charAt(cur + 1)) * 16
-                + hexdigit(value.charAt(cur + 2))));
-            cur += 2;
-            break;
-          case 'u':
-            result.append((char)(
-                hexdigit(value.charAt(cur + 1)) * 16 * 16 * 16
-                + hexdigit(value.charAt(cur + 2)) * 16 * 16
-                + hexdigit(value.charAt(cur + 3)) * 16
-                + hexdigit(value.charAt(cur + 4))));
-            cur += 4;
-            break;
-          default:
-            result.append(c);
-            break;
-        }
-        start = cur + 1;
-        cur = value.indexOf('\\', start);
-      }
-      result.append(value.substring(start, value.length() -1));
-      // skip the trailing quote.
-
-      return result.toString();
-    }
-
-    int hexdigit(char c) {
-      switch (c) {
-        case '0': return 0;
-        case '1': return 1;
-        case '2': return 2;
-        case '3': return 3;
-        case '4': return 4;
-        case '5': return 5;
-        case '6': return 6;
-        case '7': return 7;
-        case '8': return 8;
-        case '9': return 9;
-        case 'a': case 'A': return 10;
-        case 'b': case 'B': return 11;
-        case 'c': case 'C': return 12;
-        case 'd': case 'D': return 13;
-        case 'e': case 'E': return 14;
-        case 'f': case 'F': return 15;
-      }
-      throw new IllegalStateException("unexpected: " + c);
-    }
 
     @Override
     Node processSwitchCase(CaseClauseTree caseNode) {
@@ -1300,9 +1315,7 @@ class NewIRFactory {
       Node node = newNode(Token.CASE, transform(expr));
       Node block = newNode(Token.BLOCK);
       block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);
-      block.setLineno(lineno(caseNode));
-      block.setCharno(charno(caseNode));
-      maybeSetLengthFrom(block, caseNode);
+      setSourceInfo(block, caseNode);
       if (caseNode.statements != null) {
         for (ParseTree child : caseNode.statements) {
           block.addChildToBack(transform(child));
@@ -1317,9 +1330,7 @@ class NewIRFactory {
       Node node = newNode(Token.DEFAULT_CASE);
       Node block = newNode(Token.BLOCK);
       block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);
-      block.setLineno(lineno(caseNode));
-      block.setCharno(charno(caseNode));
-      maybeSetLengthFrom(block, caseNode);
+      setSourceInfo(block, caseNode);
       if (caseNode.statements != null) {
         for (ParseTree child : caseNode.statements) {
           block.addChildToBack(transform(child));
@@ -1353,14 +1364,15 @@ class NewIRFactory {
       boolean lineSet = false;
 
       ParseTree cc = statementNode.catchBlock;
-
-      // Mark the enclosing block at the same line as the first catch
-      // clause.
-      if (lineSet == false) {
-        setSourceInfo(block, cc);
-        lineSet = true;
+      if (cc != null) {
+        // Mark the enclosing block at the same line as the first catch
+        // clause.
+        if (lineSet == false) {
+          setSourceInfo(block, cc);
+          lineSet = true;
+        }
+        block.addChildToBack(transform(cc));
       }
-      block.addChildToBack(transform(cc));
 
       node.addChildToBack(block);
 
@@ -1460,7 +1472,8 @@ class NewIRFactory {
 
     @Override
     Node processVariableStatement(VariableStatementTree stmt) {
-      return processVariableDeclarationList(stmt.declarations);
+      // skip the special handling so the doc is attached in the right place.
+      return justTransform(stmt.declarations);
     }
 
     @Override
@@ -1474,22 +1487,15 @@ class NewIRFactory {
 
       Node node = newNode(Token.VAR);
       for (VariableDeclarationTree child : decl.declarations) {
-        node.addChildToBack(transform(child));
+        node.addChildToBack(
+            transformNodeWithInlineJsDoc(child, true));
       }
       return node;
     }
 
     @Override
     Node processVariableDeclaration(VariableDeclarationTree decl) {
-      Node node;
-      Comment comment = getJsDocNode(decl.lvalue);
-      // TODO(user): At some point, consider allowing only inline jsdocs for
-      // variable initializers
-      if (comment != null && !comment.value.contains("@")) {
-        node = transformNodeWithInlineJsDoc(decl.lvalue);
-      } else {
-        node = transform(decl.lvalue);
-      }
+      Node node = transformNodeWithInlineJsDoc(decl.lvalue, true);
       if (decl.initializer != null) {
         Node initalizer = transform(decl.initializer);
         node.addChildToBack(initalizer);
@@ -1576,12 +1582,17 @@ class NewIRFactory {
     @Override
     Node processCommaExpression(CommaExpressionTree tree) {
       Node root = newNode(Token.COMMA);
+      SourcePosition start = tree.expressions.get(0).location.start;
+      SourcePosition end = tree.expressions.get(1).location.end;
+      setSourceInfo(root, start, end);
       for (ParseTree expr : tree.expressions) {
         int count = root.getChildCount();
         if (count < 2) {
           root.addChildrenToBack(transform(expr));
         } else {
+          end = expr.location.end;
           root = newNode(Token.COMMA, root, transform(expr));
+          setSourceInfo(root, start, end);
         }
       }
       return root;
@@ -1597,6 +1608,179 @@ class NewIRFactory {
     }
   }
 
+  private String normalizeString(String value) {
+    StringBuilder result = new StringBuilder();
+    int start = 1; // skip the leading quote
+    int cur = value.indexOf('\\');
+    if (cur == -1) {
+      // short circuit no escapes.
+      return value.substring(1, value.length() - 1);
+    }
+    while (cur != -1) {
+      if (cur - start > 0) {
+        result.append(value.substring(start, cur));
+      }
+      cur += 1; // skip the escape char.
+      char c = value.charAt(cur);
+      switch (c) {
+        case '\'':
+        case '"':
+        case '\\':
+          result.append(c);
+          break;
+        case 'b':
+          result.append('\b');
+          break;
+        case 'f':
+          result.append('\f');
+          break;
+        case 'n':
+          result.append('\n');
+          break;
+        case 'r':
+          result.append('\r');
+          break;
+        case 't':
+          result.append('\t');
+          break;
+        case 'v':
+          result.append('\u000B');
+          break;
+        case '\n':
+          // line continuation, skip the line break
+          break;
+        case '0':
+          // TODO(johnlenz): support octal?
+          result.append('\0');
+          break;
+        case 'x':
+          result.append((char) (
+              hexdigit(value.charAt(cur + 1)) * 16
+              + hexdigit(value.charAt(cur + 2))));
+          cur += 2;
+          break;
+        case 'u':
+          result.append((char) (
+              hexdigit(value.charAt(cur + 1)) * 16 * 16 * 16
+              + hexdigit(value.charAt(cur + 2)) * 16 * 16
+              + hexdigit(value.charAt(cur + 3)) * 16
+              + hexdigit(value.charAt(cur + 4))));
+          cur += 4;
+          break;
+        default:
+          result.append(c);
+          break;
+      }
+      start = cur + 1;
+      cur = value.indexOf('\\', start);
+    }
+    // skip the trailing quote.
+    result.append(value.substring(start, value.length() - 1));
+
+    return result.toString();
+  }
+
+  double normalizeNumber(LiteralToken token) {
+    String value = token.value;
+    SourceRange location = token.location;
+    int length = value.length();
+    Preconditions.checkState(length > 0);
+    Preconditions.checkState(value.charAt(0) != '-'
+        && value.charAt(0) != '+');
+    if (value.charAt(0) == '.') {
+      return Double.valueOf("0" + value);
+    } else if (value.charAt(0) == '0' && length > 1) {
+      // TODO(johnlenz): accept octal numbers in es3 etc.
+      switch (value.charAt(1)) {
+        case '.':
+          return Double.valueOf(value);
+        case 'b':
+        case 'B': {
+          long v = 0;
+          int c = 2;
+          while (++c < length) {
+            v = (v * 2) + binarydigit(value.charAt(c));
+          }
+          return Double.valueOf(v);
+        }
+        case 'o':
+        case 'O': {
+          long v = 0;
+          int c = 2;
+          while (++c < length) {
+            v = (v * 8) + octaldigit(value.charAt(c));
+          }
+          return Double.valueOf(v);
+        }
+        case 'x':
+        case 'X': {
+          long v = 0;
+          int c = 2;
+          while (++c < length) {
+            v = (v * 16) + hexdigit(value.charAt(c));
+          }
+          return Double.valueOf(v);
+        }
+        case '0': case '1': case '2': case '3':
+        case '4': case '5': case '6': case '7':
+          errorReporter.warning(INVALID_ES5_STRICT_OCTAL, sourceName,
+              lineno(location.start), "", charno(location.start));
+          long v = 0;
+          int c = 1;
+          while (++c < length) {
+            v = (v * 8) + octaldigit(value.charAt(c));
+          }
+          return Double.valueOf(v);
+      }
+    } else {
+      return Double.valueOf(value);
+    }
+    throw new IllegalStateException("unexpected");
+  }
+
+  int binarydigit(char c) {
+    if (c >= '0' && c <= '1') {
+      return (c - '0');
+    }
+    throw new IllegalStateException("unexpected: " + c);
+  }
+
+  int octaldigit(char c) {
+    if (c >= '0' && c <= '7') {
+      return (c - '0');
+    }
+    throw new IllegalStateException("unexpected: " + c);
+  }
+
+  int digit(char c) {
+    if (c >= '0' && c <= '9') {
+      return (c - '0');
+    }
+    throw new IllegalStateException("unexpected: " + c);
+  }
+
+  int hexdigit(char c) {
+    switch (c) {
+      case '0': return 0;
+      case '1': return 1;
+      case '2': return 2;
+      case '3': return 3;
+      case '4': return 4;
+      case '5': return 5;
+      case '6': return 6;
+      case '7': return 7;
+      case '8': return 8;
+      case '9': return 9;
+      case 'a': case 'A': return 10;
+      case 'b': case 'B': return 11;
+      case 'c': case 'C': return 12;
+      case 'd': case 'D': return 13;
+      case 'e': case 'E': return 14;
+      case 'f': case 'F': return 15;
+    }
+    throw new IllegalStateException("unexpected: " + c);
+  }
+
   private static int transformBooleanTokenType(TokenType token) {
     switch (token) {
       case TRUE:
diff --git a/src/com/google/javascript/jscomp/parsing/NewTypeSafeDispatcher.java b/src/com/google/javascript/jscomp/parsing/NewTypeSafeDispatcher.java
index 6f9cc721e..4d419f929 100644
--- a/src/com/google/javascript/jscomp/parsing/NewTypeSafeDispatcher.java
+++ b/src/com/google/javascript/jscomp/parsing/NewTypeSafeDispatcher.java
@@ -34,7 +34,9 @@ import com.google.javascript.jscomp.parsing.parser.trees.ExpressionStatementTree
 import com.google.javascript.jscomp.parsing.parser.trees.FinallyTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ForInStatementTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ForStatementTree;
+import com.google.javascript.jscomp.parsing.parser.trees.FormalParameterListTree;
 import com.google.javascript.jscomp.parsing.parser.trees.FunctionDeclarationTree;
+import com.google.javascript.jscomp.parsing.parser.trees.GetAccessorTree;
 import com.google.javascript.jscomp.parsing.parser.trees.IdentifierExpressionTree;
 import com.google.javascript.jscomp.parsing.parser.trees.IfStatementTree;
 import com.google.javascript.jscomp.parsing.parser.trees.LabelledStatementTree;
@@ -49,7 +51,9 @@ import com.google.javascript.jscomp.parsing.parser.trees.ParenExpressionTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ParseTree;
 import com.google.javascript.jscomp.parsing.parser.trees.PostfixExpressionTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ProgramTree;
+import com.google.javascript.jscomp.parsing.parser.trees.PropertyNameAssignmentTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ReturnStatementTree;
+import com.google.javascript.jscomp.parsing.parser.trees.SetAccessorTree;
 import com.google.javascript.jscomp.parsing.parser.trees.SwitchStatementTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ThisExpressionTree;
 import com.google.javascript.jscomp.parsing.parser.trees.ThrowStatementTree;
@@ -65,53 +69,57 @@ import com.google.javascript.jscomp.parsing.parser.trees.WithStatementTree;
  * Type safe dispatcher interface for use with new ES6 parser ASTs.
  */
 abstract class NewTypeSafeDispatcher<T> {
-  abstract T processArrayLiteral(ArrayLiteralExpressionTree arrayLiteralExpressionTree);
-  abstract T processAstRoot(ProgramTree programTree);
-  abstract T processBlock(BlockTree blockTree);
+  abstract T processArrayLiteral(ArrayLiteralExpressionTree tree);
+  abstract T processAstRoot(ProgramTree tree);
+  abstract T processBlock(BlockTree tree);
   abstract T processBreakStatement(BreakStatementTree breakStatementTree);
-  abstract T processCatchClause(CatchTree catchTree);
-  abstract T processConditionalExpression(ConditionalExpressionTree conditionalExpressionTree);
-  abstract T processContinueStatement(ContinueStatementTree continueStatementTree);
-  abstract T processDoLoop(DoWhileStatementTree doWhileStatementTree);
-  abstract T processElementGet(MemberLookupExpressionTree memberLookupExpressionTree);
-  abstract T processEmptyStatement(EmptyStatementTree emptyStatementTree);
-  abstract T processExpressionStatement(ExpressionStatementTree expressionStatementTree);
-  abstract T processForInLoop(ForInStatementTree forInStatementTree);
-  abstract T processForLoop(ForStatementTree forStatementTree);
-  abstract T processFunctionCall(CallExpressionTree callExpressionTree);
-  abstract T processFunction(FunctionDeclarationTree functionDeclarationTree);
-  abstract T processIfStatement(IfStatementTree ifStatementTree);
-  abstract T processBinaryExpression(BinaryOperatorTree binaryOperatorTree);
-  abstract T processLabeledStatement(LabelledStatementTree labelledStatementTree);
-  abstract T processName(IdentifierExpressionTree identifierExpressionTree);
-  abstract T processNewExpression(NewExpressionTree newExpressionTree);
-  abstract T processNumberLiteral(LiteralExpressionTree literalNode);
-  abstract T processObjectLiteral(ObjectLiteralExpressionTree objectLiteralExpressionTree);
-  abstract T processParenthesizedExpression(ParenExpressionTree parenExpressionTree);
-  abstract T processPropertyGet(MemberExpressionTree memberExpressionTree);
-  abstract T processRegExpLiteral(LiteralExpressionTree literalNode);
-  abstract T processReturnStatement(ReturnStatementTree returnStatementTree);
-  abstract T processStringLiteral(LiteralExpressionTree literalNode);
-  abstract T processSwitchCase(CaseClauseTree caseClauseTree);
-  abstract T processSwitchStatement(SwitchStatementTree switchStatementTree);
-  abstract T processThrowStatement(ThrowStatementTree throwStatementTree);
-  abstract T processTryStatement(TryStatementTree tryStatementTree);
-  abstract T processUnaryExpression(UnaryExpressionTree unaryExpressionTree);
-  abstract T processVariableStatement(VariableStatementTree variableStatementTree);
-  abstract T processVariableDeclarationList(VariableDeclarationListTree decl);
+  abstract T processCatchClause(CatchTree tree);
+  abstract T processConditionalExpression(ConditionalExpressionTree tree);
+  abstract T processContinueStatement(ContinueStatementTree tree);
+  abstract T processDoLoop(DoWhileStatementTree tree);
+  abstract T processElementGet(MemberLookupExpressionTree tree);
+  abstract T processEmptyStatement(EmptyStatementTree tree);
+  abstract T processExpressionStatement(ExpressionStatementTree tree);
+  abstract T processForInLoop(ForInStatementTree tree);
+  abstract T processForLoop(ForStatementTree tree);
+  abstract T processFunctionCall(CallExpressionTree tree);
+  abstract T processFunction(FunctionDeclarationTree tree);
+  abstract T processIfStatement(IfStatementTree tree);
+  abstract T processBinaryExpression(BinaryOperatorTree tree);
+  abstract T processLabeledStatement(LabelledStatementTree tree);
+  abstract T processName(IdentifierExpressionTree tree);
+  abstract T processNewExpression(NewExpressionTree tree);
+  abstract T processNumberLiteral(LiteralExpressionTree tree);
+  abstract T processObjectLiteral(ObjectLiteralExpressionTree tree);
+  abstract T processParenthesizedExpression(ParenExpressionTree tree);
+  abstract T processPropertyGet(MemberExpressionTree tree);
+  abstract T processRegExpLiteral(LiteralExpressionTree tree);
+  abstract T processReturnStatement(ReturnStatementTree tree);
+  abstract T processStringLiteral(LiteralExpressionTree tree);
+  abstract T processSwitchCase(CaseClauseTree tree);
+  abstract T processSwitchStatement(SwitchStatementTree tree);
+  abstract T processThrowStatement(ThrowStatementTree tree);
+  abstract T processTryStatement(TryStatementTree tree);
+  abstract T processUnaryExpression(UnaryExpressionTree tree);
+  abstract T processVariableStatement(VariableStatementTree tree);
+  abstract T processVariableDeclarationList(VariableDeclarationListTree tree);
   abstract T processVariableDeclaration(VariableDeclarationTree decl);
-  abstract T processWhileLoop(WhileStatementTree whileStatementTree);
-  abstract T processWithStatement(WithStatementTree withStatementTree);
+  abstract T processWhileLoop(WhileStatementTree tree);
+  abstract T processWithStatement(WithStatementTree tree);
 
-  abstract T processDebuggerStatement(DebuggerStatementTree asDebuggerStatement);
-  abstract T processThisExpression(ThisExpressionTree asThisExpression);
-  abstract T processSwitchDefault(DefaultClauseTree asDefaultClause);
-  abstract T processBooleanLiteral(LiteralExpressionTree literalNode);
-  abstract T processNullLiteral(LiteralExpressionTree literalNode);
+  abstract T processDebuggerStatement(DebuggerStatementTree tree);
+  abstract T processThisExpression(ThisExpressionTree tree);
+  abstract T processSwitchDefault(DefaultClauseTree tree);
+  abstract T processBooleanLiteral(LiteralExpressionTree tree);
+  abstract T processNullLiteral(LiteralExpressionTree tree);
   abstract T processNull(NullTree literalNode);
   abstract T processPostfixExpression(PostfixExpressionTree tree);
   abstract T processCommaExpression(CommaExpressionTree tree);
   abstract T processFinally(FinallyTree tree);
+  abstract T processGetAccessor(GetAccessorTree tree);
+  abstract T processSetAccessor(SetAccessorTree tree);
+  abstract T processPropertyNameAssignment(PropertyNameAssignmentTree tree);
+  abstract T processFormalParameterList(FormalParameterListTree tree);
 
   abstract T processMissingExpression(MissingPrimaryExpressionTree tree);
 
@@ -124,6 +132,7 @@ abstract class NewTypeSafeDispatcher<T> {
         return processNumberLiteral(expr);
       case STRING:
         return processStringLiteral(expr);
+      case FALSE:
       case TRUE:
         return processBooleanLiteral(expr);
       case NULL:
@@ -230,15 +239,14 @@ abstract class NewTypeSafeDispatcher<T> {
       case MISSING_PRIMARY_EXPRESSION:
         return processMissingExpression(node.asMissingPrimaryExpression());
 
-      // Not handled directly
-      case SET_ACCESSOR:
-        break;
-      case GET_ACCESSOR:
-        break;
       case PROPERTY_NAME_ASSIGNMENT:
-        break;
+        return processPropertyNameAssignment(node.asPropertyNameAssignment());
+      case GET_ACCESSOR:
+        return processGetAccessor(node.asGetAccessor());
+      case SET_ACCESSOR:
+        return processSetAccessor(node.asSetAccessor());
       case FORMAL_PARAMETER_LIST:
-        break;
+        return processFormalParameterList(node.asFormalParameterList());
 
       case ARRAY_PATTERN:
       case OBJECT_PATTERN:
diff --git a/src/com/google/javascript/jscomp/parsing/parser/Parser.java b/src/com/google/javascript/jscomp/parsing/parser/Parser.java
index f5dfa79cc..63f2f70d6 100644
--- a/src/com/google/javascript/jscomp/parsing/parser/Parser.java
+++ b/src/com/google/javascript/jscomp/parsing/parser/Parser.java
@@ -461,9 +461,7 @@ public class Parser {
   private ParseTree parseFunctionDeclarationTail(
       SourcePosition start, boolean isStatic) {
     IdentifierToken name = eatId();
-    eat(TokenType.OPEN_PAREN);
     FormalParameterListTree formalParameterList = parseFormalParameterList();
-    eat(TokenType.CLOSE_PAREN);
     BlockTree functionBody = parseFunctionBody();
     return new FunctionDeclarationTree(
         getTreeLocation(start), name, isStatic, formalParameterList, functionBody);
@@ -473,15 +471,17 @@ public class Parser {
     SourcePosition start = getTreeStartLocation();
     nextToken(); // function or #
     IdentifierToken name = eatIdOpt();
-    eat(TokenType.OPEN_PAREN);
     FormalParameterListTree formalParameterList = parseFormalParameterList();
-    eat(TokenType.CLOSE_PAREN);
     BlockTree functionBody = parseFunctionBody();
     return new FunctionDeclarationTree(
         getTreeLocation(start), name, false, formalParameterList, functionBody);
   }
 
   private FormalParameterListTree parseFormalParameterList() {
+    SourcePosition listStart = getTreeStartLocation();
+    eat(TokenType.OPEN_PAREN);
+
+
     // FormalParameterList :
     //   ... Identifier
     //   FormalParameterListNoRest
@@ -521,7 +521,10 @@ public class Parser {
       }
     }
 
-    return new FormalParameterListTree(null, result.build());
+    eat(TokenType.CLOSE_PAREN);
+
+    return new FormalParameterListTree(
+        getTreeLocation(listStart), result.build());
   }
 
   private DefaultParameterTree parseDefaultParameter() {
@@ -909,17 +912,24 @@ public class Parser {
 
   // 12.6.3 The for Statement
   private ParseTree parseForStatement(SourcePosition start, ParseTree initializer) {
+    if (initializer == null) {
+      initializer = new NullTree(getTreeLocation(getTreeStartLocation()));
+    }
     eat(TokenType.SEMI_COLON);
 
     ParseTree condition = null;
     if (!peek(TokenType.SEMI_COLON)) {
       condition = parseExpression();
+    } else {
+      condition = new NullTree(getTreeLocation(getTreeStartLocation()));
     }
     eat(TokenType.SEMI_COLON);
 
     ParseTree increment = null;
     if (!peek(TokenType.CLOSE_PAREN)) {
       increment = parseExpression();
+    } else {
+      increment = new NullTree(getTreeLocation(getTreeStartLocation()));
     }
     eat(TokenType.CLOSE_PAREN);
     ParseTree body = parseStatement();
@@ -1208,7 +1218,7 @@ public class Parser {
     while (peek(TokenType.COMMA) || peek(TokenType.SPREAD) || peekAssignmentExpression()) {
       trailingCommaToken = null;
       if (peek(TokenType.COMMA)) {
-        elements.add(NullTree.Instance);
+        elements.add(new NullTree(getTreeLocation(getTreeStartLocation())));
       } else {
         if (peek(TokenType.SPREAD)) {
           elements.add(parseSpreadExpression());
diff --git a/src/com/google/javascript/jscomp/parsing/parser/trees/NullTree.java b/src/com/google/javascript/jscomp/parsing/parser/trees/NullTree.java
index 08739eebd..40f4ffc0b 100644
--- a/src/com/google/javascript/jscomp/parsing/parser/trees/NullTree.java
+++ b/src/com/google/javascript/jscomp/parsing/parser/trees/NullTree.java
@@ -22,7 +22,7 @@ import com.google.javascript.jscomp.parsing.parser.util.SourceRange;
  * Represents a null parse tree element.
  */
 public final class NullTree extends ParseTree {
-  private NullTree(SourceRange location) {
+  public NullTree(SourceRange location) {
     super(ParseTreeType.NULL, location);
   }
 
diff --git a/test/com/google/javascript/jscomp/parsing/NewParserTest.java b/test/com/google/javascript/jscomp/parsing/NewParserTest.java
index acdaad63f..9cbd58a31 100644
--- a/test/com/google/javascript/jscomp/parsing/NewParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/NewParserTest.java
@@ -264,7 +264,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertEquals(8, op.getCharno());
   }
 
-  public void disable_testJSDocAttachment1() {
+  public void testJSDocAttachment1() {
     Node varNode = parse("/** @type number */var a;").getFirstChild();
 
     // VAR
@@ -279,7 +279,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertNull(nameNode.getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment2() {
+  public void testJSDocAttachment2() {
     Node varNode = parse("/** @type number */var a,b;").getFirstChild();
 
     // VAR
@@ -299,7 +299,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertNull(nameNode2.getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment3() {
+  public void testJSDocAttachment3() {
     Node assignNode = parse(
         "/** @type number */goog.FOO = 5;").getFirstChild().getFirstChild();
     assertEquals(Token.ASSIGN, assignNode.getType());
@@ -308,7 +308,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertTypeEquals(NUMBER_TYPE, info.getType());
   }
 
-  public void disable_testJSDocAttachment4() {
+  public void testJSDocAttachment4() {
     Node varNode = parse(
         "var a, /** @define {number} */ b = 5;").getFirstChild();
 
@@ -328,7 +328,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertTypeEquals(NUMBER_TYPE, info.getType());
   }
 
-  public void disable_testJSDocAttachment5() {
+  public void testJSDocAttachment5() {
     Node varNode = parse(
         "var /** @type number */a, /** @define {number} */b = 5;")
         .getFirstChild();
@@ -357,7 +357,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
    * Tests that a JSDoc comment in an unexpected place of the code does not
    * propagate to following code due to {@link JSDocInfo} aggregation.
    */
-  public void disable_testJSDocAttachment6() throws Exception {
+  public void testJSDocAttachment6() throws Exception {
     Node functionNode = parse(
         "var a = /** @param {number} index */5;" +
         "/** @return boolean */function f(index){}")
@@ -371,7 +371,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertTypeEquals(UNKNOWN_TYPE, info.getReturnType());
   }
 
-  public void disable_testJSDocAttachment7() {
+  public void testJSDocAttachment7() {
     Node varNode = parse("/** */var a;").getFirstChild();
 
     // VAR
@@ -383,7 +383,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertNull(nameNode.getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment8() {
+  public void testJSDocAttachment8() {
     Node varNode = parse("/** x */var a;").getFirstChild();
 
     // VAR
@@ -395,7 +395,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertNull(nameNode.getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment9() {
+  public void testJSDocAttachment9() {
     Node varNode = parse("/** \n x */var a;").getFirstChild();
 
     // VAR
@@ -407,7 +407,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertNull(nameNode.getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment10() {
+  public void testJSDocAttachment10() {
     Node varNode = parse("/** x\n */var a;").getFirstChild();
 
     // VAR
@@ -419,7 +419,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertNull(nameNode.getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment11() {
+  public void testJSDocAttachment11() {
     Node varNode =
        parse("/** @type {{x : number, 'y' : string, z}} */var a;")
         .getFirstChild();
@@ -442,7 +442,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertNull(nameNode.getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment12() {
+  public void testJSDocAttachment12() {
     Node varNode =
        parse("var a = {/** @type {Object} */ b: c};")
         .getFirstChild();
@@ -451,22 +451,22 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertNotNull(objectLitNode.getFirstChild().getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment13() {
+  public void testJSDocAttachment13() {
     Node varNode = parse("/** foo */ var a;").getFirstChild();
     assertNotNull(varNode.getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment14() {
+  public void testJSDocAttachment14() {
     Node varNode = parse("/** */ var a;").getFirstChild();
     assertNull(varNode.getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment15() {
+  public void testJSDocAttachment15() {
     Node varNode = parse("/** \n * \n */ var a;").getFirstChild();
     assertNull(varNode.getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment16() {
+  public void testJSDocAttachment16() {
     Node exprCall =
         parse("/** @private */ x(); function f() {};").getFirstChild();
     assertEquals(Token.EXPR_RESULT, exprCall.getType());
@@ -474,7 +474,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertNotNull(exprCall.getFirstChild().getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment17() {
+  public void testJSDocAttachment17() {
     Node fn =
         parse(
             "function f() { " +
@@ -485,7 +485,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertEquals(Token.CAST, cast.getType());
   }
 
-  public void disable_testJSDocAttachment18() {
+  public void testJSDocAttachment18() {
     Node fn =
         parse(
             "function f() { " +
@@ -497,7 +497,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertEquals(Token.CAST, cast.getType());
   }
 
-  public void disable_testJSDocAttachment19() {
+  public void testJSDocAttachment19() {
     Node fn =
         parse(
             "function f() { " +
@@ -511,7 +511,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertNull(ret.getJSDocInfo());
   }
 
-  public void disable_testJSDocAttachment20() {
+  public void testJSDocAttachment20() {
     Node fn =
         parse(
             "function f() { " +
@@ -525,7 +525,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertNull(ret.getJSDocInfo());
   }
 
-  public void disable_testInlineJSDocAttachment1() {
+  public void testInlineJSDocAttachment1() {
     Node fn = parse("function f(/** string */ x) {}").getFirstChild();
     assertTrue(fn.isFunction());
 
@@ -535,7 +535,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertTypeEquals(STRING_TYPE, info.getType());
   }
 
-  public void disable_testInlineJSDocAttachment2() {
+  public void testInlineJSDocAttachment2() {
     Node fn = parse(
         "function f(/** ? */ x) {}").getFirstChild();
     assertTrue(fn.isFunction());
@@ -546,13 +546,13 @@ public class NewParserTest extends BaseJSTypeTestCase {
     assertTypeEquals(UNKNOWN_TYPE, info.getType());
   }
 
-  public void disable_testInlineJSDocAttachment3() {
+  public void testInlineJSDocAttachment3() {
     parse(
         "function f(/** @type {string} */ x) {}",
         "Bad type annotation. type not recognized due to syntax error");
   }
 
-  public void disable_testInlineJSDocAttachment4() {
+  public void testInlineJSDocAttachment4() {
     parse(
         "function f(/**\n" +
         " * @type {string}\n" +
@@ -560,14 +560,15 @@ public class NewParserTest extends BaseJSTypeTestCase {
         "Bad type annotation. type not recognized due to syntax error");
   }
 
-  public void disable_testInlineJSDocAttachment5() {
+  public void testInlineJSDocAttachment5() {
     Node vardecl = parse("var /** string */ x = 'asdf';").getFirstChild();
     JSDocInfo info = vardecl.getFirstChild().getJSDocInfo();
     assertNotNull(info);
+    assertTrue(info.hasType());
     assertTypeEquals(STRING_TYPE, info.getType());
   }
 
-  public void disable_testInlineJSDocAttachment6() {
+  public void testInlineJSDocAttachment6() {
     Node fn = parse("function f(/** {attr: number} */ x) {}").getFirstChild();
     assertTrue(fn.isFunction());
 
@@ -580,21 +581,21 @@ public class NewParserTest extends BaseJSTypeTestCase {
         info.getType());
   }
 
-  public void disable_testIncorrectJSDocDoesNotAlterJSParsing1() throws Exception {
+  public void testIncorrectJSDocDoesNotAlterJSParsing1() throws Exception {
     assertNodeEquality(
         parse("var a = [1,2]"),
         parse("/** @type Array.<number*/var a = [1,2]",
             MISSING_GT_MESSAGE));
   }
 
-  public void disable_testIncorrectJSDocDoesNotAlterJSParsing2() throws Exception {
+  public void testIncorrectJSDocDoesNotAlterJSParsing2() throws Exception {
     assertNodeEquality(
         parse("var a = [1,2]"),
         parse("/** @type {Array.<number}*/var a = [1,2]",
             MISSING_GT_MESSAGE));
   }
 
-  public void disable_testIncorrectJSDocDoesNotAlterJSParsing3() throws Exception {
+  public void testIncorrectJSDocDoesNotAlterJSParsing3() throws Exception {
     assertNodeEquality(
         parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
         parse("/** @param {Array.<number} nums */" +
@@ -602,7 +603,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
             MISSING_GT_MESSAGE));
   }
 
-  public void disable_testIncorrectJSDocDoesNotAlterJSParsing4() throws Exception {
+  public void testIncorrectJSDocDoesNotAlterJSParsing4() throws Exception {
     assertNodeEquality(
         parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
         parse("/** @return boolean */" +
@@ -616,7 +617,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
             "C.prototype.say=function(nums) {alert(nums.join(','));};"));
   }
 
-  public void disable_testIncorrectJSDocDoesNotAlterJSParsing6() throws Exception {
+  public void testIncorrectJSDocDoesNotAlterJSParsing6() throws Exception {
     assertNodeEquality(
         parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
         parse("/** @param {bool!*%E$} */" +
@@ -625,7 +626,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
             "Bad type annotation. expecting a variable name in a @param tag"));
   }
 
-  public void disable_testIncorrectJSDocDoesNotAlterJSParsing7() throws Exception {
+  public void testIncorrectJSDocDoesNotAlterJSParsing7() throws Exception {
     assertNodeEquality(
         parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
         parse("/** @see */" +
@@ -633,7 +634,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
               "@see tag missing description"));
   }
 
-  public void disable_testIncorrectJSDocDoesNotAlterJSParsing8() throws Exception {
+  public void testIncorrectJSDocDoesNotAlterJSParsing8() throws Exception {
     assertNodeEquality(
         parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
         parse("/** @author */" +
@@ -641,7 +642,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
               "@author tag missing author"));
   }
 
-  public void disable_testIncorrectJSDocDoesNotAlterJSParsing9() throws Exception {
+  public void testIncorrectJSDocDoesNotAlterJSParsing9() throws Exception {
     assertNodeEquality(
         parse("C.prototype.say=function(nums) {alert(nums.join(','));};"),
         parse("/** @someillegaltag */" +
@@ -728,19 +729,19 @@ public class NewParserTest extends BaseJSTypeTestCase {
         "'}' expected");
   }
 
-  public void disable_testSuspiciousBlockCommentWarning1() {
+  public void testSuspiciousBlockCommentWarning1() {
     parse("/* @type {number} */ var x = 3;", SUSPICIOUS_COMMENT_WARNING);
   }
 
-  public void disable_testSuspiciousBlockCommentWarning2() {
+  public void testSuspiciousBlockCommentWarning2() {
     parse("/* \n * @type {number} */ var x = 3;", SUSPICIOUS_COMMENT_WARNING);
   }
 
-  public void disable_testSuspiciousBlockCommentWarning3() {
+  public void testSuspiciousBlockCommentWarning3() {
     parse("/* \n *@type {number} */ var x = 3;", SUSPICIOUS_COMMENT_WARNING);
   }
 
-  public void disable_testSuspiciousBlockCommentWarning4() {
+  public void testSuspiciousBlockCommentWarning4() {
     parse(
         "  /*\n" +
         "   * @type {number}\n" +
@@ -749,7 +750,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
         SUSPICIOUS_COMMENT_WARNING);
   }
 
-  public void disable_testSuspiciousBlockCommentWarning5() {
+  public void testSuspiciousBlockCommentWarning5() {
     parse(
         "  /*\n" +
         "   * some random text here\n" +
@@ -759,16 +760,16 @@ public class NewParserTest extends BaseJSTypeTestCase {
         SUSPICIOUS_COMMENT_WARNING);
   }
 
-  public void disable_testSuspiciousBlockCommentWarning6() {
+  public void testSuspiciousBlockCommentWarning6() {
     parse("/* @type{number} */ var x = 3;", SUSPICIOUS_COMMENT_WARNING);
   }
 
-  public void disable_testSuspiciousBlockCommentWarning7() {
+  public void testSuspiciousBlockCommentWarning7() {
     // jsdoc tags contain letters only, no underscores etc.
     parse("/* @cc_on */ var x = 3;");
   }
 
-  public void disable_testSuspiciousBlockCommentWarning8() {
+  public void testSuspiciousBlockCommentWarning8() {
     // a jsdoc tag can't be immediately followed by a paren
     parse("/* @TODO(username) */ var x = 3;");
   }
@@ -873,7 +874,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
         "':' expected");
   }
 
-  public void disable_testFileOverviewJSDoc1() {
+  public void testFileOverviewJSDoc1() {
     Node n = parse("/** @fileoverview Hi mom! */ function Foo() {}");
     assertEquals(Token.FUNCTION, n.getFirstChild().getType());
     assertTrue(n.getJSDocInfo() != null);
@@ -901,7 +902,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
             .getFirstChild().getType());
   }
 
-  public void disable_testFileOverviewJSDoc2() {
+  public void testFileOverviewJSDoc2() {
     Node n = parse("/** @fileoverview Hi mom! */ " +
         "/** @constructor */ function Foo() {}");
     assertTrue(n.getJSDocInfo() != null);
@@ -919,8 +920,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
 
     Node number = objectLit.getFirstChild();
     assertEquals(Token.STRING_KEY, number.getType());
-    // TODO(johnlenz): reenable
-    // assertNotNull(number.getJSDocInfo());
+    assertNotNull(number.getJSDocInfo());
   }
 
   // TODO(johnlenz): check duplication and scoping later or build the basic
@@ -970,7 +970,7 @@ public class NewParserTest extends BaseJSTypeTestCase {
     parseError("/** this is a comment ", "unterminated comment");
   }
 
-  public void disable_testParseBlockDescription() {
+  public void testParseBlockDescription() {
     Node n = parse("/** This is a variable. */ var x;");
     Node var = n.getFirstChild();
     assertNotNull(var.getJSDocInfo());
@@ -996,9 +996,8 @@ public class NewParserTest extends BaseJSTypeTestCase {
         "identifier is a reserved word");
     parseError("boolean = 1;", "identifier is a reserved word");
 
-    // parseError("class = 1;", // "identifier is a reserved word");
-    //    "'identifier' expected");
-
+    // TODO(johnlenz): reenable
+    // parseError("class = 1;", "identifier is a reserved word");
     // parseError("public = 2;", "identifier is a reserved word");
 
     mode = LanguageMode.ECMASCRIPT5;
