diff --git a/lib/common/parse-features-string.js b/lib/common/parse-features-string.js
index 955ab8f480..1ef51092fd 100644
--- a/lib/common/parse-features-string.js
+++ b/lib/common/parse-features-string.js
@@ -4,12 +4,12 @@
 // - `features` input string
 // - `emit` function(key, value) - called for each parsed KV
 module.exports = function parseFeaturesString (features, emit) {
-  features = `${features}`
+  features = `${features}`.trim()
   // split the string by ','
-  features.split(/,\s*/).forEach((feature) => {
+  features.split(/\s*,\s*/).forEach((feature) => {
     // expected form is either a key by itself or a key/value pair in the form of
     // 'key=value'
-    let [key, value] = feature.split(/\s*=/)
+    let [key, value] = feature.split(/\s*=\s*/)
     if (!key) return
 
     // interpret the value as a boolean, if possible
diff --git a/spec/internal-spec.js b/spec/internal-spec.js
new file mode 100644
index 0000000000..fc3e23bf4d
--- /dev/null
+++ b/spec/internal-spec.js
@@ -0,0 +1,23 @@
+const chai = require('chai')
+const { expect } = chai
+
+describe('feature-string parsing', () => {
+  it('is indifferent to whitespace around keys and values', () => {
+    const parseFeaturesString = require('@electron/internal/common/parse-features-string')
+    const checkParse = (string, parsed) => {
+      const features = {}
+      parseFeaturesString(string, (k, v) => { features[k] = v })
+      expect(features).to.deep.equal(parsed)
+    }
+    checkParse('a=yes,c=d', { a: true, c: 'd' })
+    checkParse('a=yes ,c=d', { a: true, c: 'd' })
+    checkParse('a=yes, c=d', { a: true, c: 'd' })
+    checkParse('a=yes , c=d', { a: true, c: 'd' })
+    checkParse(' a=yes , c=d', { a: true, c: 'd' })
+    checkParse(' a= yes , c=d', { a: true, c: 'd' })
+    checkParse(' a = yes , c=d', { a: true, c: 'd' })
+    checkParse(' a = yes , c =d', { a: true, c: 'd' })
+    checkParse(' a = yes , c = d', { a: true, c: 'd' })
+    checkParse(' a = yes , c = d ', { a: true, c: 'd' })
+  })
+})
